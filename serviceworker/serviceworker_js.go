// Code generated by webidl-bind. DO NOT EDIT.

package serviceworker

import "syscall/js"

import (
	"github.com/gowebapi/webapi/appmanifest/appmenifestres"
	"github.com/gowebapi/webapi/core"
	"github.com/gowebapi/webapi/dom/domcore"
	"github.com/gowebapi/webapi/fetch"
	"github.com/gowebapi/webapi/html/channel"
	"github.com/gowebapi/webapi/html/htmlcommon"
	"github.com/gowebapi/webapi/javascript"
	"github.com/gowebapi/webapi/payment"
	"github.com/gowebapi/webapi/push"
	"github.com/gowebapi/webapi/serviceworker/client"
)

// using following types:
// appmenifestres.ImageResource
// channel.MessageEvent
// channel.MessagePort
// client.ClientType
// client.PromiseNilWindowClient
// domcore.Event
// domcore.EventHandler
// domcore.EventTarget
// domcore.ExtendableEvent
// fetch.PromiseResponse
// fetch.Request
// fetch.Response
// htmlcommon.WorkerType
// javascript.FrozenArray
// javascript.Object
// javascript.Promise
// javascript.PromiseBool
// javascript.PromiseFinally
// javascript.PromiseFrozenArray
// javascript.PromiseSequenceString
// javascript.PromiseVoid
// payment.PaymentManager
// push.Manager

// source idl files:
// BackgroundSync.idl
// background-fetch.idl
// promises.idl
// service-workers.idl

// transform files:
// BackgroundSync.go.md
// background-fetch.go.md
// promises.go.md
// service-workers.go.md

// workaround for compiler error
func unused(value interface{}) {
	// TODO remove this method
}

type Union struct {
	Value js.Value
}

func (u *Union) JSValue() js.Value {
	return u.Value
}

func UnionFromJS(value js.Value) *Union {
	return &Union{Value: value}
}

// enum: BackgroundFetchFailureReason
type BackgroundFetchFailureReason int

const (
	EmptyString0BackgroundFetchFailureReason BackgroundFetchFailureReason = iota
	AbortedBackgroundFetchFailureReason
	BadStatusBackgroundFetchFailureReason
	FetchErrorBackgroundFetchFailureReason
	QuotaExceededBackgroundFetchFailureReason
	DownloadTotalExceededBackgroundFetchFailureReason
)

var backgroundFetchFailureReasonToWasmTable = []string{
	"", "aborted", "bad-status", "fetch-error", "quota-exceeded", "download-total-exceeded",
}

var backgroundFetchFailureReasonFromWasmTable = map[string]BackgroundFetchFailureReason{
	"": EmptyString0BackgroundFetchFailureReason, "aborted": AbortedBackgroundFetchFailureReason, "bad-status": BadStatusBackgroundFetchFailureReason, "fetch-error": FetchErrorBackgroundFetchFailureReason, "quota-exceeded": QuotaExceededBackgroundFetchFailureReason, "download-total-exceeded": DownloadTotalExceededBackgroundFetchFailureReason,
}

// JSValue is converting this enum into a javascript object
func (this *BackgroundFetchFailureReason) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this BackgroundFetchFailureReason) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(backgroundFetchFailureReasonToWasmTable) {
		return backgroundFetchFailureReasonToWasmTable[idx]
	}
	panic("unknown input value")
}

// BackgroundFetchFailureReasonFromJS is converting a javascript value into
// a BackgroundFetchFailureReason enum value.
func BackgroundFetchFailureReasonFromJS(value js.Value) BackgroundFetchFailureReason {
	key := value.String()
	conv, ok := backgroundFetchFailureReasonFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: BackgroundFetchResult
type BackgroundFetchResult int

const (
	EmptyString0BackgroundFetchResult BackgroundFetchResult = iota
	SuccessBackgroundFetchResult
	FailureBackgroundFetchResult
)

var backgroundFetchResultToWasmTable = []string{
	"", "success", "failure",
}

var backgroundFetchResultFromWasmTable = map[string]BackgroundFetchResult{
	"": EmptyString0BackgroundFetchResult, "success": SuccessBackgroundFetchResult, "failure": FailureBackgroundFetchResult,
}

// JSValue is converting this enum into a javascript object
func (this *BackgroundFetchResult) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this BackgroundFetchResult) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(backgroundFetchResultToWasmTable) {
		return backgroundFetchResultToWasmTable[idx]
	}
	panic("unknown input value")
}

// BackgroundFetchResultFromJS is converting a javascript value into
// a BackgroundFetchResult enum value.
func BackgroundFetchResultFromJS(value js.Value) BackgroundFetchResult {
	key := value.String()
	conv, ok := backgroundFetchResultFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: ServiceWorkerState
type ServiceWorkerState int

const (
	InstallingServiceWorkerState ServiceWorkerState = iota
	InstalledServiceWorkerState
	ActivatingServiceWorkerState
	ActivatedServiceWorkerState
	RedundantServiceWorkerState
)

var serviceWorkerStateToWasmTable = []string{
	"installing", "installed", "activating", "activated", "redundant",
}

var serviceWorkerStateFromWasmTable = map[string]ServiceWorkerState{
	"installing": InstallingServiceWorkerState, "installed": InstalledServiceWorkerState, "activating": ActivatingServiceWorkerState, "activated": ActivatedServiceWorkerState, "redundant": RedundantServiceWorkerState,
}

// JSValue is converting this enum into a javascript object
func (this *ServiceWorkerState) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this ServiceWorkerState) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(serviceWorkerStateToWasmTable) {
		return serviceWorkerStateToWasmTable[idx]
	}
	panic("unknown input value")
}

// ServiceWorkerStateFromJS is converting a javascript value into
// a ServiceWorkerState enum value.
func ServiceWorkerStateFromJS(value js.Value) ServiceWorkerState {
	key := value.String()
	conv, ok := serviceWorkerStateFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: ServiceWorkerUpdateViaCache
type ServiceWorkerUpdateViaCache int

const (
	ImportsServiceWorkerUpdateViaCache ServiceWorkerUpdateViaCache = iota
	AllServiceWorkerUpdateViaCache
	NoneServiceWorkerUpdateViaCache
)

var serviceWorkerUpdateViaCacheToWasmTable = []string{
	"imports", "all", "none",
}

var serviceWorkerUpdateViaCacheFromWasmTable = map[string]ServiceWorkerUpdateViaCache{
	"imports": ImportsServiceWorkerUpdateViaCache, "all": AllServiceWorkerUpdateViaCache, "none": NoneServiceWorkerUpdateViaCache,
}

// JSValue is converting this enum into a javascript object
func (this *ServiceWorkerUpdateViaCache) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this ServiceWorkerUpdateViaCache) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(serviceWorkerUpdateViaCacheToWasmTable) {
		return serviceWorkerUpdateViaCacheToWasmTable[idx]
	}
	panic("unknown input value")
}

// ServiceWorkerUpdateViaCacheFromJS is converting a javascript value into
// a ServiceWorkerUpdateViaCache enum value.
func ServiceWorkerUpdateViaCacheFromJS(value js.Value) ServiceWorkerUpdateViaCache {
	key := value.String()
	conv, ok := serviceWorkerUpdateViaCacheFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// callback: PromiseTemplateOnFulfilled
type PromiseBackgroundFetchRecordOnFulfilledFunc func(value *BackgroundFetchRecord)

// PromiseBackgroundFetchRecordOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseBackgroundFetchRecordOnFulfilled js.Func

func PromiseBackgroundFetchRecordOnFulfilledToJS(callback PromiseBackgroundFetchRecordOnFulfilledFunc) *PromiseBackgroundFetchRecordOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseBackgroundFetchRecordOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *BackgroundFetchRecord // javascript: BackgroundFetchRecord value
		)
		_p0 = BackgroundFetchRecordFromJS(args[0])
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseBackgroundFetchRecordOnFulfilledFromJS(_value js.Value) PromiseBackgroundFetchRecordOnFulfilledFunc {
	return func(value *BackgroundFetchRecord) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseBackgroundFetchRecordOnRejectedFunc func(reason js.Value)

// PromiseBackgroundFetchRecordOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseBackgroundFetchRecordOnRejected js.Func

func PromiseBackgroundFetchRecordOnRejectedToJS(callback PromiseBackgroundFetchRecordOnRejectedFunc) *PromiseBackgroundFetchRecordOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseBackgroundFetchRecordOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseBackgroundFetchRecordOnRejectedFromJS(_value js.Value) PromiseBackgroundFetchRecordOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromiseBackgroundFetchRegistrationOnFulfilledFunc func(value *BackgroundFetchRegistration)

// PromiseBackgroundFetchRegistrationOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseBackgroundFetchRegistrationOnFulfilled js.Func

func PromiseBackgroundFetchRegistrationOnFulfilledToJS(callback PromiseBackgroundFetchRegistrationOnFulfilledFunc) *PromiseBackgroundFetchRegistrationOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseBackgroundFetchRegistrationOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *BackgroundFetchRegistration // javascript: BackgroundFetchRegistration value
		)
		_p0 = BackgroundFetchRegistrationFromJS(args[0])
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseBackgroundFetchRegistrationOnFulfilledFromJS(_value js.Value) PromiseBackgroundFetchRegistrationOnFulfilledFunc {
	return func(value *BackgroundFetchRegistration) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseBackgroundFetchRegistrationOnRejectedFunc func(reason js.Value)

// PromiseBackgroundFetchRegistrationOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseBackgroundFetchRegistrationOnRejected js.Func

func PromiseBackgroundFetchRegistrationOnRejectedToJS(callback PromiseBackgroundFetchRegistrationOnRejectedFunc) *PromiseBackgroundFetchRegistrationOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseBackgroundFetchRegistrationOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseBackgroundFetchRegistrationOnRejectedFromJS(_value js.Value) PromiseBackgroundFetchRegistrationOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromiseCacheOnFulfilledFunc func(value *Cache)

// PromiseCacheOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseCacheOnFulfilled js.Func

func PromiseCacheOnFulfilledToJS(callback PromiseCacheOnFulfilledFunc) *PromiseCacheOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseCacheOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *Cache // javascript: Cache value
		)
		_p0 = CacheFromJS(args[0])
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseCacheOnFulfilledFromJS(_value js.Value) PromiseCacheOnFulfilledFunc {
	return func(value *Cache) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseCacheOnRejectedFunc func(reason js.Value)

// PromiseCacheOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseCacheOnRejected js.Func

func PromiseCacheOnRejectedToJS(callback PromiseCacheOnRejectedFunc) *PromiseCacheOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseCacheOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseCacheOnRejectedFromJS(_value js.Value) PromiseCacheOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromiseNilBackgroundFetchRegistrationOnFulfilledFunc func(value *BackgroundFetchRegistration)

// PromiseNilBackgroundFetchRegistrationOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseNilBackgroundFetchRegistrationOnFulfilled js.Func

func PromiseNilBackgroundFetchRegistrationOnFulfilledToJS(callback PromiseNilBackgroundFetchRegistrationOnFulfilledFunc) *PromiseNilBackgroundFetchRegistrationOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseNilBackgroundFetchRegistrationOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *BackgroundFetchRegistration // javascript: BackgroundFetchRegistration value
		)
		_p0 = BackgroundFetchRegistrationFromJS(args[0])
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseNilBackgroundFetchRegistrationOnFulfilledFromJS(_value js.Value) PromiseNilBackgroundFetchRegistrationOnFulfilledFunc {
	return func(value *BackgroundFetchRegistration) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseNilBackgroundFetchRegistrationOnRejectedFunc func(reason js.Value)

// PromiseNilBackgroundFetchRegistrationOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseNilBackgroundFetchRegistrationOnRejected js.Func

func PromiseNilBackgroundFetchRegistrationOnRejectedToJS(callback PromiseNilBackgroundFetchRegistrationOnRejectedFunc) *PromiseNilBackgroundFetchRegistrationOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseNilBackgroundFetchRegistrationOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseNilBackgroundFetchRegistrationOnRejectedFromJS(_value js.Value) PromiseNilBackgroundFetchRegistrationOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromiseSequenceBackgroundFetchRecordOnFulfilledFunc func(value []*BackgroundFetchRecord)

// PromiseSequenceBackgroundFetchRecordOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseSequenceBackgroundFetchRecordOnFulfilled js.Func

func PromiseSequenceBackgroundFetchRecordOnFulfilledToJS(callback PromiseSequenceBackgroundFetchRecordOnFulfilledFunc) *PromiseSequenceBackgroundFetchRecordOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseSequenceBackgroundFetchRecordOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 []*BackgroundFetchRecord // javascript: sequence<BackgroundFetchRecord> value
		)
		__length0 := args[0].Length()
		__array0 := make([]*BackgroundFetchRecord, __length0, __length0)
		for __idx0 := 0; __idx0 < __length0; __idx0++ {
			var __seq_out0 *BackgroundFetchRecord
			__seq_in0 := args[0].Index(__idx0)
			__seq_out0 = BackgroundFetchRecordFromJS(__seq_in0)
			__array0[__idx0] = __seq_out0
		}
		_p0 = __array0
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseSequenceBackgroundFetchRecordOnFulfilledFromJS(_value js.Value) PromiseSequenceBackgroundFetchRecordOnFulfilledFunc {
	return func(value []*BackgroundFetchRecord) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := js.Global().Get("Array").New(len(value))
		for __idx0, __seq_in0 := range value {
			__seq_out0 := __seq_in0.JSValue()
			_p0.SetIndex(__idx0, __seq_out0)
		}
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseSequenceBackgroundFetchRecordOnRejectedFunc func(reason js.Value)

// PromiseSequenceBackgroundFetchRecordOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseSequenceBackgroundFetchRecordOnRejected js.Func

func PromiseSequenceBackgroundFetchRecordOnRejectedToJS(callback PromiseSequenceBackgroundFetchRecordOnRejectedFunc) *PromiseSequenceBackgroundFetchRecordOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseSequenceBackgroundFetchRecordOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseSequenceBackgroundFetchRecordOnRejectedFromJS(_value js.Value) PromiseSequenceBackgroundFetchRecordOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromiseServiceWorkerRegistrationOnFulfilledFunc func(value *ServiceWorkerRegistration)

// PromiseServiceWorkerRegistrationOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseServiceWorkerRegistrationOnFulfilled js.Func

func PromiseServiceWorkerRegistrationOnFulfilledToJS(callback PromiseServiceWorkerRegistrationOnFulfilledFunc) *PromiseServiceWorkerRegistrationOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseServiceWorkerRegistrationOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *ServiceWorkerRegistration // javascript: ServiceWorkerRegistration value
		)
		_p0 = ServiceWorkerRegistrationFromJS(args[0])
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseServiceWorkerRegistrationOnFulfilledFromJS(_value js.Value) PromiseServiceWorkerRegistrationOnFulfilledFunc {
	return func(value *ServiceWorkerRegistration) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseServiceWorkerRegistrationOnRejectedFunc func(reason js.Value)

// PromiseServiceWorkerRegistrationOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseServiceWorkerRegistrationOnRejected js.Func

func PromiseServiceWorkerRegistrationOnRejectedToJS(callback PromiseServiceWorkerRegistrationOnRejectedFunc) *PromiseServiceWorkerRegistrationOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseServiceWorkerRegistrationOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseServiceWorkerRegistrationOnRejectedFromJS(_value js.Value) PromiseServiceWorkerRegistrationOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// dictionary: BackgroundFetchEventInit
type BackgroundFetchEventInit struct {
	Bubbles      bool
	Cancelable   bool
	Composed     bool
	Registration *BackgroundFetchRegistration
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *BackgroundFetchEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Registration.JSValue()
	out.Set("registration", value3)
	return out
}

// BackgroundFetchEventInitFromJS is allocating a new
// BackgroundFetchEventInit object and copy all values in the value javascript object.
func BackgroundFetchEventInitFromJS(value js.Value) *BackgroundFetchEventInit {
	var out BackgroundFetchEventInit
	var (
		value0 bool                         // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool                         // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool                         // javascript: boolean {composed Composed composed}
		value3 *BackgroundFetchRegistration // javascript: BackgroundFetchRegistration {registration Registration registration}
	)
	value0 = (value.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (value.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (value.Get("composed")).Bool()
	out.Composed = value2
	value3 = BackgroundFetchRegistrationFromJS(value.Get("registration"))
	out.Registration = value3
	return &out
}

// dictionary: BackgroundFetchOptions
type BackgroundFetchOptions struct {
	Icons         []*appmenifestres.ImageResource
	Title         string
	DownloadTotal int
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *BackgroundFetchOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.Icons))
	for __idx0, __seq_in0 := range _this.Icons {
		__seq_out0 := __seq_in0.JSValue()
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("icons", value0)
	value1 := _this.Title
	out.Set("title", value1)
	value2 := _this.DownloadTotal
	out.Set("downloadTotal", value2)
	return out
}

// BackgroundFetchOptionsFromJS is allocating a new
// BackgroundFetchOptions object and copy all values in the value javascript object.
func BackgroundFetchOptionsFromJS(value js.Value) *BackgroundFetchOptions {
	var out BackgroundFetchOptions
	var (
		value0 []*appmenifestres.ImageResource // javascript: sequence<ImageResource> {icons Icons icons}
		value1 string                          // javascript: DOMString {title Title title}
		value2 int                             // javascript: unsigned long long {downloadTotal DownloadTotal downloadTotal}
	)
	__length0 := value.Get("icons").Length()
	__array0 := make([]*appmenifestres.ImageResource, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *appmenifestres.ImageResource
		__seq_in0 := value.Get("icons").Index(__idx0)
		__seq_out0 = appmenifestres.ImageResourceFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.Icons = value0
	value1 = (value.Get("title")).String()
	out.Title = value1
	value2 = (value.Get("downloadTotal")).Int()
	out.DownloadTotal = value2
	return &out
}

// dictionary: BackgroundFetchUIOptions
type BackgroundFetchUIOptions struct {
	Icons []*appmenifestres.ImageResource
	Title string
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *BackgroundFetchUIOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.Icons))
	for __idx0, __seq_in0 := range _this.Icons {
		__seq_out0 := __seq_in0.JSValue()
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("icons", value0)
	value1 := _this.Title
	out.Set("title", value1)
	return out
}

// BackgroundFetchUIOptionsFromJS is allocating a new
// BackgroundFetchUIOptions object and copy all values in the value javascript object.
func BackgroundFetchUIOptionsFromJS(value js.Value) *BackgroundFetchUIOptions {
	var out BackgroundFetchUIOptions
	var (
		value0 []*appmenifestres.ImageResource // javascript: sequence<ImageResource> {icons Icons icons}
		value1 string                          // javascript: DOMString {title Title title}
	)
	__length0 := value.Get("icons").Length()
	__array0 := make([]*appmenifestres.ImageResource, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *appmenifestres.ImageResource
		__seq_in0 := value.Get("icons").Index(__idx0)
		__seq_out0 = appmenifestres.ImageResourceFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.Icons = value0
	value1 = (value.Get("title")).String()
	out.Title = value1
	return &out
}

// dictionary: CacheQueryOptions
type CacheQueryOptions struct {
	IgnoreSearch bool
	IgnoreMethod bool
	IgnoreVary   bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *CacheQueryOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.IgnoreSearch
	out.Set("ignoreSearch", value0)
	value1 := _this.IgnoreMethod
	out.Set("ignoreMethod", value1)
	value2 := _this.IgnoreVary
	out.Set("ignoreVary", value2)
	return out
}

// CacheQueryOptionsFromJS is allocating a new
// CacheQueryOptions object and copy all values in the value javascript object.
func CacheQueryOptionsFromJS(value js.Value) *CacheQueryOptions {
	var out CacheQueryOptions
	var (
		value0 bool // javascript: boolean {ignoreSearch IgnoreSearch ignoreSearch}
		value1 bool // javascript: boolean {ignoreMethod IgnoreMethod ignoreMethod}
		value2 bool // javascript: boolean {ignoreVary IgnoreVary ignoreVary}
	)
	value0 = (value.Get("ignoreSearch")).Bool()
	out.IgnoreSearch = value0
	value1 = (value.Get("ignoreMethod")).Bool()
	out.IgnoreMethod = value1
	value2 = (value.Get("ignoreVary")).Bool()
	out.IgnoreVary = value2
	return &out
}

// dictionary: ClientQueryOptions
type ClientQueryOptions struct {
	IncludeUncontrolled bool
	Type                client.ClientType
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *ClientQueryOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.IncludeUncontrolled
	out.Set("includeUncontrolled", value0)
	value1 := _this.Type.JSValue()
	out.Set("type", value1)
	return out
}

// ClientQueryOptionsFromJS is allocating a new
// ClientQueryOptions object and copy all values in the value javascript object.
func ClientQueryOptionsFromJS(value js.Value) *ClientQueryOptions {
	var out ClientQueryOptions
	var (
		value0 bool              // javascript: boolean {includeUncontrolled IncludeUncontrolled includeUncontrolled}
		value1 client.ClientType // javascript: ClientType {type Type _type}
	)
	value0 = (value.Get("includeUncontrolled")).Bool()
	out.IncludeUncontrolled = value0
	value1 = client.ClientTypeFromJS(value.Get("type"))
	out.Type = value1
	return &out
}

// dictionary: ExtendableMessageEventInit
type ExtendableMessageEventInit struct {
	Bubbles     bool
	Cancelable  bool
	Composed    bool
	Data        js.Value
	Origin      string
	LastEventId string
	Source      *Union
	Ports       []*channel.MessagePort
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *ExtendableMessageEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Data
	out.Set("data", value3)
	value4 := _this.Origin
	out.Set("origin", value4)
	value5 := _this.LastEventId
	out.Set("lastEventId", value5)
	value6 := _this.Source.JSValue()
	out.Set("source", value6)
	value7 := js.Global().Get("Array").New(len(_this.Ports))
	for __idx7, __seq_in7 := range _this.Ports {
		__seq_out7 := __seq_in7.JSValue()
		value7.SetIndex(__idx7, __seq_out7)
	}
	out.Set("ports", value7)
	return out
}

// ExtendableMessageEventInitFromJS is allocating a new
// ExtendableMessageEventInit object and copy all values in the value javascript object.
func ExtendableMessageEventInitFromJS(value js.Value) *ExtendableMessageEventInit {
	var out ExtendableMessageEventInit
	var (
		value0 bool                   // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool                   // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool                   // javascript: boolean {composed Composed composed}
		value3 js.Value               // javascript: any {data Data data}
		value4 string                 // javascript: USVString {origin Origin origin}
		value5 string                 // javascript: DOMString {lastEventId LastEventId lastEventId}
		value6 *Union                 // javascript: Union {source Source source}
		value7 []*channel.MessagePort // javascript: sequence<MessagePort> {ports Ports ports}
	)
	value0 = (value.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (value.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (value.Get("composed")).Bool()
	out.Composed = value2
	value3 = value.Get("data")
	out.Data = value3
	value4 = (value.Get("origin")).String()
	out.Origin = value4
	value5 = (value.Get("lastEventId")).String()
	out.LastEventId = value5
	if value.Get("source").Type() != js.TypeNull && value.Get("source").Type() != js.TypeUndefined {
		value6 = UnionFromJS(value.Get("source"))
	}
	out.Source = value6
	__length7 := value.Get("ports").Length()
	__array7 := make([]*channel.MessagePort, __length7, __length7)
	for __idx7 := 0; __idx7 < __length7; __idx7++ {
		var __seq_out7 *channel.MessagePort
		__seq_in7 := value.Get("ports").Index(__idx7)
		__seq_out7 = channel.MessagePortFromJS(__seq_in7)
		__array7[__idx7] = __seq_out7
	}
	value7 = __array7
	out.Ports = value7
	return &out
}

// dictionary: FetchEventInit
type FetchEventInit struct {
	Bubbles    bool
	Cancelable bool
	Composed   bool
	Request    *fetch.Request
	ClientId   string
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *FetchEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Request.JSValue()
	out.Set("request", value3)
	value4 := _this.ClientId
	out.Set("clientId", value4)
	return out
}

// FetchEventInitFromJS is allocating a new
// FetchEventInit object and copy all values in the value javascript object.
func FetchEventInitFromJS(value js.Value) *FetchEventInit {
	var out FetchEventInit
	var (
		value0 bool           // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool           // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool           // javascript: boolean {composed Composed composed}
		value3 *fetch.Request // javascript: Request {request Request request}
		value4 string         // javascript: DOMString {clientId ClientId clientId}
	)
	value0 = (value.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (value.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (value.Get("composed")).Bool()
	out.Composed = value2
	value3 = fetch.RequestFromJS(value.Get("request"))
	out.Request = value3
	value4 = (value.Get("clientId")).String()
	out.ClientId = value4
	return &out
}

// dictionary: MultiCacheQueryOptions
type MultiCacheQueryOptions struct {
	IgnoreSearch bool
	IgnoreMethod bool
	IgnoreVary   bool
	CacheName    string
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *MultiCacheQueryOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.IgnoreSearch
	out.Set("ignoreSearch", value0)
	value1 := _this.IgnoreMethod
	out.Set("ignoreMethod", value1)
	value2 := _this.IgnoreVary
	out.Set("ignoreVary", value2)
	value3 := _this.CacheName
	out.Set("cacheName", value3)
	return out
}

// MultiCacheQueryOptionsFromJS is allocating a new
// MultiCacheQueryOptions object and copy all values in the value javascript object.
func MultiCacheQueryOptionsFromJS(value js.Value) *MultiCacheQueryOptions {
	var out MultiCacheQueryOptions
	var (
		value0 bool   // javascript: boolean {ignoreSearch IgnoreSearch ignoreSearch}
		value1 bool   // javascript: boolean {ignoreMethod IgnoreMethod ignoreMethod}
		value2 bool   // javascript: boolean {ignoreVary IgnoreVary ignoreVary}
		value3 string // javascript: DOMString {cacheName CacheName cacheName}
	)
	value0 = (value.Get("ignoreSearch")).Bool()
	out.IgnoreSearch = value0
	value1 = (value.Get("ignoreMethod")).Bool()
	out.IgnoreMethod = value1
	value2 = (value.Get("ignoreVary")).Bool()
	out.IgnoreVary = value2
	value3 = (value.Get("cacheName")).String()
	out.CacheName = value3
	return &out
}

// dictionary: RegistrationOptions
type RegistrationOptions struct {
	Scope          string
	Type           htmlcommon.WorkerType
	UpdateViaCache ServiceWorkerUpdateViaCache
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *RegistrationOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Scope
	out.Set("scope", value0)
	value1 := _this.Type.JSValue()
	out.Set("type", value1)
	value2 := _this.UpdateViaCache.JSValue()
	out.Set("updateViaCache", value2)
	return out
}

// RegistrationOptionsFromJS is allocating a new
// RegistrationOptions object and copy all values in the value javascript object.
func RegistrationOptionsFromJS(value js.Value) *RegistrationOptions {
	var out RegistrationOptions
	var (
		value0 string                      // javascript: USVString {scope Scope scope}
		value1 htmlcommon.WorkerType       // javascript: WorkerType {type Type _type}
		value2 ServiceWorkerUpdateViaCache // javascript: ServiceWorkerUpdateViaCache {updateViaCache UpdateViaCache updateViaCache}
	)
	value0 = (value.Get("scope")).String()
	out.Scope = value0
	value1 = htmlcommon.WorkerTypeFromJS(value.Get("type"))
	out.Type = value1
	value2 = ServiceWorkerUpdateViaCacheFromJS(value.Get("updateViaCache"))
	out.UpdateViaCache = value2
	return &out
}

// dictionary: SyncEventInit
type SyncEventInit struct {
	Bubbles    bool
	Cancelable bool
	Composed   bool
	Tag        string
	LastChance bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *SyncEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Tag
	out.Set("tag", value3)
	value4 := _this.LastChance
	out.Set("lastChance", value4)
	return out
}

// SyncEventInitFromJS is allocating a new
// SyncEventInit object and copy all values in the value javascript object.
func SyncEventInitFromJS(value js.Value) *SyncEventInit {
	var out SyncEventInit
	var (
		value0 bool   // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool   // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool   // javascript: boolean {composed Composed composed}
		value3 string // javascript: DOMString {tag Tag tag}
		value4 bool   // javascript: boolean {lastChance LastChance lastChance}
	)
	value0 = (value.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (value.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (value.Get("composed")).Bool()
	out.Composed = value2
	value3 = (value.Get("tag")).String()
	out.Tag = value3
	value4 = (value.Get("lastChance")).Bool()
	out.LastChance = value4
	return &out
}

// class: BackgroundFetchEvent
type BackgroundFetchEvent struct {
	domcore.ExtendableEvent
}

// BackgroundFetchEventFromJS is casting a js.Value into BackgroundFetchEvent.
func BackgroundFetchEventFromJS(value js.Value) *BackgroundFetchEvent {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &BackgroundFetchEvent{}
	ret.Value_JS = value
	return ret
}

// BackgroundFetchEventFromJS is casting from something that holds a js.Value into BackgroundFetchEvent.
func BackgroundFetchEventFromWrapper(input core.Wrapper) *BackgroundFetchEvent {
	return BackgroundFetchEventFromJS(input.JSValue())
}

func NewBackgroundFetchEvent(_type string, init *BackgroundFetchEventInit) (_result *BackgroundFetchEvent) {
	_klass := js.Global().Get("BackgroundFetchEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := init.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *BackgroundFetchEvent // javascript: BackgroundFetchEvent _what_return_name
	)
	_converted = BackgroundFetchEventFromJS(_returned)
	_result = _converted
	return
}

// Registration returning attribute 'registration' with
// type BackgroundFetchRegistration (idl: BackgroundFetchRegistration).
func (_this *BackgroundFetchEvent) Registration() *BackgroundFetchRegistration {
	var ret *BackgroundFetchRegistration
	value := _this.Value_JS.Get("registration")
	ret = BackgroundFetchRegistrationFromJS(value)
	return ret
}

// class: BackgroundFetchManager
type BackgroundFetchManager struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *BackgroundFetchManager) JSValue() js.Value {
	return _this.Value_JS
}

// BackgroundFetchManagerFromJS is casting a js.Value into BackgroundFetchManager.
func BackgroundFetchManagerFromJS(value js.Value) *BackgroundFetchManager {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &BackgroundFetchManager{}
	ret.Value_JS = value
	return ret
}

// BackgroundFetchManagerFromJS is casting from something that holds a js.Value into BackgroundFetchManager.
func BackgroundFetchManagerFromWrapper(input core.Wrapper) *BackgroundFetchManager {
	return BackgroundFetchManagerFromJS(input.JSValue())
}

func (_this *BackgroundFetchManager) Fetch(id string, requests *Union, options *BackgroundFetchOptions) (_result *PromiseBackgroundFetchRegistration) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := id
	_args[0] = _p0
	_end++
	_p1 := requests.JSValue()
	_args[1] = _p1
	_end++
	if options != nil {
		_p2 := options.JSValue()
		_args[2] = _p2
		_end++
	}
	_returned := _this.Value_JS.Call("fetch", _args[0:_end]...)
	var (
		_converted *PromiseBackgroundFetchRegistration // javascript: Promise _what_return_name
	)
	_converted = PromiseBackgroundFetchRegistrationFromJS(_returned)
	_result = _converted
	return
}

func (_this *BackgroundFetchManager) Get(id string) (_result *PromiseNilBackgroundFetchRegistration) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := id
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("get", _args[0:_end]...)
	var (
		_converted *PromiseNilBackgroundFetchRegistration // javascript: Promise _what_return_name
	)
	_converted = PromiseNilBackgroundFetchRegistrationFromJS(_returned)
	_result = _converted
	return
}

func (_this *BackgroundFetchManager) GetIds() (_result *javascript.PromiseSequenceString) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getIds", _args[0:_end]...)
	var (
		_converted *javascript.PromiseSequenceString // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseSequenceStringFromJS(_returned)
	_result = _converted
	return
}

// class: BackgroundFetchRecord
type BackgroundFetchRecord struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *BackgroundFetchRecord) JSValue() js.Value {
	return _this.Value_JS
}

// BackgroundFetchRecordFromJS is casting a js.Value into BackgroundFetchRecord.
func BackgroundFetchRecordFromJS(value js.Value) *BackgroundFetchRecord {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &BackgroundFetchRecord{}
	ret.Value_JS = value
	return ret
}

// BackgroundFetchRecordFromJS is casting from something that holds a js.Value into BackgroundFetchRecord.
func BackgroundFetchRecordFromWrapper(input core.Wrapper) *BackgroundFetchRecord {
	return BackgroundFetchRecordFromJS(input.JSValue())
}

// Request returning attribute 'request' with
// type fetch.Request (idl: Request).
func (_this *BackgroundFetchRecord) Request() *fetch.Request {
	var ret *fetch.Request
	value := _this.Value_JS.Get("request")
	ret = fetch.RequestFromJS(value)
	return ret
}

// ResponseReady returning attribute 'responseReady' with
// type javascript.Promise (idl: Promise).
func (_this *BackgroundFetchRecord) ResponseReady() *javascript.Promise {
	var ret *javascript.Promise
	value := _this.Value_JS.Get("responseReady")
	ret = javascript.PromiseFromJS(value)
	return ret
}

// class: BackgroundFetchRegistration
type BackgroundFetchRegistration struct {
	domcore.EventTarget
}

// BackgroundFetchRegistrationFromJS is casting a js.Value into BackgroundFetchRegistration.
func BackgroundFetchRegistrationFromJS(value js.Value) *BackgroundFetchRegistration {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &BackgroundFetchRegistration{}
	ret.Value_JS = value
	return ret
}

// BackgroundFetchRegistrationFromJS is casting from something that holds a js.Value into BackgroundFetchRegistration.
func BackgroundFetchRegistrationFromWrapper(input core.Wrapper) *BackgroundFetchRegistration {
	return BackgroundFetchRegistrationFromJS(input.JSValue())
}

// Id returning attribute 'id' with
// type string (idl: DOMString).
func (_this *BackgroundFetchRegistration) Id() string {
	var ret string
	value := _this.Value_JS.Get("id")
	ret = (value).String()
	return ret
}

// UploadTotal returning attribute 'uploadTotal' with
// type int (idl: unsigned long long).
func (_this *BackgroundFetchRegistration) UploadTotal() int {
	var ret int
	value := _this.Value_JS.Get("uploadTotal")
	ret = (value).Int()
	return ret
}

// Uploaded returning attribute 'uploaded' with
// type int (idl: unsigned long long).
func (_this *BackgroundFetchRegistration) Uploaded() int {
	var ret int
	value := _this.Value_JS.Get("uploaded")
	ret = (value).Int()
	return ret
}

// DownloadTotal returning attribute 'downloadTotal' with
// type int (idl: unsigned long long).
func (_this *BackgroundFetchRegistration) DownloadTotal() int {
	var ret int
	value := _this.Value_JS.Get("downloadTotal")
	ret = (value).Int()
	return ret
}

// Downloaded returning attribute 'downloaded' with
// type int (idl: unsigned long long).
func (_this *BackgroundFetchRegistration) Downloaded() int {
	var ret int
	value := _this.Value_JS.Get("downloaded")
	ret = (value).Int()
	return ret
}

// Result returning attribute 'result' with
// type BackgroundFetchResult (idl: BackgroundFetchResult).
func (_this *BackgroundFetchRegistration) Result() BackgroundFetchResult {
	var ret BackgroundFetchResult
	value := _this.Value_JS.Get("result")
	ret = BackgroundFetchResultFromJS(value)
	return ret
}

// FailureReason returning attribute 'failureReason' with
// type BackgroundFetchFailureReason (idl: BackgroundFetchFailureReason).
func (_this *BackgroundFetchRegistration) FailureReason() BackgroundFetchFailureReason {
	var ret BackgroundFetchFailureReason
	value := _this.Value_JS.Get("failureReason")
	ret = BackgroundFetchFailureReasonFromJS(value)
	return ret
}

// RecordsAvailable returning attribute 'recordsAvailable' with
// type bool (idl: boolean).
func (_this *BackgroundFetchRegistration) RecordsAvailable() bool {
	var ret bool
	value := _this.Value_JS.Get("recordsAvailable")
	ret = (value).Bool()
	return ret
}

// OnProgress returning attribute 'onprogress' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *BackgroundFetchRegistration) OnProgress() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onprogress")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// event attribute: domcore.Event
func eventFuncBackgroundFetchRegistration_domcore_Event(listener func(event *domcore.Event, target *BackgroundFetchRegistration)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *domcore.Event
		value := args[0]
		incoming := value.Get("target")
		ret = domcore.EventFromJS(value)
		src := BackgroundFetchRegistrationFromJS(incoming)
		listener(ret, src)
		return js.Undefined()
	}
	return js.FuncOf(fn)
}

// AddProgress is adding doing AddEventListener for 'Progress' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *BackgroundFetchRegistration) AddEventProgress(listener func(event *domcore.Event, currentTarget *BackgroundFetchRegistration)) js.Func {
	cb := eventFuncBackgroundFetchRegistration_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "progress", cb)
	return cb
}

// SetOnProgress is assigning a function to 'onprogress'. This
// This method is returning allocated javascript function that need to be released.
func (_this *BackgroundFetchRegistration) SetOnProgress(listener func(event *domcore.Event, currentTarget *BackgroundFetchRegistration)) js.Func {
	cb := eventFuncBackgroundFetchRegistration_domcore_Event(listener)
	_this.Value_JS.Set("onprogress", cb)
	return cb
}

func (_this *BackgroundFetchRegistration) Abort() (_result *javascript.PromiseBool) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("abort", _args[0:_end]...)
	var (
		_converted *javascript.PromiseBool // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseBoolFromJS(_returned)
	_result = _converted
	return
}

func (_this *BackgroundFetchRegistration) Match(request *Union, options *CacheQueryOptions) (_result *PromiseBackgroundFetchRecord) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := request.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("match", _args[0:_end]...)
	var (
		_converted *PromiseBackgroundFetchRecord // javascript: Promise _what_return_name
	)
	_converted = PromiseBackgroundFetchRecordFromJS(_returned)
	_result = _converted
	return
}

func (_this *BackgroundFetchRegistration) MatchAll(request *Union, options *CacheQueryOptions) (_result *PromiseSequenceBackgroundFetchRecord) {
	var (
		_args [2]interface{}
		_end  int
	)
	if request != nil {
		_p0 := request.JSValue()
		_args[0] = _p0
		_end++
	}
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("matchAll", _args[0:_end]...)
	var (
		_converted *PromiseSequenceBackgroundFetchRecord // javascript: Promise _what_return_name
	)
	_converted = PromiseSequenceBackgroundFetchRecordFromJS(_returned)
	_result = _converted
	return
}

// class: BackgroundFetchUpdateUIEvent
type BackgroundFetchUpdateUIEvent struct {
	BackgroundFetchEvent
}

// BackgroundFetchUpdateUIEventFromJS is casting a js.Value into BackgroundFetchUpdateUIEvent.
func BackgroundFetchUpdateUIEventFromJS(value js.Value) *BackgroundFetchUpdateUIEvent {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &BackgroundFetchUpdateUIEvent{}
	ret.Value_JS = value
	return ret
}

// BackgroundFetchUpdateUIEventFromJS is casting from something that holds a js.Value into BackgroundFetchUpdateUIEvent.
func BackgroundFetchUpdateUIEventFromWrapper(input core.Wrapper) *BackgroundFetchUpdateUIEvent {
	return BackgroundFetchUpdateUIEventFromJS(input.JSValue())
}

func NewBackgroundFetchUpdateUIEvent(_type string, init *BackgroundFetchEventInit) (_result *BackgroundFetchUpdateUIEvent) {
	_klass := js.Global().Get("BackgroundFetchUpdateUIEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := init.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *BackgroundFetchUpdateUIEvent // javascript: BackgroundFetchUpdateUIEvent _what_return_name
	)
	_converted = BackgroundFetchUpdateUIEventFromJS(_returned)
	_result = _converted
	return
}

func (_this *BackgroundFetchUpdateUIEvent) UpdateUI(options *BackgroundFetchUIOptions) (_result *javascript.PromiseVoid) {
	var (
		_args [1]interface{}
		_end  int
	)
	if options != nil {
		_p0 := options.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _this.Value_JS.Call("updateUI", _args[0:_end]...)
	var (
		_converted *javascript.PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = javascript.PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

// class: Cache
type Cache struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Cache) JSValue() js.Value {
	return _this.Value_JS
}

// CacheFromJS is casting a js.Value into Cache.
func CacheFromJS(value js.Value) *Cache {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Cache{}
	ret.Value_JS = value
	return ret
}

// CacheFromJS is casting from something that holds a js.Value into Cache.
func CacheFromWrapper(input core.Wrapper) *Cache {
	return CacheFromJS(input.JSValue())
}

func (_this *Cache) Match(request *Union, options *CacheQueryOptions) (_result *javascript.Promise) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := request.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("match", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *Cache) MatchAll(request *Union, options *CacheQueryOptions) (_result *javascript.PromiseFrozenArray) {
	var (
		_args [2]interface{}
		_end  int
	)
	if request != nil {
		_p0 := request.JSValue()
		_args[0] = _p0
		_end++
	}
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("matchAll", _args[0:_end]...)
	var (
		_converted *javascript.PromiseFrozenArray // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFrozenArrayFromJS(_returned)
	_result = _converted
	return
}

func (_this *Cache) Add(request *Union) (_result *javascript.PromiseVoid) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := request.JSValue()
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("add", _args[0:_end]...)
	var (
		_converted *javascript.PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = javascript.PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

func (_this *Cache) AddAll(requests []*Union) (_result *javascript.PromiseVoid) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := js.Global().Get("Array").New(len(requests))
	for __idx0, __seq_in0 := range requests {
		__seq_out0 := __seq_in0.JSValue()
		_p0.SetIndex(__idx0, __seq_out0)
	}
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("addAll", _args[0:_end]...)
	var (
		_converted *javascript.PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = javascript.PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

func (_this *Cache) Put(request *Union, response *fetch.Response) (_result *javascript.PromiseVoid) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := request.JSValue()
	_args[0] = _p0
	_end++
	_p1 := response.JSValue()
	_args[1] = _p1
	_end++
	_returned := _this.Value_JS.Call("put", _args[0:_end]...)
	var (
		_converted *javascript.PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = javascript.PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

func (_this *Cache) Delete(request *Union, options *CacheQueryOptions) (_result *javascript.PromiseBool) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := request.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("delete", _args[0:_end]...)
	var (
		_converted *javascript.PromiseBool // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseBoolFromJS(_returned)
	_result = _converted
	return
}

func (_this *Cache) Keys(request *Union, options *CacheQueryOptions) (_result *javascript.PromiseFrozenArray) {
	var (
		_args [2]interface{}
		_end  int
	)
	if request != nil {
		_p0 := request.JSValue()
		_args[0] = _p0
		_end++
	}
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("keys", _args[0:_end]...)
	var (
		_converted *javascript.PromiseFrozenArray // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFrozenArrayFromJS(_returned)
	_result = _converted
	return
}

// class: CacheStorage
type CacheStorage struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *CacheStorage) JSValue() js.Value {
	return _this.Value_JS
}

// CacheStorageFromJS is casting a js.Value into CacheStorage.
func CacheStorageFromJS(value js.Value) *CacheStorage {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CacheStorage{}
	ret.Value_JS = value
	return ret
}

// CacheStorageFromJS is casting from something that holds a js.Value into CacheStorage.
func CacheStorageFromWrapper(input core.Wrapper) *CacheStorage {
	return CacheStorageFromJS(input.JSValue())
}

func (_this *CacheStorage) Match(request *Union, options *MultiCacheQueryOptions) (_result *javascript.Promise) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := request.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("match", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *CacheStorage) Has(cacheName string) (_result *javascript.PromiseBool) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := cacheName
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("has", _args[0:_end]...)
	var (
		_converted *javascript.PromiseBool // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseBoolFromJS(_returned)
	_result = _converted
	return
}

func (_this *CacheStorage) Open(cacheName string) (_result *PromiseCache) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := cacheName
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("open", _args[0:_end]...)
	var (
		_converted *PromiseCache // javascript: Promise _what_return_name
	)
	_converted = PromiseCacheFromJS(_returned)
	_result = _converted
	return
}

func (_this *CacheStorage) Delete(cacheName string) (_result *javascript.PromiseBool) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := cacheName
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("delete", _args[0:_end]...)
	var (
		_converted *javascript.PromiseBool // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseBoolFromJS(_returned)
	_result = _converted
	return
}

func (_this *CacheStorage) Keys() (_result *javascript.PromiseSequenceString) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("keys", _args[0:_end]...)
	var (
		_converted *javascript.PromiseSequenceString // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseSequenceStringFromJS(_returned)
	_result = _converted
	return
}

// class: Clients
type Clients struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Clients) JSValue() js.Value {
	return _this.Value_JS
}

// ClientsFromJS is casting a js.Value into Clients.
func ClientsFromJS(value js.Value) *Clients {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Clients{}
	ret.Value_JS = value
	return ret
}

// ClientsFromJS is casting from something that holds a js.Value into Clients.
func ClientsFromWrapper(input core.Wrapper) *Clients {
	return ClientsFromJS(input.JSValue())
}

func (_this *Clients) Get(id string) (_result *javascript.Promise) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := id
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("get", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *Clients) MatchAll(options *ClientQueryOptions) (_result *javascript.PromiseFrozenArray) {
	var (
		_args [1]interface{}
		_end  int
	)
	if options != nil {
		_p0 := options.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _this.Value_JS.Call("matchAll", _args[0:_end]...)
	var (
		_converted *javascript.PromiseFrozenArray // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFrozenArrayFromJS(_returned)
	_result = _converted
	return
}

func (_this *Clients) OpenWindow(url string) (_result *client.PromiseNilWindowClient) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := url
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("openWindow", _args[0:_end]...)
	var (
		_converted *client.PromiseNilWindowClient // javascript: Promise _what_return_name
	)
	_converted = client.PromiseNilWindowClientFromJS(_returned)
	_result = _converted
	return
}

func (_this *Clients) Claim() (_result *javascript.PromiseVoid) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("claim", _args[0:_end]...)
	var (
		_converted *javascript.PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = javascript.PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

// class: ExtendableMessageEvent
type ExtendableMessageEvent struct {
	domcore.ExtendableEvent
}

// ExtendableMessageEventFromJS is casting a js.Value into ExtendableMessageEvent.
func ExtendableMessageEventFromJS(value js.Value) *ExtendableMessageEvent {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &ExtendableMessageEvent{}
	ret.Value_JS = value
	return ret
}

// ExtendableMessageEventFromJS is casting from something that holds a js.Value into ExtendableMessageEvent.
func ExtendableMessageEventFromWrapper(input core.Wrapper) *ExtendableMessageEvent {
	return ExtendableMessageEventFromJS(input.JSValue())
}

func NewExtendableMessageEvent(_type string, eventInitDict *ExtendableMessageEventInit) (_result *ExtendableMessageEvent) {
	_klass := js.Global().Get("ExtendableMessageEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	if eventInitDict != nil {
		_p1 := eventInitDict.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *ExtendableMessageEvent // javascript: ExtendableMessageEvent _what_return_name
	)
	_converted = ExtendableMessageEventFromJS(_returned)
	_result = _converted
	return
}

// Data returning attribute 'data' with
// type Any (idl: any).
func (_this *ExtendableMessageEvent) Data() js.Value {
	var ret js.Value
	value := _this.Value_JS.Get("data")
	ret = value
	return ret
}

// Origin returning attribute 'origin' with
// type string (idl: USVString).
func (_this *ExtendableMessageEvent) Origin() string {
	var ret string
	value := _this.Value_JS.Get("origin")
	ret = (value).String()
	return ret
}

// LastEventId returning attribute 'lastEventId' with
// type string (idl: DOMString).
func (_this *ExtendableMessageEvent) LastEventId() string {
	var ret string
	value := _this.Value_JS.Get("lastEventId")
	ret = (value).String()
	return ret
}

// Source returning attribute 'source' with
// type Union (idl: Union).
func (_this *ExtendableMessageEvent) Source() *Union {
	var ret *Union
	value := _this.Value_JS.Get("source")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = UnionFromJS(value)
	}
	return ret
}

// Ports returning attribute 'ports' with
// type javascript.FrozenArray (idl: FrozenArray).
func (_this *ExtendableMessageEvent) Ports() *javascript.FrozenArray {
	var ret *javascript.FrozenArray
	value := _this.Value_JS.Get("ports")
	ret = javascript.FrozenArrayFromJS(value)
	return ret
}

// class: FetchEvent
type FetchEvent struct {
	domcore.ExtendableEvent
}

// FetchEventFromJS is casting a js.Value into FetchEvent.
func FetchEventFromJS(value js.Value) *FetchEvent {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &FetchEvent{}
	ret.Value_JS = value
	return ret
}

// FetchEventFromJS is casting from something that holds a js.Value into FetchEvent.
func FetchEventFromWrapper(input core.Wrapper) *FetchEvent {
	return FetchEventFromJS(input.JSValue())
}

func NewFetchEvent(_type string, eventInitDict *FetchEventInit) (_result *FetchEvent) {
	_klass := js.Global().Get("FetchEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := eventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *FetchEvent // javascript: FetchEvent _what_return_name
	)
	_converted = FetchEventFromJS(_returned)
	_result = _converted
	return
}

// Request returning attribute 'request' with
// type fetch.Request (idl: Request).
func (_this *FetchEvent) Request() *fetch.Request {
	var ret *fetch.Request
	value := _this.Value_JS.Get("request")
	ret = fetch.RequestFromJS(value)
	return ret
}

// ClientId returning attribute 'clientId' with
// type string (idl: DOMString).
func (_this *FetchEvent) ClientId() string {
	var ret string
	value := _this.Value_JS.Get("clientId")
	ret = (value).String()
	return ret
}

func (_this *FetchEvent) RespondWith(r *fetch.PromiseResponse) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := r.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("respondWith", _args[0:_end]...)
	return
}

// class: Promise
type PromiseBackgroundFetchRecord struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PromiseBackgroundFetchRecord) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseBackgroundFetchRecordFromJS is casting a js.Value into PromiseBackgroundFetchRecord.
func PromiseBackgroundFetchRecordFromJS(value js.Value) *PromiseBackgroundFetchRecord {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseBackgroundFetchRecord{}
	ret.Value_JS = value
	return ret
}

// PromiseBackgroundFetchRecordFromJS is casting from something that holds a js.Value into PromiseBackgroundFetchRecord.
func PromiseBackgroundFetchRecordFromWrapper(input core.Wrapper) *PromiseBackgroundFetchRecord {
	return PromiseBackgroundFetchRecordFromJS(input.JSValue())
}

func (_this *PromiseBackgroundFetchRecord) Then(onFulfilled *PromiseBackgroundFetchRecordOnFulfilled, onRejected *PromiseBackgroundFetchRecordOnRejected) (_result *PromiseBackgroundFetchRecord) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseBackgroundFetchRecord // javascript: Promise _what_return_name
	)
	_converted = PromiseBackgroundFetchRecordFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseBackgroundFetchRecord) Catch(onRejected *PromiseBackgroundFetchRecordOnRejected) (_result *PromiseBackgroundFetchRecord) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseBackgroundFetchRecord // javascript: Promise _what_return_name
	)
	_converted = PromiseBackgroundFetchRecordFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseBackgroundFetchRecord) Finally(onFinally *javascript.PromiseFinally) (_result *PromiseBackgroundFetchRecord) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseBackgroundFetchRecord // javascript: Promise _what_return_name
	)
	_converted = PromiseBackgroundFetchRecordFromJS(_returned)
	_result = _converted
	return
}

// class: Promise
type PromiseBackgroundFetchRegistration struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PromiseBackgroundFetchRegistration) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseBackgroundFetchRegistrationFromJS is casting a js.Value into PromiseBackgroundFetchRegistration.
func PromiseBackgroundFetchRegistrationFromJS(value js.Value) *PromiseBackgroundFetchRegistration {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseBackgroundFetchRegistration{}
	ret.Value_JS = value
	return ret
}

// PromiseBackgroundFetchRegistrationFromJS is casting from something that holds a js.Value into PromiseBackgroundFetchRegistration.
func PromiseBackgroundFetchRegistrationFromWrapper(input core.Wrapper) *PromiseBackgroundFetchRegistration {
	return PromiseBackgroundFetchRegistrationFromJS(input.JSValue())
}

func (_this *PromiseBackgroundFetchRegistration) Then(onFulfilled *PromiseBackgroundFetchRegistrationOnFulfilled, onRejected *PromiseBackgroundFetchRegistrationOnRejected) (_result *PromiseBackgroundFetchRegistration) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseBackgroundFetchRegistration // javascript: Promise _what_return_name
	)
	_converted = PromiseBackgroundFetchRegistrationFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseBackgroundFetchRegistration) Catch(onRejected *PromiseBackgroundFetchRegistrationOnRejected) (_result *PromiseBackgroundFetchRegistration) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseBackgroundFetchRegistration // javascript: Promise _what_return_name
	)
	_converted = PromiseBackgroundFetchRegistrationFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseBackgroundFetchRegistration) Finally(onFinally *javascript.PromiseFinally) (_result *PromiseBackgroundFetchRegistration) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseBackgroundFetchRegistration // javascript: Promise _what_return_name
	)
	_converted = PromiseBackgroundFetchRegistrationFromJS(_returned)
	_result = _converted
	return
}

// class: Promise
type PromiseCache struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PromiseCache) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseCacheFromJS is casting a js.Value into PromiseCache.
func PromiseCacheFromJS(value js.Value) *PromiseCache {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseCache{}
	ret.Value_JS = value
	return ret
}

// PromiseCacheFromJS is casting from something that holds a js.Value into PromiseCache.
func PromiseCacheFromWrapper(input core.Wrapper) *PromiseCache {
	return PromiseCacheFromJS(input.JSValue())
}

func (_this *PromiseCache) Then(onFulfilled *PromiseCacheOnFulfilled, onRejected *PromiseCacheOnRejected) (_result *PromiseCache) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseCache // javascript: Promise _what_return_name
	)
	_converted = PromiseCacheFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseCache) Catch(onRejected *PromiseCacheOnRejected) (_result *PromiseCache) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseCache // javascript: Promise _what_return_name
	)
	_converted = PromiseCacheFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseCache) Finally(onFinally *javascript.PromiseFinally) (_result *PromiseCache) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseCache // javascript: Promise _what_return_name
	)
	_converted = PromiseCacheFromJS(_returned)
	_result = _converted
	return
}

// class: Promise
type PromiseNilBackgroundFetchRegistration struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PromiseNilBackgroundFetchRegistration) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseNilBackgroundFetchRegistrationFromJS is casting a js.Value into PromiseNilBackgroundFetchRegistration.
func PromiseNilBackgroundFetchRegistrationFromJS(value js.Value) *PromiseNilBackgroundFetchRegistration {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseNilBackgroundFetchRegistration{}
	ret.Value_JS = value
	return ret
}

// PromiseNilBackgroundFetchRegistrationFromJS is casting from something that holds a js.Value into PromiseNilBackgroundFetchRegistration.
func PromiseNilBackgroundFetchRegistrationFromWrapper(input core.Wrapper) *PromiseNilBackgroundFetchRegistration {
	return PromiseNilBackgroundFetchRegistrationFromJS(input.JSValue())
}

func (_this *PromiseNilBackgroundFetchRegistration) Then(onFulfilled *PromiseNilBackgroundFetchRegistrationOnFulfilled, onRejected *PromiseNilBackgroundFetchRegistrationOnRejected) (_result *PromiseNilBackgroundFetchRegistration) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseNilBackgroundFetchRegistration // javascript: Promise _what_return_name
	)
	_converted = PromiseNilBackgroundFetchRegistrationFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseNilBackgroundFetchRegistration) Catch(onRejected *PromiseNilBackgroundFetchRegistrationOnRejected) (_result *PromiseNilBackgroundFetchRegistration) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseNilBackgroundFetchRegistration // javascript: Promise _what_return_name
	)
	_converted = PromiseNilBackgroundFetchRegistrationFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseNilBackgroundFetchRegistration) Finally(onFinally *javascript.PromiseFinally) (_result *PromiseNilBackgroundFetchRegistration) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseNilBackgroundFetchRegistration // javascript: Promise _what_return_name
	)
	_converted = PromiseNilBackgroundFetchRegistrationFromJS(_returned)
	_result = _converted
	return
}

// class: Promise
type PromiseSequenceBackgroundFetchRecord struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PromiseSequenceBackgroundFetchRecord) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseSequenceBackgroundFetchRecordFromJS is casting a js.Value into PromiseSequenceBackgroundFetchRecord.
func PromiseSequenceBackgroundFetchRecordFromJS(value js.Value) *PromiseSequenceBackgroundFetchRecord {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseSequenceBackgroundFetchRecord{}
	ret.Value_JS = value
	return ret
}

// PromiseSequenceBackgroundFetchRecordFromJS is casting from something that holds a js.Value into PromiseSequenceBackgroundFetchRecord.
func PromiseSequenceBackgroundFetchRecordFromWrapper(input core.Wrapper) *PromiseSequenceBackgroundFetchRecord {
	return PromiseSequenceBackgroundFetchRecordFromJS(input.JSValue())
}

func (_this *PromiseSequenceBackgroundFetchRecord) Then(onFulfilled *PromiseSequenceBackgroundFetchRecordOnFulfilled, onRejected *PromiseSequenceBackgroundFetchRecordOnRejected) (_result *PromiseSequenceBackgroundFetchRecord) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseSequenceBackgroundFetchRecord // javascript: Promise _what_return_name
	)
	_converted = PromiseSequenceBackgroundFetchRecordFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseSequenceBackgroundFetchRecord) Catch(onRejected *PromiseSequenceBackgroundFetchRecordOnRejected) (_result *PromiseSequenceBackgroundFetchRecord) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseSequenceBackgroundFetchRecord // javascript: Promise _what_return_name
	)
	_converted = PromiseSequenceBackgroundFetchRecordFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseSequenceBackgroundFetchRecord) Finally(onFinally *javascript.PromiseFinally) (_result *PromiseSequenceBackgroundFetchRecord) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseSequenceBackgroundFetchRecord // javascript: Promise _what_return_name
	)
	_converted = PromiseSequenceBackgroundFetchRecordFromJS(_returned)
	_result = _converted
	return
}

// class: Promise
type PromiseServiceWorkerRegistration struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PromiseServiceWorkerRegistration) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseServiceWorkerRegistrationFromJS is casting a js.Value into PromiseServiceWorkerRegistration.
func PromiseServiceWorkerRegistrationFromJS(value js.Value) *PromiseServiceWorkerRegistration {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseServiceWorkerRegistration{}
	ret.Value_JS = value
	return ret
}

// PromiseServiceWorkerRegistrationFromJS is casting from something that holds a js.Value into PromiseServiceWorkerRegistration.
func PromiseServiceWorkerRegistrationFromWrapper(input core.Wrapper) *PromiseServiceWorkerRegistration {
	return PromiseServiceWorkerRegistrationFromJS(input.JSValue())
}

func (_this *PromiseServiceWorkerRegistration) Then(onFulfilled *PromiseServiceWorkerRegistrationOnFulfilled, onRejected *PromiseServiceWorkerRegistrationOnRejected) (_result *PromiseServiceWorkerRegistration) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseServiceWorkerRegistration // javascript: Promise _what_return_name
	)
	_converted = PromiseServiceWorkerRegistrationFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseServiceWorkerRegistration) Catch(onRejected *PromiseServiceWorkerRegistrationOnRejected) (_result *PromiseServiceWorkerRegistration) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseServiceWorkerRegistration // javascript: Promise _what_return_name
	)
	_converted = PromiseServiceWorkerRegistrationFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseServiceWorkerRegistration) Finally(onFinally *javascript.PromiseFinally) (_result *PromiseServiceWorkerRegistration) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseServiceWorkerRegistration // javascript: Promise _what_return_name
	)
	_converted = PromiseServiceWorkerRegistrationFromJS(_returned)
	_result = _converted
	return
}

// class: ServiceWorker
type ServiceWorker struct {
	domcore.EventTarget
}

// ServiceWorkerFromJS is casting a js.Value into ServiceWorker.
func ServiceWorkerFromJS(value js.Value) *ServiceWorker {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &ServiceWorker{}
	ret.Value_JS = value
	return ret
}

// ServiceWorkerFromJS is casting from something that holds a js.Value into ServiceWorker.
func ServiceWorkerFromWrapper(input core.Wrapper) *ServiceWorker {
	return ServiceWorkerFromJS(input.JSValue())
}

// ScriptURL returning attribute 'scriptURL' with
// type string (idl: USVString).
func (_this *ServiceWorker) ScriptURL() string {
	var ret string
	value := _this.Value_JS.Get("scriptURL")
	ret = (value).String()
	return ret
}

// State returning attribute 'state' with
// type ServiceWorkerState (idl: ServiceWorkerState).
func (_this *ServiceWorker) State() ServiceWorkerState {
	var ret ServiceWorkerState
	value := _this.Value_JS.Get("state")
	ret = ServiceWorkerStateFromJS(value)
	return ret
}

// OnStateChange returning attribute 'onstatechange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ServiceWorker) OnStateChange() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onstatechange")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnError returning attribute 'onerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ServiceWorker) OnError() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onerror")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// event attribute: domcore.Event
func eventFuncServiceWorker_domcore_Event(listener func(event *domcore.Event, target *ServiceWorker)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *domcore.Event
		value := args[0]
		incoming := value.Get("target")
		ret = domcore.EventFromJS(value)
		src := ServiceWorkerFromJS(incoming)
		listener(ret, src)
		return js.Undefined()
	}
	return js.FuncOf(fn)
}

// AddError is adding doing AddEventListener for 'Error' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *ServiceWorker) AddEventError(listener func(event *domcore.Event, currentTarget *ServiceWorker)) js.Func {
	cb := eventFuncServiceWorker_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "error", cb)
	return cb
}

// SetOnError is assigning a function to 'onerror'. This
// This method is returning allocated javascript function that need to be released.
func (_this *ServiceWorker) SetOnError(listener func(event *domcore.Event, currentTarget *ServiceWorker)) js.Func {
	cb := eventFuncServiceWorker_domcore_Event(listener)
	_this.Value_JS.Set("onerror", cb)
	return cb
}

// AddStateChange is adding doing AddEventListener for 'StateChange' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *ServiceWorker) AddEventStateChange(listener func(event *domcore.Event, currentTarget *ServiceWorker)) js.Func {
	cb := eventFuncServiceWorker_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "statechange", cb)
	return cb
}

// SetOnStateChange is assigning a function to 'onstatechange'. This
// This method is returning allocated javascript function that need to be released.
func (_this *ServiceWorker) SetOnStateChange(listener func(event *domcore.Event, currentTarget *ServiceWorker)) js.Func {
	cb := eventFuncServiceWorker_domcore_Event(listener)
	_this.Value_JS.Set("onstatechange", cb)
	return cb
}

func (_this *ServiceWorker) PostMessage(message interface{}, transfer []*javascript.Object) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := message
	_args[0] = _p0
	_end++
	if transfer != nil {
		_p1 := js.Global().Get("Array").New(len(transfer))
		for __idx1, __seq_in1 := range transfer {
			__seq_out1 := __seq_in1.JSValue()
			_p1.SetIndex(__idx1, __seq_out1)
		}
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("postMessage", _args[0:_end]...)
	return
}

// class: ServiceWorkerContainer
type ServiceWorkerContainer struct {
	domcore.EventTarget
}

// ServiceWorkerContainerFromJS is casting a js.Value into ServiceWorkerContainer.
func ServiceWorkerContainerFromJS(value js.Value) *ServiceWorkerContainer {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &ServiceWorkerContainer{}
	ret.Value_JS = value
	return ret
}

// ServiceWorkerContainerFromJS is casting from something that holds a js.Value into ServiceWorkerContainer.
func ServiceWorkerContainerFromWrapper(input core.Wrapper) *ServiceWorkerContainer {
	return ServiceWorkerContainerFromJS(input.JSValue())
}

// Controller returning attribute 'controller' with
// type ServiceWorker (idl: ServiceWorker).
func (_this *ServiceWorkerContainer) Controller() *ServiceWorker {
	var ret *ServiceWorker
	value := _this.Value_JS.Get("controller")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = ServiceWorkerFromJS(value)
	}
	return ret
}

// Ready returning attribute 'ready' with
// type javascript.Promise (idl: Promise).
func (_this *ServiceWorkerContainer) Ready() *javascript.Promise {
	var ret *javascript.Promise
	value := _this.Value_JS.Get("ready")
	ret = javascript.PromiseFromJS(value)
	return ret
}

// OnControllerChange returning attribute 'oncontrollerchange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ServiceWorkerContainer) OnControllerChange() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("oncontrollerchange")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnMessage returning attribute 'onmessage' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ServiceWorkerContainer) OnMessage() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onmessage")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnMessageError returning attribute 'onmessageerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ServiceWorkerContainer) OnMessageError() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onmessageerror")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// event attribute: domcore.Event
func eventFuncServiceWorkerContainer_domcore_Event(listener func(event *domcore.Event, target *ServiceWorkerContainer)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *domcore.Event
		value := args[0]
		incoming := value.Get("target")
		ret = domcore.EventFromJS(value)
		src := ServiceWorkerContainerFromJS(incoming)
		listener(ret, src)
		return js.Undefined()
	}
	return js.FuncOf(fn)
}

// AddControllerChange is adding doing AddEventListener for 'ControllerChange' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *ServiceWorkerContainer) AddEventControllerChange(listener func(event *domcore.Event, currentTarget *ServiceWorkerContainer)) js.Func {
	cb := eventFuncServiceWorkerContainer_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "controllerchange", cb)
	return cb
}

// SetOnControllerChange is assigning a function to 'oncontrollerchange'. This
// This method is returning allocated javascript function that need to be released.
func (_this *ServiceWorkerContainer) SetOnControllerChange(listener func(event *domcore.Event, currentTarget *ServiceWorkerContainer)) js.Func {
	cb := eventFuncServiceWorkerContainer_domcore_Event(listener)
	_this.Value_JS.Set("oncontrollerchange", cb)
	return cb
}

// event attribute: ExtendableMessageEvent
func eventFuncServiceWorkerContainer_ExtendableMessageEvent(listener func(event *ExtendableMessageEvent, target *ServiceWorkerContainer)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *ExtendableMessageEvent
		value := args[0]
		incoming := value.Get("target")
		ret = ExtendableMessageEventFromJS(value)
		src := ServiceWorkerContainerFromJS(incoming)
		listener(ret, src)
		return js.Undefined()
	}
	return js.FuncOf(fn)
}

// AddMessage is adding doing AddEventListener for 'Message' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *ServiceWorkerContainer) AddEventMessage(listener func(event *ExtendableMessageEvent, currentTarget *ServiceWorkerContainer)) js.Func {
	cb := eventFuncServiceWorkerContainer_ExtendableMessageEvent(listener)
	_this.Value_JS.Call("addEventListener", "message", cb)
	return cb
}

// SetOnMessage is assigning a function to 'onmessage'. This
// This method is returning allocated javascript function that need to be released.
func (_this *ServiceWorkerContainer) SetOnMessage(listener func(event *ExtendableMessageEvent, currentTarget *ServiceWorkerContainer)) js.Func {
	cb := eventFuncServiceWorkerContainer_ExtendableMessageEvent(listener)
	_this.Value_JS.Set("onmessage", cb)
	return cb
}

// event attribute: channel.MessageEvent
func eventFuncServiceWorkerContainer_channel_MessageEvent(listener func(event *channel.MessageEvent, target *ServiceWorkerContainer)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *channel.MessageEvent
		value := args[0]
		incoming := value.Get("target")
		ret = channel.MessageEventFromJS(value)
		src := ServiceWorkerContainerFromJS(incoming)
		listener(ret, src)
		return js.Undefined()
	}
	return js.FuncOf(fn)
}

// AddMessageError is adding doing AddEventListener for 'MessageError' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *ServiceWorkerContainer) AddEventMessageError(listener func(event *channel.MessageEvent, currentTarget *ServiceWorkerContainer)) js.Func {
	cb := eventFuncServiceWorkerContainer_channel_MessageEvent(listener)
	_this.Value_JS.Call("addEventListener", "messageerror", cb)
	return cb
}

// SetOnMessageError is assigning a function to 'onmessageerror'. This
// This method is returning allocated javascript function that need to be released.
func (_this *ServiceWorkerContainer) SetOnMessageError(listener func(event *channel.MessageEvent, currentTarget *ServiceWorkerContainer)) js.Func {
	cb := eventFuncServiceWorkerContainer_channel_MessageEvent(listener)
	_this.Value_JS.Set("onmessageerror", cb)
	return cb
}

func (_this *ServiceWorkerContainer) Register(scriptURL string, options *RegistrationOptions) (_result *PromiseServiceWorkerRegistration) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := scriptURL
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("register", _args[0:_end]...)
	var (
		_converted *PromiseServiceWorkerRegistration // javascript: Promise _what_return_name
	)
	_converted = PromiseServiceWorkerRegistrationFromJS(_returned)
	_result = _converted
	return
}

func (_this *ServiceWorkerContainer) GetRegistration(clientURL *string) (_result *javascript.Promise) {
	var (
		_args [1]interface{}
		_end  int
	)
	if clientURL != nil {

		var _p0 interface{}
		if clientURL != nil {
			_p0 = *(clientURL)
		} else {
			_p0 = nil
		}
		_args[0] = _p0
		_end++
	}
	_returned := _this.Value_JS.Call("getRegistration", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *ServiceWorkerContainer) GetRegistrations() (_result *javascript.PromiseFrozenArray) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getRegistrations", _args[0:_end]...)
	var (
		_converted *javascript.PromiseFrozenArray // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFrozenArrayFromJS(_returned)
	_result = _converted
	return
}

func (_this *ServiceWorkerContainer) StartMessages() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("startMessages", _args[0:_end]...)
	return
}

// class: ServiceWorkerRegistration
type ServiceWorkerRegistration struct {
	domcore.EventTarget
}

// ServiceWorkerRegistrationFromJS is casting a js.Value into ServiceWorkerRegistration.
func ServiceWorkerRegistrationFromJS(value js.Value) *ServiceWorkerRegistration {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &ServiceWorkerRegistration{}
	ret.Value_JS = value
	return ret
}

// ServiceWorkerRegistrationFromJS is casting from something that holds a js.Value into ServiceWorkerRegistration.
func ServiceWorkerRegistrationFromWrapper(input core.Wrapper) *ServiceWorkerRegistration {
	return ServiceWorkerRegistrationFromJS(input.JSValue())
}

// Installing returning attribute 'installing' with
// type ServiceWorker (idl: ServiceWorker).
func (_this *ServiceWorkerRegistration) Installing() *ServiceWorker {
	var ret *ServiceWorker
	value := _this.Value_JS.Get("installing")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = ServiceWorkerFromJS(value)
	}
	return ret
}

// Waiting returning attribute 'waiting' with
// type ServiceWorker (idl: ServiceWorker).
func (_this *ServiceWorkerRegistration) Waiting() *ServiceWorker {
	var ret *ServiceWorker
	value := _this.Value_JS.Get("waiting")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = ServiceWorkerFromJS(value)
	}
	return ret
}

// Active returning attribute 'active' with
// type ServiceWorker (idl: ServiceWorker).
func (_this *ServiceWorkerRegistration) Active() *ServiceWorker {
	var ret *ServiceWorker
	value := _this.Value_JS.Get("active")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = ServiceWorkerFromJS(value)
	}
	return ret
}

// Scope returning attribute 'scope' with
// type string (idl: USVString).
func (_this *ServiceWorkerRegistration) Scope() string {
	var ret string
	value := _this.Value_JS.Get("scope")
	ret = (value).String()
	return ret
}

// UpdateViaCache returning attribute 'updateViaCache' with
// type ServiceWorkerUpdateViaCache (idl: ServiceWorkerUpdateViaCache).
func (_this *ServiceWorkerRegistration) UpdateViaCache() ServiceWorkerUpdateViaCache {
	var ret ServiceWorkerUpdateViaCache
	value := _this.Value_JS.Get("updateViaCache")
	ret = ServiceWorkerUpdateViaCacheFromJS(value)
	return ret
}

// OnUpdateFound returning attribute 'onupdatefound' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ServiceWorkerRegistration) OnUpdateFound() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onupdatefound")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// Sync returning attribute 'sync' with
// type SyncManager (idl: SyncManager).
func (_this *ServiceWorkerRegistration) Sync() *SyncManager {
	var ret *SyncManager
	value := _this.Value_JS.Get("sync")
	ret = SyncManagerFromJS(value)
	return ret
}

// BackgroundFetch returning attribute 'backgroundFetch' with
// type BackgroundFetchManager (idl: BackgroundFetchManager).
func (_this *ServiceWorkerRegistration) BackgroundFetch() *BackgroundFetchManager {
	var ret *BackgroundFetchManager
	value := _this.Value_JS.Get("backgroundFetch")
	ret = BackgroundFetchManagerFromJS(value)
	return ret
}

// PaymentManager returning attribute 'paymentManager' with
// type payment.PaymentManager (idl: PaymentManager).
func (_this *ServiceWorkerRegistration) PaymentManager() *payment.PaymentManager {
	var ret *payment.PaymentManager
	value := _this.Value_JS.Get("paymentManager")
	ret = payment.PaymentManagerFromJS(value)
	return ret
}

// PushManager returning attribute 'pushManager' with
// type push.Manager (idl: PushManager).
func (_this *ServiceWorkerRegistration) PushManager() *push.Manager {
	var ret *push.Manager
	value := _this.Value_JS.Get("pushManager")
	ret = push.ManagerFromJS(value)
	return ret
}

// event attribute: domcore.Event
func eventFuncServiceWorkerRegistration_domcore_Event(listener func(event *domcore.Event, target *ServiceWorkerRegistration)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *domcore.Event
		value := args[0]
		incoming := value.Get("target")
		ret = domcore.EventFromJS(value)
		src := ServiceWorkerRegistrationFromJS(incoming)
		listener(ret, src)
		return js.Undefined()
	}
	return js.FuncOf(fn)
}

// AddUpdateFound is adding doing AddEventListener for 'UpdateFound' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *ServiceWorkerRegistration) AddEventUpdateFound(listener func(event *domcore.Event, currentTarget *ServiceWorkerRegistration)) js.Func {
	cb := eventFuncServiceWorkerRegistration_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "updatefound", cb)
	return cb
}

// SetOnUpdateFound is assigning a function to 'onupdatefound'. This
// This method is returning allocated javascript function that need to be released.
func (_this *ServiceWorkerRegistration) SetOnUpdateFound(listener func(event *domcore.Event, currentTarget *ServiceWorkerRegistration)) js.Func {
	cb := eventFuncServiceWorkerRegistration_domcore_Event(listener)
	_this.Value_JS.Set("onupdatefound", cb)
	return cb
}

func (_this *ServiceWorkerRegistration) Update() (_result *javascript.PromiseVoid) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("update", _args[0:_end]...)
	var (
		_converted *javascript.PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = javascript.PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

func (_this *ServiceWorkerRegistration) Unregister() (_result *javascript.PromiseBool) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("unregister", _args[0:_end]...)
	var (
		_converted *javascript.PromiseBool // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseBoolFromJS(_returned)
	_result = _converted
	return
}

// class: SyncEvent
type SyncEvent struct {
	domcore.ExtendableEvent
}

// SyncEventFromJS is casting a js.Value into SyncEvent.
func SyncEventFromJS(value js.Value) *SyncEvent {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &SyncEvent{}
	ret.Value_JS = value
	return ret
}

// SyncEventFromJS is casting from something that holds a js.Value into SyncEvent.
func SyncEventFromWrapper(input core.Wrapper) *SyncEvent {
	return SyncEventFromJS(input.JSValue())
}

func NewSyncEvent(_type string, init *SyncEventInit) (_result *SyncEvent) {
	_klass := js.Global().Get("SyncEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := init.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SyncEvent // javascript: SyncEvent _what_return_name
	)
	_converted = SyncEventFromJS(_returned)
	_result = _converted
	return
}

// Tag returning attribute 'tag' with
// type string (idl: DOMString).
func (_this *SyncEvent) Tag() string {
	var ret string
	value := _this.Value_JS.Get("tag")
	ret = (value).String()
	return ret
}

// LastChance returning attribute 'lastChance' with
// type bool (idl: boolean).
func (_this *SyncEvent) LastChance() bool {
	var ret bool
	value := _this.Value_JS.Get("lastChance")
	ret = (value).Bool()
	return ret
}

// class: SyncManager
type SyncManager struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *SyncManager) JSValue() js.Value {
	return _this.Value_JS
}

// SyncManagerFromJS is casting a js.Value into SyncManager.
func SyncManagerFromJS(value js.Value) *SyncManager {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &SyncManager{}
	ret.Value_JS = value
	return ret
}

// SyncManagerFromJS is casting from something that holds a js.Value into SyncManager.
func SyncManagerFromWrapper(input core.Wrapper) *SyncManager {
	return SyncManagerFromJS(input.JSValue())
}

func (_this *SyncManager) Register(tag string) (_result *javascript.PromiseVoid) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := tag
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("register", _args[0:_end]...)
	var (
		_converted *javascript.PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = javascript.PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

func (_this *SyncManager) GetTags() (_result *javascript.PromiseSequenceString) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getTags", _args[0:_end]...)
	var (
		_converted *javascript.PromiseSequenceString // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseSequenceStringFromJS(_returned)
	_result = _converted
	return
}
