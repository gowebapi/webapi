// Code generated by webidl-bind. DO NOT EDIT.

package serviceworker

import "syscall/js"

import (
	"github.com/gowebapi/webapi/appmanifest"
	"github.com/gowebapi/webapi/dom/domcore"
	"github.com/gowebapi/webapi/fetch"
	"github.com/gowebapi/webapi/html/channel"
	"github.com/gowebapi/webapi/html/htmlcommon"
	"github.com/gowebapi/webapi/javascript"
	"github.com/gowebapi/webapi/payment"
)

// using following types:
// appmanifest.ImageResource
// channel.MessagePort
// domcore.EventHandler
// domcore.EventTarget
// domcore.ExtendableEvent
// domcore.VisibilityState
// fetch.Request
// fetch.Response
// htmlcommon.WorkerType
// javascript.FrozenArray
// javascript.Object
// javascript.Promise
// payment.PaymentManager

// ReleasableApiResource is used to release underlaying
// allocated resources.
type ReleasableApiResource interface {
	Release()
}

type releasableApiResourceList []ReleasableApiResource

func (a releasableApiResourceList) Release() {
	for _, v := range a {
		v.Release()
	}
}

// workaround for compiler error
func unused(value interface{}) {
	// TODO remove this method
}

type Union struct {
	Value js.Value
}

func (u *Union) JSValue() js.Value {
	return u.Value
}

func UnionFromJS(value js.Value) *Union {
	return &Union{Value: value}
}

// enum: BackgroundFetchFailureReason
type BackgroundFetchFailureReason int

const (
	EmptyString0BackgroundFetchFailureReason BackgroundFetchFailureReason = iota
	AbortedBackgroundFetchFailureReason
	BadStatusBackgroundFetchFailureReason
	FetchErrorBackgroundFetchFailureReason
	QuotaExceededBackgroundFetchFailureReason
	DownloadTotalExceededBackgroundFetchFailureReason
)

var backgroundFetchFailureReasonToWasmTable = []string{
	"", "aborted", "bad-status", "fetch-error", "quota-exceeded", "download-total-exceeded",
}

var backgroundFetchFailureReasonFromWasmTable = map[string]BackgroundFetchFailureReason{
	"": EmptyString0BackgroundFetchFailureReason, "aborted": AbortedBackgroundFetchFailureReason, "bad-status": BadStatusBackgroundFetchFailureReason, "fetch-error": FetchErrorBackgroundFetchFailureReason, "quota-exceeded": QuotaExceededBackgroundFetchFailureReason, "download-total-exceeded": DownloadTotalExceededBackgroundFetchFailureReason,
}

// JSValue is converting this enum into a java object
func (this *BackgroundFetchFailureReason) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this BackgroundFetchFailureReason) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(backgroundFetchFailureReasonToWasmTable) {
		return backgroundFetchFailureReasonToWasmTable[idx]
	}
	panic("unknown input value")
}

// BackgroundFetchFailureReasonFromJS is converting a javascript value into
// a BackgroundFetchFailureReason enum value.
func BackgroundFetchFailureReasonFromJS(value js.Value) BackgroundFetchFailureReason {
	key := value.String()
	conv, ok := backgroundFetchFailureReasonFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: BackgroundFetchResult
type BackgroundFetchResult int

const (
	EmptyString0BackgroundFetchResult BackgroundFetchResult = iota
	SuccessBackgroundFetchResult
	FailureBackgroundFetchResult
)

var backgroundFetchResultToWasmTable = []string{
	"", "success", "failure",
}

var backgroundFetchResultFromWasmTable = map[string]BackgroundFetchResult{
	"": EmptyString0BackgroundFetchResult, "success": SuccessBackgroundFetchResult, "failure": FailureBackgroundFetchResult,
}

// JSValue is converting this enum into a java object
func (this *BackgroundFetchResult) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this BackgroundFetchResult) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(backgroundFetchResultToWasmTable) {
		return backgroundFetchResultToWasmTable[idx]
	}
	panic("unknown input value")
}

// BackgroundFetchResultFromJS is converting a javascript value into
// a BackgroundFetchResult enum value.
func BackgroundFetchResultFromJS(value js.Value) BackgroundFetchResult {
	key := value.String()
	conv, ok := backgroundFetchResultFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: ClientType
type ClientType int

const (
	WindowClientType ClientType = iota
	WorkerClientType
	SharedworkerClientType
	AllClientType
)

var clientTypeToWasmTable = []string{
	"window", "worker", "sharedworker", "all",
}

var clientTypeFromWasmTable = map[string]ClientType{
	"window": WindowClientType, "worker": WorkerClientType, "sharedworker": SharedworkerClientType, "all": AllClientType,
}

// JSValue is converting this enum into a java object
func (this *ClientType) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this ClientType) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(clientTypeToWasmTable) {
		return clientTypeToWasmTable[idx]
	}
	panic("unknown input value")
}

// ClientTypeFromJS is converting a javascript value into
// a ClientType enum value.
func ClientTypeFromJS(value js.Value) ClientType {
	key := value.String()
	conv, ok := clientTypeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: FrameType
type FrameType int

const (
	AuxiliaryFrameType FrameType = iota
	TopLevelFrameType
	NestedFrameType
	NoneFrameType
)

var frameTypeToWasmTable = []string{
	"auxiliary", "top-level", "nested", "none",
}

var frameTypeFromWasmTable = map[string]FrameType{
	"auxiliary": AuxiliaryFrameType, "top-level": TopLevelFrameType, "nested": NestedFrameType, "none": NoneFrameType,
}

// JSValue is converting this enum into a java object
func (this *FrameType) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this FrameType) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(frameTypeToWasmTable) {
		return frameTypeToWasmTable[idx]
	}
	panic("unknown input value")
}

// FrameTypeFromJS is converting a javascript value into
// a FrameType enum value.
func FrameTypeFromJS(value js.Value) FrameType {
	key := value.String()
	conv, ok := frameTypeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: ServiceWorkerState
type ServiceWorkerState int

const (
	InstallingServiceWorkerState ServiceWorkerState = iota
	InstalledServiceWorkerState
	ActivatingServiceWorkerState
	ActivatedServiceWorkerState
	RedundantServiceWorkerState
)

var serviceWorkerStateToWasmTable = []string{
	"installing", "installed", "activating", "activated", "redundant",
}

var serviceWorkerStateFromWasmTable = map[string]ServiceWorkerState{
	"installing": InstallingServiceWorkerState, "installed": InstalledServiceWorkerState, "activating": ActivatingServiceWorkerState, "activated": ActivatedServiceWorkerState, "redundant": RedundantServiceWorkerState,
}

// JSValue is converting this enum into a java object
func (this *ServiceWorkerState) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this ServiceWorkerState) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(serviceWorkerStateToWasmTable) {
		return serviceWorkerStateToWasmTable[idx]
	}
	panic("unknown input value")
}

// ServiceWorkerStateFromJS is converting a javascript value into
// a ServiceWorkerState enum value.
func ServiceWorkerStateFromJS(value js.Value) ServiceWorkerState {
	key := value.String()
	conv, ok := serviceWorkerStateFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: ServiceWorkerUpdateViaCache
type ServiceWorkerUpdateViaCache int

const (
	ImportsServiceWorkerUpdateViaCache ServiceWorkerUpdateViaCache = iota
	AllServiceWorkerUpdateViaCache
	NoneServiceWorkerUpdateViaCache
)

var serviceWorkerUpdateViaCacheToWasmTable = []string{
	"imports", "all", "none",
}

var serviceWorkerUpdateViaCacheFromWasmTable = map[string]ServiceWorkerUpdateViaCache{
	"imports": ImportsServiceWorkerUpdateViaCache, "all": AllServiceWorkerUpdateViaCache, "none": NoneServiceWorkerUpdateViaCache,
}

// JSValue is converting this enum into a java object
func (this *ServiceWorkerUpdateViaCache) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this ServiceWorkerUpdateViaCache) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(serviceWorkerUpdateViaCacheToWasmTable) {
		return serviceWorkerUpdateViaCacheToWasmTable[idx]
	}
	panic("unknown input value")
}

// ServiceWorkerUpdateViaCacheFromJS is converting a javascript value into
// a ServiceWorkerUpdateViaCache enum value.
func ServiceWorkerUpdateViaCacheFromJS(value js.Value) ServiceWorkerUpdateViaCache {
	key := value.String()
	conv, ok := serviceWorkerUpdateViaCacheFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// dictionary: BackgroundFetchEventInit
type BackgroundFetchEventInit struct {
	Bubbles      bool
	Cancelable   bool
	Composed     bool
	Registration *BackgroundFetchRegistration
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *BackgroundFetchEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Registration.JSValue()
	out.Set("registration", value3)
	return out
}

// BackgroundFetchEventInitFromJS is allocating a new
// BackgroundFetchEventInit object and copy all values from
// input javascript object
func BackgroundFetchEventInitFromJS(value js.Wrapper) *BackgroundFetchEventInit {
	input := value.JSValue()
	var out BackgroundFetchEventInit
	var (
		value0 bool                         // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool                         // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool                         // javascript: boolean {composed Composed composed}
		value3 *BackgroundFetchRegistration // javascript: BackgroundFetchRegistration {registration Registration registration}
	)
	value0 = (input.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (input.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (input.Get("composed")).Bool()
	out.Composed = value2
	value3 = BackgroundFetchRegistrationFromJS(input.Get("registration"))
	out.Registration = value3
	return &out
}

// dictionary: BackgroundFetchOptions
type BackgroundFetchOptions struct {
	Icons         []*appmanifest.ImageResource
	Title         string
	DownloadTotal int
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *BackgroundFetchOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.Icons))
	for __idx0, __seq_in0 := range _this.Icons {
		__seq_out0 := __seq_in0.JSValue()
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("icons", value0)
	value1 := _this.Title
	out.Set("title", value1)
	value2 := _this.DownloadTotal
	out.Set("downloadTotal", value2)
	return out
}

// BackgroundFetchOptionsFromJS is allocating a new
// BackgroundFetchOptions object and copy all values from
// input javascript object
func BackgroundFetchOptionsFromJS(value js.Wrapper) *BackgroundFetchOptions {
	input := value.JSValue()
	var out BackgroundFetchOptions
	var (
		value0 []*appmanifest.ImageResource // javascript: sequence<ImageResource> {icons Icons icons}
		value1 string                       // javascript: DOMString {title Title title}
		value2 int                          // javascript: unsigned long long {downloadTotal DownloadTotal downloadTotal}
	)
	__length0 := input.Get("icons").Length()
	__array0 := make([]*appmanifest.ImageResource, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *appmanifest.ImageResource
		__seq_in0 := input.Get("icons").Index(__idx0)
		__seq_out0 = appmanifest.ImageResourceFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.Icons = value0
	value1 = (input.Get("title")).String()
	out.Title = value1
	value2 = (input.Get("downloadTotal")).Int()
	out.DownloadTotal = value2
	return &out
}

// dictionary: BackgroundFetchUIOptions
type BackgroundFetchUIOptions struct {
	Icons []*appmanifest.ImageResource
	Title string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *BackgroundFetchUIOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.Icons))
	for __idx0, __seq_in0 := range _this.Icons {
		__seq_out0 := __seq_in0.JSValue()
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("icons", value0)
	value1 := _this.Title
	out.Set("title", value1)
	return out
}

// BackgroundFetchUIOptionsFromJS is allocating a new
// BackgroundFetchUIOptions object and copy all values from
// input javascript object
func BackgroundFetchUIOptionsFromJS(value js.Wrapper) *BackgroundFetchUIOptions {
	input := value.JSValue()
	var out BackgroundFetchUIOptions
	var (
		value0 []*appmanifest.ImageResource // javascript: sequence<ImageResource> {icons Icons icons}
		value1 string                       // javascript: DOMString {title Title title}
	)
	__length0 := input.Get("icons").Length()
	__array0 := make([]*appmanifest.ImageResource, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *appmanifest.ImageResource
		__seq_in0 := input.Get("icons").Index(__idx0)
		__seq_out0 = appmanifest.ImageResourceFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.Icons = value0
	value1 = (input.Get("title")).String()
	out.Title = value1
	return &out
}

// dictionary: CacheQueryOptions
type CacheQueryOptions struct {
	IgnoreSearch bool
	IgnoreMethod bool
	IgnoreVary   bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *CacheQueryOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.IgnoreSearch
	out.Set("ignoreSearch", value0)
	value1 := _this.IgnoreMethod
	out.Set("ignoreMethod", value1)
	value2 := _this.IgnoreVary
	out.Set("ignoreVary", value2)
	return out
}

// CacheQueryOptionsFromJS is allocating a new
// CacheQueryOptions object and copy all values from
// input javascript object
func CacheQueryOptionsFromJS(value js.Wrapper) *CacheQueryOptions {
	input := value.JSValue()
	var out CacheQueryOptions
	var (
		value0 bool // javascript: boolean {ignoreSearch IgnoreSearch ignoreSearch}
		value1 bool // javascript: boolean {ignoreMethod IgnoreMethod ignoreMethod}
		value2 bool // javascript: boolean {ignoreVary IgnoreVary ignoreVary}
	)
	value0 = (input.Get("ignoreSearch")).Bool()
	out.IgnoreSearch = value0
	value1 = (input.Get("ignoreMethod")).Bool()
	out.IgnoreMethod = value1
	value2 = (input.Get("ignoreVary")).Bool()
	out.IgnoreVary = value2
	return &out
}

// dictionary: ClientQueryOptions
type ClientQueryOptions struct {
	IncludeUncontrolled bool
	Type                ClientType
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *ClientQueryOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.IncludeUncontrolled
	out.Set("includeUncontrolled", value0)
	value1 := _this.Type.JSValue()
	out.Set("type", value1)
	return out
}

// ClientQueryOptionsFromJS is allocating a new
// ClientQueryOptions object and copy all values from
// input javascript object
func ClientQueryOptionsFromJS(value js.Wrapper) *ClientQueryOptions {
	input := value.JSValue()
	var out ClientQueryOptions
	var (
		value0 bool       // javascript: boolean {includeUncontrolled IncludeUncontrolled includeUncontrolled}
		value1 ClientType // javascript: ClientType {type Type _type}
	)
	value0 = (input.Get("includeUncontrolled")).Bool()
	out.IncludeUncontrolled = value0
	value1 = ClientTypeFromJS(input.Get("type"))
	out.Type = value1
	return &out
}

// dictionary: ExtendableMessageEventInit
type ExtendableMessageEventInit struct {
	Bubbles     bool
	Cancelable  bool
	Composed    bool
	Data        js.Value
	Origin      string
	LastEventId string
	Source      *Union
	Ports       []*channel.MessagePort
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *ExtendableMessageEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Data
	out.Set("data", value3)
	value4 := _this.Origin
	out.Set("origin", value4)
	value5 := _this.LastEventId
	out.Set("lastEventId", value5)
	value6 := _this.Source.JSValue()
	out.Set("source", value6)
	value7 := js.Global().Get("Array").New(len(_this.Ports))
	for __idx7, __seq_in7 := range _this.Ports {
		__seq_out7 := __seq_in7.JSValue()
		value7.SetIndex(__idx7, __seq_out7)
	}
	out.Set("ports", value7)
	return out
}

// ExtendableMessageEventInitFromJS is allocating a new
// ExtendableMessageEventInit object and copy all values from
// input javascript object
func ExtendableMessageEventInitFromJS(value js.Wrapper) *ExtendableMessageEventInit {
	input := value.JSValue()
	var out ExtendableMessageEventInit
	var (
		value0 bool                   // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool                   // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool                   // javascript: boolean {composed Composed composed}
		value3 js.Value               // javascript: any {data Data data}
		value4 string                 // javascript: USVString {origin Origin origin}
		value5 string                 // javascript: DOMString {lastEventId LastEventId lastEventId}
		value6 *Union                 // javascript: Union {source Source source}
		value7 []*channel.MessagePort // javascript: sequence<MessagePort> {ports Ports ports}
	)
	value0 = (input.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (input.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (input.Get("composed")).Bool()
	out.Composed = value2
	value3 = input.Get("data")
	out.Data = value3
	value4 = (input.Get("origin")).String()
	out.Origin = value4
	value5 = (input.Get("lastEventId")).String()
	out.LastEventId = value5
	if input.Get("source").Type() != js.TypeNull {
		value6 = UnionFromJS(input.Get("source"))
	}
	out.Source = value6
	__length7 := input.Get("ports").Length()
	__array7 := make([]*channel.MessagePort, __length7, __length7)
	for __idx7 := 0; __idx7 < __length7; __idx7++ {
		var __seq_out7 *channel.MessagePort
		__seq_in7 := input.Get("ports").Index(__idx7)
		__seq_out7 = channel.MessagePortFromJS(__seq_in7)
		__array7[__idx7] = __seq_out7
	}
	value7 = __array7
	out.Ports = value7
	return &out
}

// dictionary: FetchEventInit
type FetchEventInit struct {
	Bubbles    bool
	Cancelable bool
	Composed   bool
	Request    *fetch.Request
	ClientId   string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *FetchEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Request.JSValue()
	out.Set("request", value3)
	value4 := _this.ClientId
	out.Set("clientId", value4)
	return out
}

// FetchEventInitFromJS is allocating a new
// FetchEventInit object and copy all values from
// input javascript object
func FetchEventInitFromJS(value js.Wrapper) *FetchEventInit {
	input := value.JSValue()
	var out FetchEventInit
	var (
		value0 bool           // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool           // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool           // javascript: boolean {composed Composed composed}
		value3 *fetch.Request // javascript: Request {request Request request}
		value4 string         // javascript: DOMString {clientId ClientId clientId}
	)
	value0 = (input.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (input.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (input.Get("composed")).Bool()
	out.Composed = value2
	value3 = fetch.RequestFromJS(input.Get("request"))
	out.Request = value3
	value4 = (input.Get("clientId")).String()
	out.ClientId = value4
	return &out
}

// dictionary: MultiCacheQueryOptions
type MultiCacheQueryOptions struct {
	IgnoreSearch bool
	IgnoreMethod bool
	IgnoreVary   bool
	CacheName    string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *MultiCacheQueryOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.IgnoreSearch
	out.Set("ignoreSearch", value0)
	value1 := _this.IgnoreMethod
	out.Set("ignoreMethod", value1)
	value2 := _this.IgnoreVary
	out.Set("ignoreVary", value2)
	value3 := _this.CacheName
	out.Set("cacheName", value3)
	return out
}

// MultiCacheQueryOptionsFromJS is allocating a new
// MultiCacheQueryOptions object and copy all values from
// input javascript object
func MultiCacheQueryOptionsFromJS(value js.Wrapper) *MultiCacheQueryOptions {
	input := value.JSValue()
	var out MultiCacheQueryOptions
	var (
		value0 bool   // javascript: boolean {ignoreSearch IgnoreSearch ignoreSearch}
		value1 bool   // javascript: boolean {ignoreMethod IgnoreMethod ignoreMethod}
		value2 bool   // javascript: boolean {ignoreVary IgnoreVary ignoreVary}
		value3 string // javascript: DOMString {cacheName CacheName cacheName}
	)
	value0 = (input.Get("ignoreSearch")).Bool()
	out.IgnoreSearch = value0
	value1 = (input.Get("ignoreMethod")).Bool()
	out.IgnoreMethod = value1
	value2 = (input.Get("ignoreVary")).Bool()
	out.IgnoreVary = value2
	value3 = (input.Get("cacheName")).String()
	out.CacheName = value3
	return &out
}

// dictionary: RegistrationOptions
type RegistrationOptions struct {
	Scope          string
	Type           htmlcommon.WorkerType
	UpdateViaCache ServiceWorkerUpdateViaCache
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *RegistrationOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Scope
	out.Set("scope", value0)
	value1 := _this.Type.JSValue()
	out.Set("type", value1)
	value2 := _this.UpdateViaCache.JSValue()
	out.Set("updateViaCache", value2)
	return out
}

// RegistrationOptionsFromJS is allocating a new
// RegistrationOptions object and copy all values from
// input javascript object
func RegistrationOptionsFromJS(value js.Wrapper) *RegistrationOptions {
	input := value.JSValue()
	var out RegistrationOptions
	var (
		value0 string                      // javascript: USVString {scope Scope scope}
		value1 htmlcommon.WorkerType       // javascript: WorkerType {type Type _type}
		value2 ServiceWorkerUpdateViaCache // javascript: ServiceWorkerUpdateViaCache {updateViaCache UpdateViaCache updateViaCache}
	)
	value0 = (input.Get("scope")).String()
	out.Scope = value0
	value1 = htmlcommon.WorkerTypeFromJS(input.Get("type"))
	out.Type = value1
	value2 = ServiceWorkerUpdateViaCacheFromJS(input.Get("updateViaCache"))
	out.UpdateViaCache = value2
	return &out
}

// dictionary: SyncEventInit
type SyncEventInit struct {
	Bubbles    bool
	Cancelable bool
	Composed   bool
	Tag        string
	LastChance bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *SyncEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Tag
	out.Set("tag", value3)
	value4 := _this.LastChance
	out.Set("lastChance", value4)
	return out
}

// SyncEventInitFromJS is allocating a new
// SyncEventInit object and copy all values from
// input javascript object
func SyncEventInitFromJS(value js.Wrapper) *SyncEventInit {
	input := value.JSValue()
	var out SyncEventInit
	var (
		value0 bool   // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool   // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool   // javascript: boolean {composed Composed composed}
		value3 string // javascript: DOMString {tag Tag tag}
		value4 bool   // javascript: boolean {lastChance LastChance lastChance}
	)
	value0 = (input.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (input.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (input.Get("composed")).Bool()
	out.Composed = value2
	value3 = (input.Get("tag")).String()
	out.Tag = value3
	value4 = (input.Get("lastChance")).Bool()
	out.LastChance = value4
	return &out
}

// interface: BackgroundFetchEvent
type BackgroundFetchEvent struct {
	domcore.ExtendableEvent
}

// BackgroundFetchEventFromJS is casting a js.Wrapper into BackgroundFetchEvent.
func BackgroundFetchEventFromJS(value js.Wrapper) *BackgroundFetchEvent {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &BackgroundFetchEvent{}
	ret.Value_JS = input
	return ret
}

func NewBackgroundFetchEvent(_type string, init *BackgroundFetchEventInit) (_result *BackgroundFetchEvent) {
	_klass := js.Global().Get("BackgroundFetchEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := init.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *BackgroundFetchEvent // javascript: BackgroundFetchEvent _what_return_name
	)
	_converted = BackgroundFetchEventFromJS(_returned)
	_result = _converted
	return
}

// Registration returning attribute 'registration' with
// type BackgroundFetchRegistration (idl: BackgroundFetchRegistration).
func (_this *BackgroundFetchEvent) Registration() *BackgroundFetchRegistration {
	var ret *BackgroundFetchRegistration
	value := _this.Value_JS.Get("registration")
	ret = BackgroundFetchRegistrationFromJS(value)
	return ret
}

// interface: BackgroundFetchManager
type BackgroundFetchManager struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *BackgroundFetchManager) JSValue() js.Value {
	return _this.Value_JS
}

// BackgroundFetchManagerFromJS is casting a js.Wrapper into BackgroundFetchManager.
func BackgroundFetchManagerFromJS(value js.Wrapper) *BackgroundFetchManager {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &BackgroundFetchManager{}
	ret.Value_JS = input
	return ret
}

func (_this *BackgroundFetchManager) Fetch(id string, requests *Union, options *BackgroundFetchOptions) (_result *javascript.Promise) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := id
	_args[0] = _p0
	_end++
	_p1 := requests.JSValue()
	_args[1] = _p1
	_end++
	if options != nil {
		_p2 := options.JSValue()
		_args[2] = _p2
		_end++
	}
	_returned := _this.Value_JS.Call("fetch", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *BackgroundFetchManager) Get(id string) (_result *javascript.Promise) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := id
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("get", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *BackgroundFetchManager) GetIds() (_result *javascript.Promise) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getIds", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

// interface: BackgroundFetchRecord
type BackgroundFetchRecord struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *BackgroundFetchRecord) JSValue() js.Value {
	return _this.Value_JS
}

// BackgroundFetchRecordFromJS is casting a js.Wrapper into BackgroundFetchRecord.
func BackgroundFetchRecordFromJS(value js.Wrapper) *BackgroundFetchRecord {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &BackgroundFetchRecord{}
	ret.Value_JS = input
	return ret
}

// Request returning attribute 'request' with
// type fetch.Request (idl: Request).
func (_this *BackgroundFetchRecord) Request() *fetch.Request {
	var ret *fetch.Request
	value := _this.Value_JS.Get("request")
	ret = fetch.RequestFromJS(value)
	return ret
}

// ResponseReady returning attribute 'responseReady' with
// type javascript.Promise (idl: Promise).
func (_this *BackgroundFetchRecord) ResponseReady() *javascript.Promise {
	var ret *javascript.Promise
	value := _this.Value_JS.Get("responseReady")
	ret = javascript.PromiseFromJS(value)
	return ret
}

// interface: BackgroundFetchRegistration
type BackgroundFetchRegistration struct {
	domcore.EventTarget
}

// BackgroundFetchRegistrationFromJS is casting a js.Wrapper into BackgroundFetchRegistration.
func BackgroundFetchRegistrationFromJS(value js.Wrapper) *BackgroundFetchRegistration {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &BackgroundFetchRegistration{}
	ret.Value_JS = input
	return ret
}

// Id returning attribute 'id' with
// type string (idl: DOMString).
func (_this *BackgroundFetchRegistration) Id() string {
	var ret string
	value := _this.Value_JS.Get("id")
	ret = (value).String()
	return ret
}

// UploadTotal returning attribute 'uploadTotal' with
// type int (idl: unsigned long long).
func (_this *BackgroundFetchRegistration) UploadTotal() int {
	var ret int
	value := _this.Value_JS.Get("uploadTotal")
	ret = (value).Int()
	return ret
}

// Uploaded returning attribute 'uploaded' with
// type int (idl: unsigned long long).
func (_this *BackgroundFetchRegistration) Uploaded() int {
	var ret int
	value := _this.Value_JS.Get("uploaded")
	ret = (value).Int()
	return ret
}

// DownloadTotal returning attribute 'downloadTotal' with
// type int (idl: unsigned long long).
func (_this *BackgroundFetchRegistration) DownloadTotal() int {
	var ret int
	value := _this.Value_JS.Get("downloadTotal")
	ret = (value).Int()
	return ret
}

// Downloaded returning attribute 'downloaded' with
// type int (idl: unsigned long long).
func (_this *BackgroundFetchRegistration) Downloaded() int {
	var ret int
	value := _this.Value_JS.Get("downloaded")
	ret = (value).Int()
	return ret
}

// Result returning attribute 'result' with
// type BackgroundFetchResult (idl: BackgroundFetchResult).
func (_this *BackgroundFetchRegistration) Result() BackgroundFetchResult {
	var ret BackgroundFetchResult
	value := _this.Value_JS.Get("result")
	ret = BackgroundFetchResultFromJS(value)
	return ret
}

// FailureReason returning attribute 'failureReason' with
// type BackgroundFetchFailureReason (idl: BackgroundFetchFailureReason).
func (_this *BackgroundFetchRegistration) FailureReason() BackgroundFetchFailureReason {
	var ret BackgroundFetchFailureReason
	value := _this.Value_JS.Get("failureReason")
	ret = BackgroundFetchFailureReasonFromJS(value)
	return ret
}

// RecordsAvailable returning attribute 'recordsAvailable' with
// type bool (idl: boolean).
func (_this *BackgroundFetchRegistration) RecordsAvailable() bool {
	var ret bool
	value := _this.Value_JS.Get("recordsAvailable")
	ret = (value).Bool()
	return ret
}

// Onprogress returning attribute 'onprogress' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *BackgroundFetchRegistration) Onprogress() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onprogress")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnprogress setting attribute 'onprogress' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *BackgroundFetchRegistration) SetOnprogress(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onprogress", input)
}

func (_this *BackgroundFetchRegistration) Abort() (_result *javascript.Promise) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("abort", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *BackgroundFetchRegistration) Match(request *Union, options *CacheQueryOptions) (_result *javascript.Promise) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := request.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("match", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *BackgroundFetchRegistration) MatchAll(request *Union, options *CacheQueryOptions) (_result *javascript.Promise) {
	var (
		_args [2]interface{}
		_end  int
	)
	if request != nil {
		_p0 := request.JSValue()
		_args[0] = _p0
		_end++
	}
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("matchAll", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

// interface: BackgroundFetchUpdateUIEvent
type BackgroundFetchUpdateUIEvent struct {
	BackgroundFetchEvent
}

// BackgroundFetchUpdateUIEventFromJS is casting a js.Wrapper into BackgroundFetchUpdateUIEvent.
func BackgroundFetchUpdateUIEventFromJS(value js.Wrapper) *BackgroundFetchUpdateUIEvent {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &BackgroundFetchUpdateUIEvent{}
	ret.Value_JS = input
	return ret
}

func NewBackgroundFetchUpdateUIEvent(_type string, init *BackgroundFetchEventInit) (_result *BackgroundFetchUpdateUIEvent) {
	_klass := js.Global().Get("BackgroundFetchUpdateUIEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := init.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *BackgroundFetchUpdateUIEvent // javascript: BackgroundFetchUpdateUIEvent _what_return_name
	)
	_converted = BackgroundFetchUpdateUIEventFromJS(_returned)
	_result = _converted
	return
}

func (_this *BackgroundFetchUpdateUIEvent) UpdateUI(options *BackgroundFetchUIOptions) (_result *javascript.Promise) {
	var (
		_args [1]interface{}
		_end  int
	)
	if options != nil {
		_p0 := options.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _this.Value_JS.Call("updateUI", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

// interface: Cache
type Cache struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Cache) JSValue() js.Value {
	return _this.Value_JS
}

// CacheFromJS is casting a js.Wrapper into Cache.
func CacheFromJS(value js.Wrapper) *Cache {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &Cache{}
	ret.Value_JS = input
	return ret
}

func (_this *Cache) Match(request *Union, options *CacheQueryOptions) (_result *javascript.Promise) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := request.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("match", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *Cache) MatchAll(request *Union, options *CacheQueryOptions) (_result *javascript.Promise) {
	var (
		_args [2]interface{}
		_end  int
	)
	if request != nil {
		_p0 := request.JSValue()
		_args[0] = _p0
		_end++
	}
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("matchAll", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *Cache) Add(request *Union) (_result *javascript.Promise) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := request.JSValue()
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("add", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *Cache) AddAll(requests []*Union) (_result *javascript.Promise) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := js.Global().Get("Array").New(len(requests))
	for __idx0, __seq_in0 := range requests {
		__seq_out0 := __seq_in0.JSValue()
		_p0.SetIndex(__idx0, __seq_out0)
	}
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("addAll", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *Cache) Put(request *Union, response *fetch.Response) (_result *javascript.Promise) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := request.JSValue()
	_args[0] = _p0
	_end++
	_p1 := response.JSValue()
	_args[1] = _p1
	_end++
	_returned := _this.Value_JS.Call("put", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *Cache) Delete(request *Union, options *CacheQueryOptions) (_result *javascript.Promise) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := request.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("delete", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *Cache) Keys(request *Union, options *CacheQueryOptions) (_result *javascript.Promise) {
	var (
		_args [2]interface{}
		_end  int
	)
	if request != nil {
		_p0 := request.JSValue()
		_args[0] = _p0
		_end++
	}
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("keys", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

// interface: CacheStorage
type CacheStorage struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *CacheStorage) JSValue() js.Value {
	return _this.Value_JS
}

// CacheStorageFromJS is casting a js.Wrapper into CacheStorage.
func CacheStorageFromJS(value js.Wrapper) *CacheStorage {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CacheStorage{}
	ret.Value_JS = input
	return ret
}

func (_this *CacheStorage) Match(request *Union, options *MultiCacheQueryOptions) (_result *javascript.Promise) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := request.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("match", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *CacheStorage) Has(cacheName string) (_result *javascript.Promise) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := cacheName
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("has", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *CacheStorage) Open(cacheName string) (_result *javascript.Promise) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := cacheName
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("open", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *CacheStorage) Delete(cacheName string) (_result *javascript.Promise) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := cacheName
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("delete", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *CacheStorage) Keys() (_result *javascript.Promise) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("keys", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

// interface: Client
type Client struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Client) JSValue() js.Value {
	return _this.Value_JS
}

// ClientFromJS is casting a js.Wrapper into Client.
func ClientFromJS(value js.Wrapper) *Client {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &Client{}
	ret.Value_JS = input
	return ret
}

// Url returning attribute 'url' with
// type string (idl: USVString).
func (_this *Client) Url() string {
	var ret string
	value := _this.Value_JS.Get("url")
	ret = (value).String()
	return ret
}

// FrameType returning attribute 'frameType' with
// type FrameType (idl: FrameType).
func (_this *Client) FrameType() FrameType {
	var ret FrameType
	value := _this.Value_JS.Get("frameType")
	ret = FrameTypeFromJS(value)
	return ret
}

// Id returning attribute 'id' with
// type string (idl: DOMString).
func (_this *Client) Id() string {
	var ret string
	value := _this.Value_JS.Get("id")
	ret = (value).String()
	return ret
}

// Type returning attribute 'type' with
// type ClientType (idl: ClientType).
func (_this *Client) Type() ClientType {
	var ret ClientType
	value := _this.Value_JS.Get("type")
	ret = ClientTypeFromJS(value)
	return ret
}

func (_this *Client) PostMessage(message interface{}, transfer []*javascript.Object) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := message
	_args[0] = _p0
	_end++
	if transfer != nil {
		_p1 := js.Global().Get("Array").New(len(transfer))
		for __idx1, __seq_in1 := range transfer {
			__seq_out1 := __seq_in1.JSValue()
			_p1.SetIndex(__idx1, __seq_out1)
		}
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("postMessage", _args[0:_end]...)
	return
}

// interface: Clients
type Clients struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Clients) JSValue() js.Value {
	return _this.Value_JS
}

// ClientsFromJS is casting a js.Wrapper into Clients.
func ClientsFromJS(value js.Wrapper) *Clients {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &Clients{}
	ret.Value_JS = input
	return ret
}

func (_this *Clients) Get(id string) (_result *javascript.Promise) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := id
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("get", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *Clients) MatchAll(options *ClientQueryOptions) (_result *javascript.Promise) {
	var (
		_args [1]interface{}
		_end  int
	)
	if options != nil {
		_p0 := options.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _this.Value_JS.Call("matchAll", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *Clients) OpenWindow(url string) (_result *javascript.Promise) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := url
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("openWindow", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *Clients) Claim() (_result *javascript.Promise) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("claim", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

// interface: ExtendableMessageEvent
type ExtendableMessageEvent struct {
	domcore.ExtendableEvent
}

// ExtendableMessageEventFromJS is casting a js.Wrapper into ExtendableMessageEvent.
func ExtendableMessageEventFromJS(value js.Wrapper) *ExtendableMessageEvent {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &ExtendableMessageEvent{}
	ret.Value_JS = input
	return ret
}

func NewExtendableMessageEvent(_type string, eventInitDict *ExtendableMessageEventInit) (_result *ExtendableMessageEvent) {
	_klass := js.Global().Get("ExtendableMessageEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	if eventInitDict != nil {
		_p1 := eventInitDict.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *ExtendableMessageEvent // javascript: ExtendableMessageEvent _what_return_name
	)
	_converted = ExtendableMessageEventFromJS(_returned)
	_result = _converted
	return
}

// Data returning attribute 'data' with
// type Any (idl: any).
func (_this *ExtendableMessageEvent) Data() js.Value {
	var ret js.Value
	value := _this.Value_JS.Get("data")
	ret = value
	return ret
}

// Origin returning attribute 'origin' with
// type string (idl: USVString).
func (_this *ExtendableMessageEvent) Origin() string {
	var ret string
	value := _this.Value_JS.Get("origin")
	ret = (value).String()
	return ret
}

// LastEventId returning attribute 'lastEventId' with
// type string (idl: DOMString).
func (_this *ExtendableMessageEvent) LastEventId() string {
	var ret string
	value := _this.Value_JS.Get("lastEventId")
	ret = (value).String()
	return ret
}

// Source returning attribute 'source' with
// type Union (idl: Union).
func (_this *ExtendableMessageEvent) Source() *Union {
	var ret *Union
	value := _this.Value_JS.Get("source")
	if value.Type() != js.TypeNull {
		ret = UnionFromJS(value)
	}
	return ret
}

// Ports returning attribute 'ports' with
// type javascript.FrozenArray (idl: FrozenArray).
func (_this *ExtendableMessageEvent) Ports() *javascript.FrozenArray {
	var ret *javascript.FrozenArray
	value := _this.Value_JS.Get("ports")
	ret = javascript.FrozenArrayFromJS(value)
	return ret
}

// interface: FetchEvent
type FetchEvent struct {
	domcore.ExtendableEvent
}

// FetchEventFromJS is casting a js.Wrapper into FetchEvent.
func FetchEventFromJS(value js.Wrapper) *FetchEvent {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &FetchEvent{}
	ret.Value_JS = input
	return ret
}

func NewFetchEvent(_type string, eventInitDict *FetchEventInit) (_result *FetchEvent) {
	_klass := js.Global().Get("FetchEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := eventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *FetchEvent // javascript: FetchEvent _what_return_name
	)
	_converted = FetchEventFromJS(_returned)
	_result = _converted
	return
}

// Request returning attribute 'request' with
// type fetch.Request (idl: Request).
func (_this *FetchEvent) Request() *fetch.Request {
	var ret *fetch.Request
	value := _this.Value_JS.Get("request")
	ret = fetch.RequestFromJS(value)
	return ret
}

// ClientId returning attribute 'clientId' with
// type string (idl: DOMString).
func (_this *FetchEvent) ClientId() string {
	var ret string
	value := _this.Value_JS.Get("clientId")
	ret = (value).String()
	return ret
}

func (_this *FetchEvent) RespondWith(r *javascript.Promise) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := r.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("respondWith", _args[0:_end]...)
	return
}

// interface: ServiceWorker
type ServiceWorker struct {
	domcore.EventTarget
}

// ServiceWorkerFromJS is casting a js.Wrapper into ServiceWorker.
func ServiceWorkerFromJS(value js.Wrapper) *ServiceWorker {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &ServiceWorker{}
	ret.Value_JS = input
	return ret
}

// ScriptURL returning attribute 'scriptURL' with
// type string (idl: USVString).
func (_this *ServiceWorker) ScriptURL() string {
	var ret string
	value := _this.Value_JS.Get("scriptURL")
	ret = (value).String()
	return ret
}

// State returning attribute 'state' with
// type ServiceWorkerState (idl: ServiceWorkerState).
func (_this *ServiceWorker) State() ServiceWorkerState {
	var ret ServiceWorkerState
	value := _this.Value_JS.Get("state")
	ret = ServiceWorkerStateFromJS(value)
	return ret
}

// Onstatechange returning attribute 'onstatechange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ServiceWorker) Onstatechange() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onstatechange")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnstatechange setting attribute 'onstatechange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ServiceWorker) SetOnstatechange(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onstatechange", input)
}

// Onerror returning attribute 'onerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ServiceWorker) Onerror() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onerror")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnerror setting attribute 'onerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ServiceWorker) SetOnerror(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onerror", input)
}

func (_this *ServiceWorker) PostMessage(message interface{}, transfer []*javascript.Object) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := message
	_args[0] = _p0
	_end++
	if transfer != nil {
		_p1 := js.Global().Get("Array").New(len(transfer))
		for __idx1, __seq_in1 := range transfer {
			__seq_out1 := __seq_in1.JSValue()
			_p1.SetIndex(__idx1, __seq_out1)
		}
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("postMessage", _args[0:_end]...)
	return
}

// interface: ServiceWorkerContainer
type ServiceWorkerContainer struct {
	domcore.EventTarget
}

// ServiceWorkerContainerFromJS is casting a js.Wrapper into ServiceWorkerContainer.
func ServiceWorkerContainerFromJS(value js.Wrapper) *ServiceWorkerContainer {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &ServiceWorkerContainer{}
	ret.Value_JS = input
	return ret
}

// Controller returning attribute 'controller' with
// type ServiceWorker (idl: ServiceWorker).
func (_this *ServiceWorkerContainer) Controller() *ServiceWorker {
	var ret *ServiceWorker
	value := _this.Value_JS.Get("controller")
	if value.Type() != js.TypeNull {
		ret = ServiceWorkerFromJS(value)
	}
	return ret
}

// Ready returning attribute 'ready' with
// type javascript.Promise (idl: Promise).
func (_this *ServiceWorkerContainer) Ready() *javascript.Promise {
	var ret *javascript.Promise
	value := _this.Value_JS.Get("ready")
	ret = javascript.PromiseFromJS(value)
	return ret
}

// Oncontrollerchange returning attribute 'oncontrollerchange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ServiceWorkerContainer) Oncontrollerchange() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("oncontrollerchange")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOncontrollerchange setting attribute 'oncontrollerchange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ServiceWorkerContainer) SetOncontrollerchange(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("oncontrollerchange", input)
}

// Onmessage returning attribute 'onmessage' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ServiceWorkerContainer) Onmessage() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onmessage")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnmessage setting attribute 'onmessage' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ServiceWorkerContainer) SetOnmessage(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onmessage", input)
}

// Onmessageerror returning attribute 'onmessageerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ServiceWorkerContainer) Onmessageerror() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onmessageerror")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnmessageerror setting attribute 'onmessageerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ServiceWorkerContainer) SetOnmessageerror(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onmessageerror", input)
}

func (_this *ServiceWorkerContainer) Register(scriptURL string, options *RegistrationOptions) (_result *javascript.Promise) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := scriptURL
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("register", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *ServiceWorkerContainer) GetRegistration(clientURL *string) (_result *javascript.Promise) {
	var (
		_args [1]interface{}
		_end  int
	)
	if clientURL != nil {
		_p0 := clientURL
		_args[0] = _p0
		_end++
	}
	_returned := _this.Value_JS.Call("getRegistration", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *ServiceWorkerContainer) GetRegistrations() (_result *javascript.Promise) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getRegistrations", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *ServiceWorkerContainer) StartMessages() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("startMessages", _args[0:_end]...)
	return
}

// interface: ServiceWorkerRegistration
type ServiceWorkerRegistration struct {
	domcore.EventTarget
}

// ServiceWorkerRegistrationFromJS is casting a js.Wrapper into ServiceWorkerRegistration.
func ServiceWorkerRegistrationFromJS(value js.Wrapper) *ServiceWorkerRegistration {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &ServiceWorkerRegistration{}
	ret.Value_JS = input
	return ret
}

// Installing returning attribute 'installing' with
// type ServiceWorker (idl: ServiceWorker).
func (_this *ServiceWorkerRegistration) Installing() *ServiceWorker {
	var ret *ServiceWorker
	value := _this.Value_JS.Get("installing")
	if value.Type() != js.TypeNull {
		ret = ServiceWorkerFromJS(value)
	}
	return ret
}

// Waiting returning attribute 'waiting' with
// type ServiceWorker (idl: ServiceWorker).
func (_this *ServiceWorkerRegistration) Waiting() *ServiceWorker {
	var ret *ServiceWorker
	value := _this.Value_JS.Get("waiting")
	if value.Type() != js.TypeNull {
		ret = ServiceWorkerFromJS(value)
	}
	return ret
}

// Active returning attribute 'active' with
// type ServiceWorker (idl: ServiceWorker).
func (_this *ServiceWorkerRegistration) Active() *ServiceWorker {
	var ret *ServiceWorker
	value := _this.Value_JS.Get("active")
	if value.Type() != js.TypeNull {
		ret = ServiceWorkerFromJS(value)
	}
	return ret
}

// Scope returning attribute 'scope' with
// type string (idl: USVString).
func (_this *ServiceWorkerRegistration) Scope() string {
	var ret string
	value := _this.Value_JS.Get("scope")
	ret = (value).String()
	return ret
}

// UpdateViaCache returning attribute 'updateViaCache' with
// type ServiceWorkerUpdateViaCache (idl: ServiceWorkerUpdateViaCache).
func (_this *ServiceWorkerRegistration) UpdateViaCache() ServiceWorkerUpdateViaCache {
	var ret ServiceWorkerUpdateViaCache
	value := _this.Value_JS.Get("updateViaCache")
	ret = ServiceWorkerUpdateViaCacheFromJS(value)
	return ret
}

// Onupdatefound returning attribute 'onupdatefound' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ServiceWorkerRegistration) Onupdatefound() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onupdatefound")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnupdatefound setting attribute 'onupdatefound' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ServiceWorkerRegistration) SetOnupdatefound(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onupdatefound", input)
}

// Sync returning attribute 'sync' with
// type SyncManager (idl: SyncManager).
func (_this *ServiceWorkerRegistration) Sync() *SyncManager {
	var ret *SyncManager
	value := _this.Value_JS.Get("sync")
	ret = SyncManagerFromJS(value)
	return ret
}

// BackgroundFetch returning attribute 'backgroundFetch' with
// type BackgroundFetchManager (idl: BackgroundFetchManager).
func (_this *ServiceWorkerRegistration) BackgroundFetch() *BackgroundFetchManager {
	var ret *BackgroundFetchManager
	value := _this.Value_JS.Get("backgroundFetch")
	ret = BackgroundFetchManagerFromJS(value)
	return ret
}

// PaymentManager returning attribute 'paymentManager' with
// type payment.PaymentManager (idl: PaymentManager).
func (_this *ServiceWorkerRegistration) PaymentManager() *payment.PaymentManager {
	var ret *payment.PaymentManager
	value := _this.Value_JS.Get("paymentManager")
	ret = payment.PaymentManagerFromJS(value)
	return ret
}

func (_this *ServiceWorkerRegistration) Update() (_result *javascript.Promise) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("update", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *ServiceWorkerRegistration) Unregister() (_result *javascript.Promise) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("unregister", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

// interface: SyncEvent
type SyncEvent struct {
	domcore.ExtendableEvent
}

// SyncEventFromJS is casting a js.Wrapper into SyncEvent.
func SyncEventFromJS(value js.Wrapper) *SyncEvent {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &SyncEvent{}
	ret.Value_JS = input
	return ret
}

func NewSyncEvent(_type string, init *SyncEventInit) (_result *SyncEvent) {
	_klass := js.Global().Get("SyncEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := init.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SyncEvent // javascript: SyncEvent _what_return_name
	)
	_converted = SyncEventFromJS(_returned)
	_result = _converted
	return
}

// Tag returning attribute 'tag' with
// type string (idl: DOMString).
func (_this *SyncEvent) Tag() string {
	var ret string
	value := _this.Value_JS.Get("tag")
	ret = (value).String()
	return ret
}

// LastChance returning attribute 'lastChance' with
// type bool (idl: boolean).
func (_this *SyncEvent) LastChance() bool {
	var ret bool
	value := _this.Value_JS.Get("lastChance")
	ret = (value).Bool()
	return ret
}

// interface: SyncManager
type SyncManager struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *SyncManager) JSValue() js.Value {
	return _this.Value_JS
}

// SyncManagerFromJS is casting a js.Wrapper into SyncManager.
func SyncManagerFromJS(value js.Wrapper) *SyncManager {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &SyncManager{}
	ret.Value_JS = input
	return ret
}

func (_this *SyncManager) Register(tag string) (_result *javascript.Promise) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := tag
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("register", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *SyncManager) GetTags() (_result *javascript.Promise) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getTags", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

// interface: WindowClient
type WindowClient struct {
	Client
}

// WindowClientFromJS is casting a js.Wrapper into WindowClient.
func WindowClientFromJS(value js.Wrapper) *WindowClient {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &WindowClient{}
	ret.Value_JS = input
	return ret
}

// VisibilityState returning attribute 'visibilityState' with
// type domcore.VisibilityState (idl: VisibilityState).
func (_this *WindowClient) VisibilityState() domcore.VisibilityState {
	var ret domcore.VisibilityState
	value := _this.Value_JS.Get("visibilityState")
	ret = domcore.VisibilityStateFromJS(value)
	return ret
}

// Focused returning attribute 'focused' with
// type bool (idl: boolean).
func (_this *WindowClient) Focused() bool {
	var ret bool
	value := _this.Value_JS.Get("focused")
	ret = (value).Bool()
	return ret
}

// AncestorOrigins returning attribute 'ancestorOrigins' with
// type javascript.FrozenArray (idl: FrozenArray).
func (_this *WindowClient) AncestorOrigins() *javascript.FrozenArray {
	var ret *javascript.FrozenArray
	value := _this.Value_JS.Get("ancestorOrigins")
	ret = javascript.FrozenArrayFromJS(value)
	return ret
}

func (_this *WindowClient) Focus() (_result *javascript.Promise) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("focus", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *WindowClient) Navigate(url string) (_result *javascript.Promise) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := url
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("navigate", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}
