// Code generated by webidl-bind. DO NOT EDIT.

// +build !js

package typedom

import js "github.com/gowebapi/webapi/core/js"

import (
	"github.com/gowebapi/webapi/dom/geometry"
)

// using following types:
// geometry.DOMMatrix
// geometry.DOMMatrixReadOnly

// source idl files:
// css-typed-om.idl

// transform files:
// css-typed-om.go.md

// ReleasableApiResource is used to release underlaying
// allocated resources.
type ReleasableApiResource interface {
	Release()
}

type releasableApiResourceList []ReleasableApiResource

func (a releasableApiResourceList) Release() {
	for _, v := range a {
		v.Release()
	}
}

// workaround for compiler error
func unused(value interface{}) {
	// TODO remove this method
}

type Union struct {
	Value js.Value
}

func (u *Union) JSValue() js.Value {
	return u.Value
}

func UnionFromJS(value js.Value) *Union {
	return &Union{Value: value}
}

// enum: CSSMathOperator
type CSSMathOperator int

const (
	SumCSSMathOperator CSSMathOperator = iota
	ProductCSSMathOperator
	NegateCSSMathOperator
	InvertCSSMathOperator
	MinCSSMathOperator
	MaxCSSMathOperator
	ClampCSSMathOperator
)

var cSSMathOperatorToWasmTable = []string{
	"sum", "product", "negate", "invert", "min", "max", "clamp",
}

var cSSMathOperatorFromWasmTable = map[string]CSSMathOperator{
	"sum": SumCSSMathOperator, "product": ProductCSSMathOperator, "negate": NegateCSSMathOperator, "invert": InvertCSSMathOperator, "min": MinCSSMathOperator, "max": MaxCSSMathOperator, "clamp": ClampCSSMathOperator,
}

// JSValue is converting this enum into a java object
func (this *CSSMathOperator) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this CSSMathOperator) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(cSSMathOperatorToWasmTable) {
		return cSSMathOperatorToWasmTable[idx]
	}
	panic("unknown input value")
}

// CSSMathOperatorFromJS is converting a javascript value into
// a CSSMathOperator enum value.
func CSSMathOperatorFromJS(value js.Value) CSSMathOperator {
	key := value.String()
	conv, ok := cSSMathOperatorFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: CSSNumericBaseType
type CSSNumericBaseType int

const (
	LengthCSSNumericBaseType CSSNumericBaseType = iota
	AngleCSSNumericBaseType
	TimeCSSNumericBaseType
	FrequencyCSSNumericBaseType
	ResolutionCSSNumericBaseType
	FlexCSSNumericBaseType
	PercentCSSNumericBaseType
)

var cSSNumericBaseTypeToWasmTable = []string{
	"length", "angle", "time", "frequency", "resolution", "flex", "percent",
}

var cSSNumericBaseTypeFromWasmTable = map[string]CSSNumericBaseType{
	"length": LengthCSSNumericBaseType, "angle": AngleCSSNumericBaseType, "time": TimeCSSNumericBaseType, "frequency": FrequencyCSSNumericBaseType, "resolution": ResolutionCSSNumericBaseType, "flex": FlexCSSNumericBaseType, "percent": PercentCSSNumericBaseType,
}

// JSValue is converting this enum into a java object
func (this *CSSNumericBaseType) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this CSSNumericBaseType) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(cSSNumericBaseTypeToWasmTable) {
		return cSSNumericBaseTypeToWasmTable[idx]
	}
	panic("unknown input value")
}

// CSSNumericBaseTypeFromJS is converting a javascript value into
// a CSSNumericBaseType enum value.
func CSSNumericBaseTypeFromJS(value js.Value) CSSNumericBaseType {
	key := value.String()
	conv, ok := cSSNumericBaseTypeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// dictionary: CSSMatrixComponentOptions
type CSSMatrixComponentOptions struct {
	Is2D bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *CSSMatrixComponentOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Is2D
	out.Set("is2D", value0)
	return out
}

// CSSMatrixComponentOptionsFromJS is allocating a new
// CSSMatrixComponentOptions object and copy all values from
// input javascript object
func CSSMatrixComponentOptionsFromJS(value js.Wrapper) *CSSMatrixComponentOptions {
	input := value.JSValue()
	var out CSSMatrixComponentOptions
	var (
		value0 bool // javascript: boolean {is2D Is2D is2D}
	)
	value0 = (input.Get("is2D")).Bool()
	out.Is2D = value0
	return &out
}

// dictionary: CSSNumericType
type CSSNumericType struct {
	Length      int
	Angle       int
	Time        int
	Frequency   int
	Resolution  int
	Flex        int
	Percent     int
	PercentHint CSSNumericBaseType
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *CSSNumericType) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Length
	out.Set("length", value0)
	value1 := _this.Angle
	out.Set("angle", value1)
	value2 := _this.Time
	out.Set("time", value2)
	value3 := _this.Frequency
	out.Set("frequency", value3)
	value4 := _this.Resolution
	out.Set("resolution", value4)
	value5 := _this.Flex
	out.Set("flex", value5)
	value6 := _this.Percent
	out.Set("percent", value6)
	value7 := _this.PercentHint.JSValue()
	out.Set("percentHint", value7)
	return out
}

// CSSNumericTypeFromJS is allocating a new
// CSSNumericType object and copy all values from
// input javascript object
func CSSNumericTypeFromJS(value js.Wrapper) *CSSNumericType {
	input := value.JSValue()
	var out CSSNumericType
	var (
		value0 int                // javascript: long {length Length length}
		value1 int                // javascript: long {angle Angle angle}
		value2 int                // javascript: long {time Time time}
		value3 int                // javascript: long {frequency Frequency frequency}
		value4 int                // javascript: long {resolution Resolution resolution}
		value5 int                // javascript: long {flex Flex flex}
		value6 int                // javascript: long {percent Percent percent}
		value7 CSSNumericBaseType // javascript: CSSNumericBaseType {percentHint PercentHint percentHint}
	)
	value0 = (input.Get("length")).Int()
	out.Length = value0
	value1 = (input.Get("angle")).Int()
	out.Angle = value1
	value2 = (input.Get("time")).Int()
	out.Time = value2
	value3 = (input.Get("frequency")).Int()
	out.Frequency = value3
	value4 = (input.Get("resolution")).Int()
	out.Resolution = value4
	value5 = (input.Get("flex")).Int()
	out.Flex = value5
	value6 = (input.Get("percent")).Int()
	out.Percent = value6
	value7 = CSSNumericBaseTypeFromJS(input.Get("percentHint"))
	out.PercentHint = value7
	return &out
}

// interface: CSSImageValue
type CSSImageValue struct {
	CSSStyleValue
}

// CSSImageValueFromJS is casting a js.Wrapper into CSSImageValue.
func CSSImageValueFromJS(value js.Wrapper) *CSSImageValue {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSImageValue{}
	ret.Value_JS = input
	return ret
}

// interface: CSSKeywordValue
type CSSKeywordValue struct {
	CSSStyleValue
}

// CSSKeywordValueFromJS is casting a js.Wrapper into CSSKeywordValue.
func CSSKeywordValueFromJS(value js.Wrapper) *CSSKeywordValue {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSKeywordValue{}
	ret.Value_JS = input
	return ret
}

func NewCSSKeywordValue(value string) (_result *CSSKeywordValue) {
	_klass := js.Global().Get("CSSKeywordValue")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := value
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSKeywordValue // javascript: CSSKeywordValue _what_return_name
	)
	_converted = CSSKeywordValueFromJS(_returned)
	_result = _converted
	return
}

// Value returning attribute 'value' with
// type string (idl: USVString).
func (_this *CSSKeywordValue) Value() string {
	var ret string
	value := _this.Value_JS.Get("value")
	ret = (value).String()
	return ret
}

// SetValue setting attribute 'value' with
// type string (idl: USVString).
func (_this *CSSKeywordValue) SetValue(value string) {
	input := value
	_this.Value_JS.Set("value", input)
}

// interface: CSSMathClamp
type CSSMathClamp struct {
	CSSMathValue
}

// CSSMathClampFromJS is casting a js.Wrapper into CSSMathClamp.
func CSSMathClampFromJS(value js.Wrapper) *CSSMathClamp {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSMathClamp{}
	ret.Value_JS = input
	return ret
}

func NewCSSMathClamp(min *Union, val *Union, max *Union) (_result *CSSMathClamp) {
	_klass := js.Global().Get("CSSMathClamp")
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := min.JSValue()
	_args[0] = _p0
	_end++
	_p1 := val.JSValue()
	_args[1] = _p1
	_end++
	_p2 := max.JSValue()
	_args[2] = _p2
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSMathClamp // javascript: CSSMathClamp _what_return_name
	)
	_converted = CSSMathClampFromJS(_returned)
	_result = _converted
	return
}

// Min returning attribute 'min' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSMathClamp) Min() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("min")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// Val returning attribute 'val' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSMathClamp) Val() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("val")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// Max returning attribute 'max' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSMathClamp) Max() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("max")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// interface: CSSMathInvert
type CSSMathInvert struct {
	CSSMathValue
}

// CSSMathInvertFromJS is casting a js.Wrapper into CSSMathInvert.
func CSSMathInvertFromJS(value js.Wrapper) *CSSMathInvert {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSMathInvert{}
	ret.Value_JS = input
	return ret
}

func NewCSSMathInvert(arg *Union) (_result *CSSMathInvert) {
	_klass := js.Global().Get("CSSMathInvert")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := arg.JSValue()
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSMathInvert // javascript: CSSMathInvert _what_return_name
	)
	_converted = CSSMathInvertFromJS(_returned)
	_result = _converted
	return
}

// Value returning attribute 'value' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSMathInvert) Value() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("value")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// interface: CSSMathMax
type CSSMathMax struct {
	CSSMathValue
}

// CSSMathMaxFromJS is casting a js.Wrapper into CSSMathMax.
func CSSMathMaxFromJS(value js.Wrapper) *CSSMathMax {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSMathMax{}
	ret.Value_JS = input
	return ret
}

func NewCSSMathMax(args ...*Union) (_result *CSSMathMax) {
	_klass := js.Global().Get("CSSMathMax")
	var (
		_args []interface{} = make([]interface{}, 0+len(args))
		_end  int
	)
	for _, __in := range args {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSMathMax // javascript: CSSMathMax _what_return_name
	)
	_converted = CSSMathMaxFromJS(_returned)
	_result = _converted
	return
}

// Values returning attribute 'values' with
// type CSSNumericArray (idl: CSSNumericArray).
func (_this *CSSMathMax) Values() *CSSNumericArray {
	var ret *CSSNumericArray
	value := _this.Value_JS.Get("values")
	ret = CSSNumericArrayFromJS(value)
	return ret
}

// interface: CSSMathMin
type CSSMathMin struct {
	CSSMathValue
}

// CSSMathMinFromJS is casting a js.Wrapper into CSSMathMin.
func CSSMathMinFromJS(value js.Wrapper) *CSSMathMin {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSMathMin{}
	ret.Value_JS = input
	return ret
}

func NewCSSMathMin(args ...*Union) (_result *CSSMathMin) {
	_klass := js.Global().Get("CSSMathMin")
	var (
		_args []interface{} = make([]interface{}, 0+len(args))
		_end  int
	)
	for _, __in := range args {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSMathMin // javascript: CSSMathMin _what_return_name
	)
	_converted = CSSMathMinFromJS(_returned)
	_result = _converted
	return
}

// Values returning attribute 'values' with
// type CSSNumericArray (idl: CSSNumericArray).
func (_this *CSSMathMin) Values() *CSSNumericArray {
	var ret *CSSNumericArray
	value := _this.Value_JS.Get("values")
	ret = CSSNumericArrayFromJS(value)
	return ret
}

// interface: CSSMathNegate
type CSSMathNegate struct {
	CSSMathValue
}

// CSSMathNegateFromJS is casting a js.Wrapper into CSSMathNegate.
func CSSMathNegateFromJS(value js.Wrapper) *CSSMathNegate {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSMathNegate{}
	ret.Value_JS = input
	return ret
}

func NewCSSMathNegate(arg *Union) (_result *CSSMathNegate) {
	_klass := js.Global().Get("CSSMathNegate")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := arg.JSValue()
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSMathNegate // javascript: CSSMathNegate _what_return_name
	)
	_converted = CSSMathNegateFromJS(_returned)
	_result = _converted
	return
}

// Value returning attribute 'value' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSMathNegate) Value() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("value")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// interface: CSSMathProduct
type CSSMathProduct struct {
	CSSMathValue
}

// CSSMathProductFromJS is casting a js.Wrapper into CSSMathProduct.
func CSSMathProductFromJS(value js.Wrapper) *CSSMathProduct {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSMathProduct{}
	ret.Value_JS = input
	return ret
}

func NewCSSMathProduct(args ...*Union) (_result *CSSMathProduct) {
	_klass := js.Global().Get("CSSMathProduct")
	var (
		_args []interface{} = make([]interface{}, 0+len(args))
		_end  int
	)
	for _, __in := range args {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSMathProduct // javascript: CSSMathProduct _what_return_name
	)
	_converted = CSSMathProductFromJS(_returned)
	_result = _converted
	return
}

// Values returning attribute 'values' with
// type CSSNumericArray (idl: CSSNumericArray).
func (_this *CSSMathProduct) Values() *CSSNumericArray {
	var ret *CSSNumericArray
	value := _this.Value_JS.Get("values")
	ret = CSSNumericArrayFromJS(value)
	return ret
}

// interface: CSSMathSum
type CSSMathSum struct {
	CSSMathValue
}

// CSSMathSumFromJS is casting a js.Wrapper into CSSMathSum.
func CSSMathSumFromJS(value js.Wrapper) *CSSMathSum {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSMathSum{}
	ret.Value_JS = input
	return ret
}

func NewCSSMathSum(args ...*Union) (_result *CSSMathSum) {
	_klass := js.Global().Get("CSSMathSum")
	var (
		_args []interface{} = make([]interface{}, 0+len(args))
		_end  int
	)
	for _, __in := range args {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSMathSum // javascript: CSSMathSum _what_return_name
	)
	_converted = CSSMathSumFromJS(_returned)
	_result = _converted
	return
}

// Values returning attribute 'values' with
// type CSSNumericArray (idl: CSSNumericArray).
func (_this *CSSMathSum) Values() *CSSNumericArray {
	var ret *CSSNumericArray
	value := _this.Value_JS.Get("values")
	ret = CSSNumericArrayFromJS(value)
	return ret
}

// interface: CSSMathValue
type CSSMathValue struct {
	CSSNumericValue
}

// CSSMathValueFromJS is casting a js.Wrapper into CSSMathValue.
func CSSMathValueFromJS(value js.Wrapper) *CSSMathValue {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSMathValue{}
	ret.Value_JS = input
	return ret
}

// Operator returning attribute 'operator' with
// type CSSMathOperator (idl: CSSMathOperator).
func (_this *CSSMathValue) Operator() CSSMathOperator {
	var ret CSSMathOperator
	value := _this.Value_JS.Get("operator")
	ret = CSSMathOperatorFromJS(value)
	return ret
}

// interface: CSSMatrixComponent
type CSSMatrixComponent struct {
	CSSTransformComponent
}

// CSSMatrixComponentFromJS is casting a js.Wrapper into CSSMatrixComponent.
func CSSMatrixComponentFromJS(value js.Wrapper) *CSSMatrixComponent {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSMatrixComponent{}
	ret.Value_JS = input
	return ret
}

func NewCSSMatrixComponent(matrix *geometry.DOMMatrixReadOnly, options *CSSMatrixComponentOptions) (_result *CSSMatrixComponent) {
	_klass := js.Global().Get("CSSMatrixComponent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := matrix.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSMatrixComponent // javascript: CSSMatrixComponent _what_return_name
	)
	_converted = CSSMatrixComponentFromJS(_returned)
	_result = _converted
	return
}

// Matrix returning attribute 'matrix' with
// type geometry.DOMMatrix (idl: DOMMatrix).
func (_this *CSSMatrixComponent) Matrix() *geometry.DOMMatrix {
	var ret *geometry.DOMMatrix
	value := _this.Value_JS.Get("matrix")
	ret = geometry.DOMMatrixFromJS(value)
	return ret
}

// SetMatrix setting attribute 'matrix' with
// type geometry.DOMMatrix (idl: DOMMatrix).
func (_this *CSSMatrixComponent) SetMatrix(value *geometry.DOMMatrix) {
	input := value.JSValue()
	_this.Value_JS.Set("matrix", input)
}

// interface: CSSNumericArray
type CSSNumericArray struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *CSSNumericArray) JSValue() js.Value {
	return _this.Value_JS
}

// CSSNumericArrayFromJS is casting a js.Wrapper into CSSNumericArray.
func CSSNumericArrayFromJS(value js.Wrapper) *CSSNumericArray {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSNumericArray{}
	ret.Value_JS = input
	return ret
}

// Length returning attribute 'length' with
// type uint (idl: unsigned long).
func (_this *CSSNumericArray) Length() uint {
	var ret uint
	value := _this.Value_JS.Get("length")
	ret = (uint)((value).Int())
	return ret
}

// interface: CSSNumericValue
type CSSNumericValue struct {
	CSSStyleValue
}

// CSSNumericValueFromJS is casting a js.Wrapper into CSSNumericValue.
func CSSNumericValueFromJS(value js.Wrapper) *CSSNumericValue {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSNumericValue{}
	ret.Value_JS = input
	return ret
}

func Parse(cssText string) (_result *CSSNumericValue) {
	_klass := js.Global().Get("CSSNumericValue")
	_method := _klass.Get("parse")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := cssText
	_args[0] = _p0
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted *CSSNumericValue // javascript: CSSNumericValue _what_return_name
	)
	_converted = CSSNumericValueFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericValue) Add(values ...*Union) (_result *CSSNumericValue) {
	var (
		_args []interface{} = make([]interface{}, 0+len(values))
		_end  int
	)
	for _, __in := range values {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("add", _args[0:_end]...)
	var (
		_converted *CSSNumericValue // javascript: CSSNumericValue _what_return_name
	)
	_converted = CSSNumericValueFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericValue) Sub(values ...*Union) (_result *CSSNumericValue) {
	var (
		_args []interface{} = make([]interface{}, 0+len(values))
		_end  int
	)
	for _, __in := range values {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("sub", _args[0:_end]...)
	var (
		_converted *CSSNumericValue // javascript: CSSNumericValue _what_return_name
	)
	_converted = CSSNumericValueFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericValue) Mul(values ...*Union) (_result *CSSNumericValue) {
	var (
		_args []interface{} = make([]interface{}, 0+len(values))
		_end  int
	)
	for _, __in := range values {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("mul", _args[0:_end]...)
	var (
		_converted *CSSNumericValue // javascript: CSSNumericValue _what_return_name
	)
	_converted = CSSNumericValueFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericValue) Div(values ...*Union) (_result *CSSNumericValue) {
	var (
		_args []interface{} = make([]interface{}, 0+len(values))
		_end  int
	)
	for _, __in := range values {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("div", _args[0:_end]...)
	var (
		_converted *CSSNumericValue // javascript: CSSNumericValue _what_return_name
	)
	_converted = CSSNumericValueFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericValue) Min(values ...*Union) (_result *CSSNumericValue) {
	var (
		_args []interface{} = make([]interface{}, 0+len(values))
		_end  int
	)
	for _, __in := range values {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("min", _args[0:_end]...)
	var (
		_converted *CSSNumericValue // javascript: CSSNumericValue _what_return_name
	)
	_converted = CSSNumericValueFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericValue) Max(values ...*Union) (_result *CSSNumericValue) {
	var (
		_args []interface{} = make([]interface{}, 0+len(values))
		_end  int
	)
	for _, __in := range values {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("max", _args[0:_end]...)
	var (
		_converted *CSSNumericValue // javascript: CSSNumericValue _what_return_name
	)
	_converted = CSSNumericValueFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericValue) Equals(value ...*Union) (_result bool) {
	var (
		_args []interface{} = make([]interface{}, 0+len(value))
		_end  int
	)
	for _, __in := range value {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("equals", _args[0:_end]...)
	var (
		_converted bool // javascript: boolean _what_return_name
	)
	_converted = (_returned).Bool()
	_result = _converted
	return
}

func (_this *CSSNumericValue) To(unit string) (_result *CSSUnitValue) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := unit
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("to", _args[0:_end]...)
	var (
		_converted *CSSUnitValue // javascript: CSSUnitValue _what_return_name
	)
	_converted = CSSUnitValueFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericValue) ToSum(units ...string) (_result *CSSMathSum) {
	var (
		_args []interface{} = make([]interface{}, 0+len(units))
		_end  int
	)
	for _, __in := range units {
		__out := __in
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("toSum", _args[0:_end]...)
	var (
		_converted *CSSMathSum // javascript: CSSMathSum _what_return_name
	)
	_converted = CSSMathSumFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericValue) Type() (_result *CSSNumericType) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("type", _args[0:_end]...)
	var (
		_converted *CSSNumericType // javascript: CSSNumericType _what_return_name
	)
	_converted = CSSNumericTypeFromJS(_returned)
	_result = _converted
	return
}

// interface: CSSPerspective
type CSSPerspective struct {
	CSSTransformComponent
}

// CSSPerspectiveFromJS is casting a js.Wrapper into CSSPerspective.
func CSSPerspectiveFromJS(value js.Wrapper) *CSSPerspective {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSPerspective{}
	ret.Value_JS = input
	return ret
}

func NewCSSPerspective(length *CSSNumericValue) (_result *CSSPerspective) {
	_klass := js.Global().Get("CSSPerspective")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := length.JSValue()
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSPerspective // javascript: CSSPerspective _what_return_name
	)
	_converted = CSSPerspectiveFromJS(_returned)
	_result = _converted
	return
}

// Length returning attribute 'length' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSPerspective) Length() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("length")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// SetLength setting attribute 'length' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSPerspective) SetLength(value *CSSNumericValue) {
	input := value.JSValue()
	_this.Value_JS.Set("length", input)
}

// interface: CSSRotate
type CSSRotate struct {
	CSSTransformComponent
}

// CSSRotateFromJS is casting a js.Wrapper into CSSRotate.
func CSSRotateFromJS(value js.Wrapper) *CSSRotate {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSRotate{}
	ret.Value_JS = input
	return ret
}

func NewCSSRotate(x *Union, y *Union, z *Union, angle *CSSNumericValue) (_result *CSSRotate) {
	_klass := js.Global().Get("CSSRotate")
	var (
		_args [4]interface{}
		_end  int
	)
	_p0 := x.JSValue()
	_args[0] = _p0
	_end++
	_p1 := y.JSValue()
	_args[1] = _p1
	_end++
	_p2 := z.JSValue()
	_args[2] = _p2
	_end++
	_p3 := angle.JSValue()
	_args[3] = _p3
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSRotate // javascript: CSSRotate _what_return_name
	)
	_converted = CSSRotateFromJS(_returned)
	_result = _converted
	return
}

// X returning attribute 'x' with
// type Union (idl: Union).
func (_this *CSSRotate) X() *Union {
	var ret *Union
	value := _this.Value_JS.Get("x")
	ret = UnionFromJS(value)
	return ret
}

// SetX setting attribute 'x' with
// type Union (idl: Union).
func (_this *CSSRotate) SetX(value *Union) {
	input := value.JSValue()
	_this.Value_JS.Set("x", input)
}

// Y returning attribute 'y' with
// type Union (idl: Union).
func (_this *CSSRotate) Y() *Union {
	var ret *Union
	value := _this.Value_JS.Get("y")
	ret = UnionFromJS(value)
	return ret
}

// SetY setting attribute 'y' with
// type Union (idl: Union).
func (_this *CSSRotate) SetY(value *Union) {
	input := value.JSValue()
	_this.Value_JS.Set("y", input)
}

// Z returning attribute 'z' with
// type Union (idl: Union).
func (_this *CSSRotate) Z() *Union {
	var ret *Union
	value := _this.Value_JS.Get("z")
	ret = UnionFromJS(value)
	return ret
}

// SetZ setting attribute 'z' with
// type Union (idl: Union).
func (_this *CSSRotate) SetZ(value *Union) {
	input := value.JSValue()
	_this.Value_JS.Set("z", input)
}

// Angle returning attribute 'angle' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSRotate) Angle() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("angle")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// SetAngle setting attribute 'angle' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSRotate) SetAngle(value *CSSNumericValue) {
	input := value.JSValue()
	_this.Value_JS.Set("angle", input)
}

// interface: CSSScale
type CSSScale struct {
	CSSTransformComponent
}

// CSSScaleFromJS is casting a js.Wrapper into CSSScale.
func CSSScaleFromJS(value js.Wrapper) *CSSScale {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSScale{}
	ret.Value_JS = input
	return ret
}

func NewCSSScale(x *Union, y *Union, z *Union) (_result *CSSScale) {
	_klass := js.Global().Get("CSSScale")
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := x.JSValue()
	_args[0] = _p0
	_end++
	_p1 := y.JSValue()
	_args[1] = _p1
	_end++
	if z != nil {
		_p2 := z.JSValue()
		_args[2] = _p2
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSScale // javascript: CSSScale _what_return_name
	)
	_converted = CSSScaleFromJS(_returned)
	_result = _converted
	return
}

// X returning attribute 'x' with
// type Union (idl: Union).
func (_this *CSSScale) X() *Union {
	var ret *Union
	value := _this.Value_JS.Get("x")
	ret = UnionFromJS(value)
	return ret
}

// SetX setting attribute 'x' with
// type Union (idl: Union).
func (_this *CSSScale) SetX(value *Union) {
	input := value.JSValue()
	_this.Value_JS.Set("x", input)
}

// Y returning attribute 'y' with
// type Union (idl: Union).
func (_this *CSSScale) Y() *Union {
	var ret *Union
	value := _this.Value_JS.Get("y")
	ret = UnionFromJS(value)
	return ret
}

// SetY setting attribute 'y' with
// type Union (idl: Union).
func (_this *CSSScale) SetY(value *Union) {
	input := value.JSValue()
	_this.Value_JS.Set("y", input)
}

// Z returning attribute 'z' with
// type Union (idl: Union).
func (_this *CSSScale) Z() *Union {
	var ret *Union
	value := _this.Value_JS.Get("z")
	ret = UnionFromJS(value)
	return ret
}

// SetZ setting attribute 'z' with
// type Union (idl: Union).
func (_this *CSSScale) SetZ(value *Union) {
	input := value.JSValue()
	_this.Value_JS.Set("z", input)
}

// interface: CSSSkew
type CSSSkew struct {
	CSSTransformComponent
}

// CSSSkewFromJS is casting a js.Wrapper into CSSSkew.
func CSSSkewFromJS(value js.Wrapper) *CSSSkew {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSSkew{}
	ret.Value_JS = input
	return ret
}

func NewCSSSkew(ax *CSSNumericValue, ay *CSSNumericValue) (_result *CSSSkew) {
	_klass := js.Global().Get("CSSSkew")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := ax.JSValue()
	_args[0] = _p0
	_end++
	_p1 := ay.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSSkew // javascript: CSSSkew _what_return_name
	)
	_converted = CSSSkewFromJS(_returned)
	_result = _converted
	return
}

// Ax returning attribute 'ax' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSSkew) Ax() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("ax")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// SetAx setting attribute 'ax' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSSkew) SetAx(value *CSSNumericValue) {
	input := value.JSValue()
	_this.Value_JS.Set("ax", input)
}

// Ay returning attribute 'ay' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSSkew) Ay() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("ay")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// SetAy setting attribute 'ay' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSSkew) SetAy(value *CSSNumericValue) {
	input := value.JSValue()
	_this.Value_JS.Set("ay", input)
}

// interface: CSSSkewX
type CSSSkewX struct {
	CSSTransformComponent
}

// CSSSkewXFromJS is casting a js.Wrapper into CSSSkewX.
func CSSSkewXFromJS(value js.Wrapper) *CSSSkewX {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSSkewX{}
	ret.Value_JS = input
	return ret
}

func NewCSSSkewX(ax *CSSNumericValue) (_result *CSSSkewX) {
	_klass := js.Global().Get("CSSSkewX")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := ax.JSValue()
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSSkewX // javascript: CSSSkewX _what_return_name
	)
	_converted = CSSSkewXFromJS(_returned)
	_result = _converted
	return
}

// Ax returning attribute 'ax' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSSkewX) Ax() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("ax")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// SetAx setting attribute 'ax' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSSkewX) SetAx(value *CSSNumericValue) {
	input := value.JSValue()
	_this.Value_JS.Set("ax", input)
}

// interface: CSSSkewY
type CSSSkewY struct {
	CSSTransformComponent
}

// CSSSkewYFromJS is casting a js.Wrapper into CSSSkewY.
func CSSSkewYFromJS(value js.Wrapper) *CSSSkewY {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSSkewY{}
	ret.Value_JS = input
	return ret
}

func NewCSSSkewY(ay *CSSNumericValue) (_result *CSSSkewY) {
	_klass := js.Global().Get("CSSSkewY")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := ay.JSValue()
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSSkewY // javascript: CSSSkewY _what_return_name
	)
	_converted = CSSSkewYFromJS(_returned)
	_result = _converted
	return
}

// Ay returning attribute 'ay' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSSkewY) Ay() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("ay")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// SetAy setting attribute 'ay' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSSkewY) SetAy(value *CSSNumericValue) {
	input := value.JSValue()
	_this.Value_JS.Set("ay", input)
}

// interface: CSSStyleValue
type CSSStyleValue struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *CSSStyleValue) JSValue() js.Value {
	return _this.Value_JS
}

// CSSStyleValueFromJS is casting a js.Wrapper into CSSStyleValue.
func CSSStyleValueFromJS(value js.Wrapper) *CSSStyleValue {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSStyleValue{}
	ret.Value_JS = input
	return ret
}

func Parse2(property string, cssText string) (_result *CSSStyleValue) {
	_klass := js.Global().Get("CSSStyleValue")
	_method := _klass.Get("parse")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := property
	_args[0] = _p0
	_end++
	_p1 := cssText
	_args[1] = _p1
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted *CSSStyleValue // javascript: CSSStyleValue _what_return_name
	)
	_converted = CSSStyleValueFromJS(_returned)
	_result = _converted
	return
}

func ParseAll(property string, cssText string) (_result []*CSSStyleValue) {
	_klass := js.Global().Get("CSSStyleValue")
	_method := _klass.Get("parseAll")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := property
	_args[0] = _p0
	_end++
	_p1 := cssText
	_args[1] = _p1
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted []*CSSStyleValue // javascript: sequence<CSSStyleValue> _what_return_name
	)
	__length0 := _returned.Length()
	__array0 := make([]*CSSStyleValue, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *CSSStyleValue
		__seq_in0 := _returned.Index(__idx0)
		__seq_out0 = CSSStyleValueFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	_converted = __array0
	_result = _converted
	return
}

func (_this *CSSStyleValue) ToString() (_result string) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("toString", _args[0:_end]...)
	var (
		_converted string // javascript: DOMString _what_return_name
	)
	_converted = (_returned).String()
	_result = _converted
	return
}

// interface: CSSTransformComponent
type CSSTransformComponent struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *CSSTransformComponent) JSValue() js.Value {
	return _this.Value_JS
}

// CSSTransformComponentFromJS is casting a js.Wrapper into CSSTransformComponent.
func CSSTransformComponentFromJS(value js.Wrapper) *CSSTransformComponent {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSTransformComponent{}
	ret.Value_JS = input
	return ret
}

// Is2D returning attribute 'is2D' with
// type bool (idl: boolean).
func (_this *CSSTransformComponent) Is2D() bool {
	var ret bool
	value := _this.Value_JS.Get("is2D")
	ret = (value).Bool()
	return ret
}

// SetIs2D setting attribute 'is2D' with
// type bool (idl: boolean).
func (_this *CSSTransformComponent) SetIs2D(value bool) {
	input := value
	_this.Value_JS.Set("is2D", input)
}

func (_this *CSSTransformComponent) ToMatrix() (_result *geometry.DOMMatrix) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("toMatrix", _args[0:_end]...)
	var (
		_converted *geometry.DOMMatrix // javascript: DOMMatrix _what_return_name
	)
	_converted = geometry.DOMMatrixFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSTransformComponent) ToString() (_result string) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("toString", _args[0:_end]...)
	var (
		_converted string // javascript: DOMString _what_return_name
	)
	_converted = (_returned).String()
	_result = _converted
	return
}

// interface: CSSTransformValue
type CSSTransformValue struct {
	CSSStyleValue
}

// CSSTransformValueFromJS is casting a js.Wrapper into CSSTransformValue.
func CSSTransformValueFromJS(value js.Wrapper) *CSSTransformValue {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSTransformValue{}
	ret.Value_JS = input
	return ret
}

func NewCSSTransformValue(transforms []*CSSTransformComponent) (_result *CSSTransformValue) {
	_klass := js.Global().Get("CSSTransformValue")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := js.Global().Get("Array").New(len(transforms))
	for __idx0, __seq_in0 := range transforms {
		__seq_out0 := __seq_in0.JSValue()
		_p0.SetIndex(__idx0, __seq_out0)
	}
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSTransformValue // javascript: CSSTransformValue _what_return_name
	)
	_converted = CSSTransformValueFromJS(_returned)
	_result = _converted
	return
}

// Length returning attribute 'length' with
// type uint (idl: unsigned long).
func (_this *CSSTransformValue) Length() uint {
	var ret uint
	value := _this.Value_JS.Get("length")
	ret = (uint)((value).Int())
	return ret
}

// Is2D returning attribute 'is2D' with
// type bool (idl: boolean).
func (_this *CSSTransformValue) Is2D() bool {
	var ret bool
	value := _this.Value_JS.Get("is2D")
	ret = (value).Bool()
	return ret
}

func (_this *CSSTransformValue) ToMatrix() (_result *geometry.DOMMatrix) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("toMatrix", _args[0:_end]...)
	var (
		_converted *geometry.DOMMatrix // javascript: DOMMatrix _what_return_name
	)
	_converted = geometry.DOMMatrixFromJS(_returned)
	_result = _converted
	return
}

// interface: CSSTranslate
type CSSTranslate struct {
	CSSTransformComponent
}

// CSSTranslateFromJS is casting a js.Wrapper into CSSTranslate.
func CSSTranslateFromJS(value js.Wrapper) *CSSTranslate {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSTranslate{}
	ret.Value_JS = input
	return ret
}

func NewCSSTranslate(x *CSSNumericValue, y *CSSNumericValue, z *CSSNumericValue) (_result *CSSTranslate) {
	_klass := js.Global().Get("CSSTranslate")
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := x.JSValue()
	_args[0] = _p0
	_end++
	_p1 := y.JSValue()
	_args[1] = _p1
	_end++
	if z != nil {
		_p2 := z.JSValue()
		_args[2] = _p2
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSTranslate // javascript: CSSTranslate _what_return_name
	)
	_converted = CSSTranslateFromJS(_returned)
	_result = _converted
	return
}

// X returning attribute 'x' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSTranslate) X() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("x")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// SetX setting attribute 'x' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSTranslate) SetX(value *CSSNumericValue) {
	input := value.JSValue()
	_this.Value_JS.Set("x", input)
}

// Y returning attribute 'y' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSTranslate) Y() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("y")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// SetY setting attribute 'y' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSTranslate) SetY(value *CSSNumericValue) {
	input := value.JSValue()
	_this.Value_JS.Set("y", input)
}

// Z returning attribute 'z' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSTranslate) Z() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("z")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// SetZ setting attribute 'z' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSTranslate) SetZ(value *CSSNumericValue) {
	input := value.JSValue()
	_this.Value_JS.Set("z", input)
}

// interface: CSSUnitValue
type CSSUnitValue struct {
	CSSNumericValue
}

// CSSUnitValueFromJS is casting a js.Wrapper into CSSUnitValue.
func CSSUnitValueFromJS(value js.Wrapper) *CSSUnitValue {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSUnitValue{}
	ret.Value_JS = input
	return ret
}

func NewCSSUnitValue(value float64, unit string) (_result *CSSUnitValue) {
	_klass := js.Global().Get("CSSUnitValue")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := value
	_args[0] = _p0
	_end++
	_p1 := unit
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSUnitValue // javascript: CSSUnitValue _what_return_name
	)
	_converted = CSSUnitValueFromJS(_returned)
	_result = _converted
	return
}

// Value returning attribute 'value' with
// type float64 (idl: double).
func (_this *CSSUnitValue) Value() float64 {
	var ret float64
	value := _this.Value_JS.Get("value")
	ret = (value).Float()
	return ret
}

// SetValue setting attribute 'value' with
// type float64 (idl: double).
func (_this *CSSUnitValue) SetValue(value float64) {
	input := value
	_this.Value_JS.Set("value", input)
}

// Unit returning attribute 'unit' with
// type string (idl: USVString).
func (_this *CSSUnitValue) Unit() string {
	var ret string
	value := _this.Value_JS.Get("unit")
	ret = (value).String()
	return ret
}

// interface: CSSUnparsedValue
type CSSUnparsedValue struct {
	CSSStyleValue
}

// CSSUnparsedValueFromJS is casting a js.Wrapper into CSSUnparsedValue.
func CSSUnparsedValueFromJS(value js.Wrapper) *CSSUnparsedValue {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSUnparsedValue{}
	ret.Value_JS = input
	return ret
}

func NewCSSUnparsedValue(members []*Union) (_result *CSSUnparsedValue) {
	_klass := js.Global().Get("CSSUnparsedValue")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := js.Global().Get("Array").New(len(members))
	for __idx0, __seq_in0 := range members {
		__seq_out0 := __seq_in0.JSValue()
		_p0.SetIndex(__idx0, __seq_out0)
	}
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSUnparsedValue // javascript: CSSUnparsedValue _what_return_name
	)
	_converted = CSSUnparsedValueFromJS(_returned)
	_result = _converted
	return
}

// Length returning attribute 'length' with
// type uint (idl: unsigned long).
func (_this *CSSUnparsedValue) Length() uint {
	var ret uint
	value := _this.Value_JS.Get("length")
	ret = (uint)((value).Int())
	return ret
}

// interface: CSSVariableReferenceValue
type CSSVariableReferenceValue struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *CSSVariableReferenceValue) JSValue() js.Value {
	return _this.Value_JS
}

// CSSVariableReferenceValueFromJS is casting a js.Wrapper into CSSVariableReferenceValue.
func CSSVariableReferenceValueFromJS(value js.Wrapper) *CSSVariableReferenceValue {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CSSVariableReferenceValue{}
	ret.Value_JS = input
	return ret
}

func NewCSSVariableReferenceValue(variable string, fallback *CSSUnparsedValue) (_result *CSSVariableReferenceValue) {
	_klass := js.Global().Get("CSSVariableReferenceValue")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := variable
	_args[0] = _p0
	_end++
	if fallback != nil {
		_p1 := fallback.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSVariableReferenceValue // javascript: CSSVariableReferenceValue _what_return_name
	)
	_converted = CSSVariableReferenceValueFromJS(_returned)
	_result = _converted
	return
}

// Variable returning attribute 'variable' with
// type string (idl: USVString).
func (_this *CSSVariableReferenceValue) Variable() string {
	var ret string
	value := _this.Value_JS.Get("variable")
	ret = (value).String()
	return ret
}

// SetVariable setting attribute 'variable' with
// type string (idl: USVString).
func (_this *CSSVariableReferenceValue) SetVariable(value string) {
	input := value
	_this.Value_JS.Set("variable", input)
}

// Fallback returning attribute 'fallback' with
// type CSSUnparsedValue (idl: CSSUnparsedValue).
func (_this *CSSVariableReferenceValue) Fallback() *CSSUnparsedValue {
	var ret *CSSUnparsedValue
	value := _this.Value_JS.Get("fallback")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = CSSUnparsedValueFromJS(value)
	}
	return ret
}

// interface: StylePropertyMap
type StylePropertyMap struct {
	StylePropertyMapReadOnly
}

// StylePropertyMapFromJS is casting a js.Wrapper into StylePropertyMap.
func StylePropertyMapFromJS(value js.Wrapper) *StylePropertyMap {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &StylePropertyMap{}
	ret.Value_JS = input
	return ret
}

func (_this *StylePropertyMap) Set(property string, values ...*Union) {
	var (
		_args []interface{} = make([]interface{}, 1+len(values))
		_end  int
	)
	_p0 := property
	_args[0] = _p0
	_end++
	for _, __in := range values {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_this.Value_JS.Call("set", _args[0:_end]...)
	return
}

func (_this *StylePropertyMap) Append(property string, values ...*Union) {
	var (
		_args []interface{} = make([]interface{}, 1+len(values))
		_end  int
	)
	_p0 := property
	_args[0] = _p0
	_end++
	for _, __in := range values {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_this.Value_JS.Call("append", _args[0:_end]...)
	return
}

func (_this *StylePropertyMap) Delete(property string) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := property
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("delete", _args[0:_end]...)
	return
}

func (_this *StylePropertyMap) Clear() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("clear", _args[0:_end]...)
	return
}

// interface: StylePropertyMapReadOnly
type StylePropertyMapReadOnly struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *StylePropertyMapReadOnly) JSValue() js.Value {
	return _this.Value_JS
}

// StylePropertyMapReadOnlyFromJS is casting a js.Wrapper into StylePropertyMapReadOnly.
func StylePropertyMapReadOnlyFromJS(value js.Wrapper) *StylePropertyMapReadOnly {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &StylePropertyMapReadOnly{}
	ret.Value_JS = input
	return ret
}

// Size returning attribute 'size' with
// type uint (idl: unsigned long).
func (_this *StylePropertyMapReadOnly) Size() uint {
	var ret uint
	value := _this.Value_JS.Get("size")
	ret = (uint)((value).Int())
	return ret
}

func (_this *StylePropertyMapReadOnly) Get(property string) (_result js.Value) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := property
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("get", _args[0:_end]...)
	var (
		_converted js.Value // javascript: any _what_return_name
	)
	_converted = _returned
	_result = _converted
	return
}

func (_this *StylePropertyMapReadOnly) GetAll(property string) (_result []*CSSStyleValue) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := property
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("getAll", _args[0:_end]...)
	var (
		_converted []*CSSStyleValue // javascript: sequence<CSSStyleValue> _what_return_name
	)
	__length0 := _returned.Length()
	__array0 := make([]*CSSStyleValue, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *CSSStyleValue
		__seq_in0 := _returned.Index(__idx0)
		__seq_out0 = CSSStyleValueFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	_converted = __array0
	_result = _converted
	return
}

func (_this *StylePropertyMapReadOnly) Has(property string) (_result bool) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := property
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("has", _args[0:_end]...)
	var (
		_converted bool // javascript: boolean _what_return_name
	)
	_converted = (_returned).Bool()
	_result = _converted
	return
}
