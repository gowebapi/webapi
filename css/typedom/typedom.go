// Code generated by webidl-bind. DO NOT EDIT.

// +build !js

package typedom

import js "github.com/gowebapi/webapi/core/js"

import (
	"github.com/gowebapi/webapi/core"
	"github.com/gowebapi/webapi/dom/geometry"
)

// using following types:
// geometry.DOMMatrix
// geometry.DOMMatrixReadOnly

// source idl files:
// css-typed-om.idl

// transform files:
// css-typed-om.go.md

// workaround for compiler error
func unused(value interface{}) {
	// TODO remove this method
}

type Union struct {
	Value js.Value
}

func (u *Union) JSValue() js.Value {
	return u.Value
}

func UnionFromJS(value js.Value) *Union {
	return &Union{Value: value}
}

// enum: CSSMathOperator
type CSSMathOperator int

const (
	SumCSSMathOperator CSSMathOperator = iota
	ProductCSSMathOperator
	NegateCSSMathOperator
	InvertCSSMathOperator
	MinCSSMathOperator
	MaxCSSMathOperator
	ClampCSSMathOperator
)

var cSSMathOperatorToWasmTable = []string{
	"sum", "product", "negate", "invert", "min", "max", "clamp",
}

var cSSMathOperatorFromWasmTable = map[string]CSSMathOperator{
	"sum": SumCSSMathOperator, "product": ProductCSSMathOperator, "negate": NegateCSSMathOperator, "invert": InvertCSSMathOperator, "min": MinCSSMathOperator, "max": MaxCSSMathOperator, "clamp": ClampCSSMathOperator,
}

// JSValue is converting this enum into a javascript object
func (this *CSSMathOperator) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this CSSMathOperator) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(cSSMathOperatorToWasmTable) {
		return cSSMathOperatorToWasmTable[idx]
	}
	panic("unknown input value")
}

// CSSMathOperatorFromJS is converting a javascript value into
// a CSSMathOperator enum value.
func CSSMathOperatorFromJS(value js.Value) CSSMathOperator {
	key := value.String()
	conv, ok := cSSMathOperatorFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: CSSNumericBaseType
type CSSNumericBaseType int

const (
	LengthCSSNumericBaseType CSSNumericBaseType = iota
	AngleCSSNumericBaseType
	TimeCSSNumericBaseType
	FrequencyCSSNumericBaseType
	ResolutionCSSNumericBaseType
	FlexCSSNumericBaseType
	PercentCSSNumericBaseType
)

var cSSNumericBaseTypeToWasmTable = []string{
	"length", "angle", "time", "frequency", "resolution", "flex", "percent",
}

var cSSNumericBaseTypeFromWasmTable = map[string]CSSNumericBaseType{
	"length": LengthCSSNumericBaseType, "angle": AngleCSSNumericBaseType, "time": TimeCSSNumericBaseType, "frequency": FrequencyCSSNumericBaseType, "resolution": ResolutionCSSNumericBaseType, "flex": FlexCSSNumericBaseType, "percent": PercentCSSNumericBaseType,
}

// JSValue is converting this enum into a javascript object
func (this *CSSNumericBaseType) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this CSSNumericBaseType) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(cSSNumericBaseTypeToWasmTable) {
		return cSSNumericBaseTypeToWasmTable[idx]
	}
	panic("unknown input value")
}

// CSSNumericBaseTypeFromJS is converting a javascript value into
// a CSSNumericBaseType enum value.
func CSSNumericBaseTypeFromJS(value js.Value) CSSNumericBaseType {
	key := value.String()
	conv, ok := cSSNumericBaseTypeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// callback: CSSNumericArrayForEach
type CSSNumericArrayForEachFunc func(currentValue *CSSNumericValue, currentIndex int, listObj *CSSNumericArray)

// CSSNumericArrayForEach is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type CSSNumericArrayForEach js.Func

func CSSNumericArrayForEachToJS(callback CSSNumericArrayForEachFunc) *CSSNumericArrayForEach {
	if callback == nil {
		return nil
	}
	ret := CSSNumericArrayForEach(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *CSSNumericValue // javascript: CSSNumericValue currentValue
			_p1 int              // javascript: long currentIndex
			_p2 *CSSNumericArray // javascript: CSSNumericArray listObj
		)
		_p0 = CSSNumericValueFromJS(args[0])
		_p1 = (args[1]).Int()
		_p2 = CSSNumericArrayFromJS(args[2])
		callback(_p0, _p1, _p2)

		// returning no return value
		return nil
	}))
	return &ret
}

func CSSNumericArrayForEachFromJS(_value js.Value) CSSNumericArrayForEachFunc {
	return func(currentValue *CSSNumericValue, currentIndex int, listObj *CSSNumericArray) {
		var (
			_args [3]interface{}
			_end  int
		)
		_p0 := currentValue.JSValue()
		_args[0] = _p0
		_end++
		_p1 := currentIndex
		_args[1] = _p1
		_end++
		_p2 := listObj.JSValue()
		_args[2] = _p2
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: CSSTransformValueForEach
type CSSTransformValueForEachFunc func(currentValue *CSSTransformComponent, currentIndex int, listObj *CSSTransformValue)

// CSSTransformValueForEach is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type CSSTransformValueForEach js.Func

func CSSTransformValueForEachToJS(callback CSSTransformValueForEachFunc) *CSSTransformValueForEach {
	if callback == nil {
		return nil
	}
	ret := CSSTransformValueForEach(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *CSSTransformComponent // javascript: CSSTransformComponent currentValue
			_p1 int                    // javascript: long currentIndex
			_p2 *CSSTransformValue     // javascript: CSSTransformValue listObj
		)
		_p0 = CSSTransformComponentFromJS(args[0])
		_p1 = (args[1]).Int()
		_p2 = CSSTransformValueFromJS(args[2])
		callback(_p0, _p1, _p2)

		// returning no return value
		return nil
	}))
	return &ret
}

func CSSTransformValueForEachFromJS(_value js.Value) CSSTransformValueForEachFunc {
	return func(currentValue *CSSTransformComponent, currentIndex int, listObj *CSSTransformValue) {
		var (
			_args [3]interface{}
			_end  int
		)
		_p0 := currentValue.JSValue()
		_args[0] = _p0
		_end++
		_p1 := currentIndex
		_args[1] = _p1
		_end++
		_p2 := listObj.JSValue()
		_args[2] = _p2
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: CSSUnparsedValueForEach
type CSSUnparsedValueForEachFunc func(currentValue *Union, currentIndex int, listObj *CSSUnparsedValue)

// CSSUnparsedValueForEach is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type CSSUnparsedValueForEach js.Func

func CSSUnparsedValueForEachToJS(callback CSSUnparsedValueForEachFunc) *CSSUnparsedValueForEach {
	if callback == nil {
		return nil
	}
	ret := CSSUnparsedValueForEach(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *Union            // javascript: Union currentValue
			_p1 int               // javascript: long currentIndex
			_p2 *CSSUnparsedValue // javascript: CSSUnparsedValue listObj
		)
		_p0 = UnionFromJS(args[0])
		_p1 = (args[1]).Int()
		_p2 = CSSUnparsedValueFromJS(args[2])
		callback(_p0, _p1, _p2)

		// returning no return value
		return nil
	}))
	return &ret
}

func CSSUnparsedValueForEachFromJS(_value js.Value) CSSUnparsedValueForEachFunc {
	return func(currentValue *Union, currentIndex int, listObj *CSSUnparsedValue) {
		var (
			_args [3]interface{}
			_end  int
		)
		_p0 := currentValue.JSValue()
		_args[0] = _p0
		_end++
		_p1 := currentIndex
		_args[1] = _p1
		_end++
		_p2 := listObj.JSValue()
		_args[2] = _p2
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: StylePropertyMapReadOnlyForEach
type StylePropertyMapReadOnlyForEachFunc func(currentValue []*CSSStyleValue, currentIndex int, listObj *StylePropertyMapReadOnly)

// StylePropertyMapReadOnlyForEach is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type StylePropertyMapReadOnlyForEach js.Func

func StylePropertyMapReadOnlyForEachToJS(callback StylePropertyMapReadOnlyForEachFunc) *StylePropertyMapReadOnlyForEach {
	if callback == nil {
		return nil
	}
	ret := StylePropertyMapReadOnlyForEach(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 []*CSSStyleValue          // javascript: sequence<CSSStyleValue> currentValue
			_p1 int                       // javascript: long currentIndex
			_p2 *StylePropertyMapReadOnly // javascript: StylePropertyMapReadOnly listObj
		)
		__length0 := args[0].Length()
		__array0 := make([]*CSSStyleValue, __length0, __length0)
		for __idx0 := 0; __idx0 < __length0; __idx0++ {
			var __seq_out0 *CSSStyleValue
			__seq_in0 := args[0].Index(__idx0)
			__seq_out0 = CSSStyleValueFromJS(__seq_in0)
			__array0[__idx0] = __seq_out0
		}
		_p0 = __array0
		_p1 = (args[1]).Int()
		_p2 = StylePropertyMapReadOnlyFromJS(args[2])
		callback(_p0, _p1, _p2)

		// returning no return value
		return nil
	}))
	return &ret
}

func StylePropertyMapReadOnlyForEachFromJS(_value js.Value) StylePropertyMapReadOnlyForEachFunc {
	return func(currentValue []*CSSStyleValue, currentIndex int, listObj *StylePropertyMapReadOnly) {
		var (
			_args [3]interface{}
			_end  int
		)
		_p0 := js.Global().Get("Array").New(len(currentValue))
		for __idx0, __seq_in0 := range currentValue {
			__seq_out0 := __seq_in0.JSValue()
			_p0.SetIndex(__idx0, __seq_out0)
		}
		_args[0] = _p0
		_end++
		_p1 := currentIndex
		_args[1] = _p1
		_end++
		_p2 := listObj.JSValue()
		_args[2] = _p2
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// dictionary: CSSMatrixComponentOptions
type CSSMatrixComponentOptions struct {
	Is2D bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *CSSMatrixComponentOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Is2D
	out.Set("is2D", value0)
	return out
}

// CSSMatrixComponentOptionsFromJS is allocating a new
// CSSMatrixComponentOptions object and copy all values in the value javascript object.
func CSSMatrixComponentOptionsFromJS(value js.Value) *CSSMatrixComponentOptions {
	var out CSSMatrixComponentOptions
	var (
		value0 bool // javascript: boolean {is2D Is2D is2D}
	)
	value0 = (value.Get("is2D")).Bool()
	out.Is2D = value0
	return &out
}

// dictionary: CSSNumericArrayEntryIteratorValue
type CSSNumericArrayEntryIteratorValue struct {
	Value []js.Value
	Done  bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *CSSNumericArrayEntryIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.Value))
	for __idx0, __seq_in0 := range _this.Value {
		__seq_out0 := __seq_in0
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// CSSNumericArrayEntryIteratorValueFromJS is allocating a new
// CSSNumericArrayEntryIteratorValue object and copy all values in the value javascript object.
func CSSNumericArrayEntryIteratorValueFromJS(value js.Value) *CSSNumericArrayEntryIteratorValue {
	var out CSSNumericArrayEntryIteratorValue
	var (
		value0 []js.Value // javascript: sequence<any> {value Value value}
		value1 bool       // javascript: boolean {done Done done}
	)
	__length0 := value.Get("value").Length()
	__array0 := make([]js.Value, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 js.Value
		__seq_in0 := value.Get("value").Index(__idx0)
		__seq_out0 = __seq_in0
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.Value = value0
	value1 = (value.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: CSSNumericArrayKeyIteratorValue
type CSSNumericArrayKeyIteratorValue struct {
	Value uint
	Done  bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *CSSNumericArrayKeyIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Value
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// CSSNumericArrayKeyIteratorValueFromJS is allocating a new
// CSSNumericArrayKeyIteratorValue object and copy all values in the value javascript object.
func CSSNumericArrayKeyIteratorValueFromJS(value js.Value) *CSSNumericArrayKeyIteratorValue {
	var out CSSNumericArrayKeyIteratorValue
	var (
		value0 uint // javascript: unsigned long {value Value value}
		value1 bool // javascript: boolean {done Done done}
	)
	value0 = (uint)((value.Get("value")).Int())
	out.Value = value0
	value1 = (value.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: CSSNumericArrayValueIteratorValue
type CSSNumericArrayValueIteratorValue struct {
	Value *CSSNumericValue
	Done  bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *CSSNumericArrayValueIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Value.JSValue()
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// CSSNumericArrayValueIteratorValueFromJS is allocating a new
// CSSNumericArrayValueIteratorValue object and copy all values in the value javascript object.
func CSSNumericArrayValueIteratorValueFromJS(value js.Value) *CSSNumericArrayValueIteratorValue {
	var out CSSNumericArrayValueIteratorValue
	var (
		value0 *CSSNumericValue // javascript: CSSNumericValue {value Value value}
		value1 bool             // javascript: boolean {done Done done}
	)
	value0 = CSSNumericValueFromJS(value.Get("value"))
	out.Value = value0
	value1 = (value.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: CSSNumericType
type CSSNumericType struct {
	Length      int
	Angle       int
	Time        int
	Frequency   int
	Resolution  int
	Flex        int
	Percent     int
	PercentHint CSSNumericBaseType
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *CSSNumericType) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Length
	out.Set("length", value0)
	value1 := _this.Angle
	out.Set("angle", value1)
	value2 := _this.Time
	out.Set("time", value2)
	value3 := _this.Frequency
	out.Set("frequency", value3)
	value4 := _this.Resolution
	out.Set("resolution", value4)
	value5 := _this.Flex
	out.Set("flex", value5)
	value6 := _this.Percent
	out.Set("percent", value6)
	value7 := _this.PercentHint.JSValue()
	out.Set("percentHint", value7)
	return out
}

// CSSNumericTypeFromJS is allocating a new
// CSSNumericType object and copy all values in the value javascript object.
func CSSNumericTypeFromJS(value js.Value) *CSSNumericType {
	var out CSSNumericType
	var (
		value0 int                // javascript: long {length Length length}
		value1 int                // javascript: long {angle Angle angle}
		value2 int                // javascript: long {time Time time}
		value3 int                // javascript: long {frequency Frequency frequency}
		value4 int                // javascript: long {resolution Resolution resolution}
		value5 int                // javascript: long {flex Flex flex}
		value6 int                // javascript: long {percent Percent percent}
		value7 CSSNumericBaseType // javascript: CSSNumericBaseType {percentHint PercentHint percentHint}
	)
	value0 = (value.Get("length")).Int()
	out.Length = value0
	value1 = (value.Get("angle")).Int()
	out.Angle = value1
	value2 = (value.Get("time")).Int()
	out.Time = value2
	value3 = (value.Get("frequency")).Int()
	out.Frequency = value3
	value4 = (value.Get("resolution")).Int()
	out.Resolution = value4
	value5 = (value.Get("flex")).Int()
	out.Flex = value5
	value6 = (value.Get("percent")).Int()
	out.Percent = value6
	value7 = CSSNumericBaseTypeFromJS(value.Get("percentHint"))
	out.PercentHint = value7
	return &out
}

// dictionary: CSSTransformValueEntryIteratorValue
type CSSTransformValueEntryIteratorValue struct {
	Value []js.Value
	Done  bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *CSSTransformValueEntryIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.Value))
	for __idx0, __seq_in0 := range _this.Value {
		__seq_out0 := __seq_in0
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// CSSTransformValueEntryIteratorValueFromJS is allocating a new
// CSSTransformValueEntryIteratorValue object and copy all values in the value javascript object.
func CSSTransformValueEntryIteratorValueFromJS(value js.Value) *CSSTransformValueEntryIteratorValue {
	var out CSSTransformValueEntryIteratorValue
	var (
		value0 []js.Value // javascript: sequence<any> {value Value value}
		value1 bool       // javascript: boolean {done Done done}
	)
	__length0 := value.Get("value").Length()
	__array0 := make([]js.Value, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 js.Value
		__seq_in0 := value.Get("value").Index(__idx0)
		__seq_out0 = __seq_in0
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.Value = value0
	value1 = (value.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: CSSTransformValueKeyIteratorValue
type CSSTransformValueKeyIteratorValue struct {
	Value uint
	Done  bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *CSSTransformValueKeyIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Value
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// CSSTransformValueKeyIteratorValueFromJS is allocating a new
// CSSTransformValueKeyIteratorValue object and copy all values in the value javascript object.
func CSSTransformValueKeyIteratorValueFromJS(value js.Value) *CSSTransformValueKeyIteratorValue {
	var out CSSTransformValueKeyIteratorValue
	var (
		value0 uint // javascript: unsigned long {value Value value}
		value1 bool // javascript: boolean {done Done done}
	)
	value0 = (uint)((value.Get("value")).Int())
	out.Value = value0
	value1 = (value.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: CSSTransformValueValueIteratorValue
type CSSTransformValueValueIteratorValue struct {
	Value *CSSTransformComponent
	Done  bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *CSSTransformValueValueIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Value.JSValue()
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// CSSTransformValueValueIteratorValueFromJS is allocating a new
// CSSTransformValueValueIteratorValue object and copy all values in the value javascript object.
func CSSTransformValueValueIteratorValueFromJS(value js.Value) *CSSTransformValueValueIteratorValue {
	var out CSSTransformValueValueIteratorValue
	var (
		value0 *CSSTransformComponent // javascript: CSSTransformComponent {value Value value}
		value1 bool                   // javascript: boolean {done Done done}
	)
	value0 = CSSTransformComponentFromJS(value.Get("value"))
	out.Value = value0
	value1 = (value.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: CSSUnparsedValueEntryIteratorValue
type CSSUnparsedValueEntryIteratorValue struct {
	Value []js.Value
	Done  bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *CSSUnparsedValueEntryIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.Value))
	for __idx0, __seq_in0 := range _this.Value {
		__seq_out0 := __seq_in0
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// CSSUnparsedValueEntryIteratorValueFromJS is allocating a new
// CSSUnparsedValueEntryIteratorValue object and copy all values in the value javascript object.
func CSSUnparsedValueEntryIteratorValueFromJS(value js.Value) *CSSUnparsedValueEntryIteratorValue {
	var out CSSUnparsedValueEntryIteratorValue
	var (
		value0 []js.Value // javascript: sequence<any> {value Value value}
		value1 bool       // javascript: boolean {done Done done}
	)
	__length0 := value.Get("value").Length()
	__array0 := make([]js.Value, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 js.Value
		__seq_in0 := value.Get("value").Index(__idx0)
		__seq_out0 = __seq_in0
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.Value = value0
	value1 = (value.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: CSSUnparsedValueKeyIteratorValue
type CSSUnparsedValueKeyIteratorValue struct {
	Value uint
	Done  bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *CSSUnparsedValueKeyIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Value
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// CSSUnparsedValueKeyIteratorValueFromJS is allocating a new
// CSSUnparsedValueKeyIteratorValue object and copy all values in the value javascript object.
func CSSUnparsedValueKeyIteratorValueFromJS(value js.Value) *CSSUnparsedValueKeyIteratorValue {
	var out CSSUnparsedValueKeyIteratorValue
	var (
		value0 uint // javascript: unsigned long {value Value value}
		value1 bool // javascript: boolean {done Done done}
	)
	value0 = (uint)((value.Get("value")).Int())
	out.Value = value0
	value1 = (value.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: CSSUnparsedValueValueIteratorValue
type CSSUnparsedValueValueIteratorValue struct {
	Value *Union
	Done  bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *CSSUnparsedValueValueIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Value.JSValue()
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// CSSUnparsedValueValueIteratorValueFromJS is allocating a new
// CSSUnparsedValueValueIteratorValue object and copy all values in the value javascript object.
func CSSUnparsedValueValueIteratorValueFromJS(value js.Value) *CSSUnparsedValueValueIteratorValue {
	var out CSSUnparsedValueValueIteratorValue
	var (
		value0 *Union // javascript: Union {value Value value}
		value1 bool   // javascript: boolean {done Done done}
	)
	value0 = UnionFromJS(value.Get("value"))
	out.Value = value0
	value1 = (value.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: StylePropertyMapReadOnlyEntryIteratorValue
type StylePropertyMapReadOnlyEntryIteratorValue struct {
	Value []js.Value
	Done  bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *StylePropertyMapReadOnlyEntryIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.Value))
	for __idx0, __seq_in0 := range _this.Value {
		__seq_out0 := __seq_in0
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// StylePropertyMapReadOnlyEntryIteratorValueFromJS is allocating a new
// StylePropertyMapReadOnlyEntryIteratorValue object and copy all values in the value javascript object.
func StylePropertyMapReadOnlyEntryIteratorValueFromJS(value js.Value) *StylePropertyMapReadOnlyEntryIteratorValue {
	var out StylePropertyMapReadOnlyEntryIteratorValue
	var (
		value0 []js.Value // javascript: sequence<any> {value Value value}
		value1 bool       // javascript: boolean {done Done done}
	)
	__length0 := value.Get("value").Length()
	__array0 := make([]js.Value, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 js.Value
		__seq_in0 := value.Get("value").Index(__idx0)
		__seq_out0 = __seq_in0
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.Value = value0
	value1 = (value.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: StylePropertyMapReadOnlyKeyIteratorValue
type StylePropertyMapReadOnlyKeyIteratorValue struct {
	Value string
	Done  bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *StylePropertyMapReadOnlyKeyIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Value
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// StylePropertyMapReadOnlyKeyIteratorValueFromJS is allocating a new
// StylePropertyMapReadOnlyKeyIteratorValue object and copy all values in the value javascript object.
func StylePropertyMapReadOnlyKeyIteratorValueFromJS(value js.Value) *StylePropertyMapReadOnlyKeyIteratorValue {
	var out StylePropertyMapReadOnlyKeyIteratorValue
	var (
		value0 string // javascript: USVString {value Value value}
		value1 bool   // javascript: boolean {done Done done}
	)
	value0 = (value.Get("value")).String()
	out.Value = value0
	value1 = (value.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: StylePropertyMapReadOnlyValueIteratorValue
type StylePropertyMapReadOnlyValueIteratorValue struct {
	Value []*CSSStyleValue
	Done  bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *StylePropertyMapReadOnlyValueIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.Value))
	for __idx0, __seq_in0 := range _this.Value {
		__seq_out0 := __seq_in0.JSValue()
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// StylePropertyMapReadOnlyValueIteratorValueFromJS is allocating a new
// StylePropertyMapReadOnlyValueIteratorValue object and copy all values in the value javascript object.
func StylePropertyMapReadOnlyValueIteratorValueFromJS(value js.Value) *StylePropertyMapReadOnlyValueIteratorValue {
	var out StylePropertyMapReadOnlyValueIteratorValue
	var (
		value0 []*CSSStyleValue // javascript: sequence<CSSStyleValue> {value Value value}
		value1 bool             // javascript: boolean {done Done done}
	)
	__length0 := value.Get("value").Length()
	__array0 := make([]*CSSStyleValue, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *CSSStyleValue
		__seq_in0 := value.Get("value").Index(__idx0)
		__seq_out0 = CSSStyleValueFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.Value = value0
	value1 = (value.Get("done")).Bool()
	out.Done = value1
	return &out
}

// class: CSSImageValue
type CSSImageValue struct {
	CSSStyleValue
}

// CSSImageValueFromJS is casting a js.Value into CSSImageValue.
func CSSImageValueFromJS(value js.Value) *CSSImageValue {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSImageValue{}
	ret.Value_JS = value
	return ret
}

// CSSImageValueFromJS is casting from something that holds a js.Value into CSSImageValue.
func CSSImageValueFromWrapper(input core.Wrapper) *CSSImageValue {
	return CSSImageValueFromJS(input.JSValue())
}

// class: CSSKeywordValue
type CSSKeywordValue struct {
	CSSStyleValue
}

// CSSKeywordValueFromJS is casting a js.Value into CSSKeywordValue.
func CSSKeywordValueFromJS(value js.Value) *CSSKeywordValue {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSKeywordValue{}
	ret.Value_JS = value
	return ret
}

// CSSKeywordValueFromJS is casting from something that holds a js.Value into CSSKeywordValue.
func CSSKeywordValueFromWrapper(input core.Wrapper) *CSSKeywordValue {
	return CSSKeywordValueFromJS(input.JSValue())
}

func NewCSSKeywordValue(value string) (_result *CSSKeywordValue) {
	_klass := js.Global().Get("CSSKeywordValue")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := value
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSKeywordValue // javascript: CSSKeywordValue _what_return_name
	)
	_converted = CSSKeywordValueFromJS(_returned)
	_result = _converted
	return
}

// Value returning attribute 'value' with
// type string (idl: USVString).
func (_this *CSSKeywordValue) Value() string {
	var ret string
	value := _this.Value_JS.Get("value")
	ret = (value).String()
	return ret
}

// SetValue setting attribute 'value' with
// type string (idl: USVString).
func (_this *CSSKeywordValue) SetValue(value string) {
	input := value
	_this.Value_JS.Set("value", input)
}

// class: CSSMathClamp
type CSSMathClamp struct {
	CSSMathValue
}

// CSSMathClampFromJS is casting a js.Value into CSSMathClamp.
func CSSMathClampFromJS(value js.Value) *CSSMathClamp {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSMathClamp{}
	ret.Value_JS = value
	return ret
}

// CSSMathClampFromJS is casting from something that holds a js.Value into CSSMathClamp.
func CSSMathClampFromWrapper(input core.Wrapper) *CSSMathClamp {
	return CSSMathClampFromJS(input.JSValue())
}

func NewCSSMathClamp(min *Union, val *Union, max *Union) (_result *CSSMathClamp) {
	_klass := js.Global().Get("CSSMathClamp")
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := min.JSValue()
	_args[0] = _p0
	_end++
	_p1 := val.JSValue()
	_args[1] = _p1
	_end++
	_p2 := max.JSValue()
	_args[2] = _p2
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSMathClamp // javascript: CSSMathClamp _what_return_name
	)
	_converted = CSSMathClampFromJS(_returned)
	_result = _converted
	return
}

// Min returning attribute 'min' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSMathClamp) Min() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("min")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// Val returning attribute 'val' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSMathClamp) Val() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("val")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// Max returning attribute 'max' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSMathClamp) Max() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("max")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// class: CSSMathInvert
type CSSMathInvert struct {
	CSSMathValue
}

// CSSMathInvertFromJS is casting a js.Value into CSSMathInvert.
func CSSMathInvertFromJS(value js.Value) *CSSMathInvert {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSMathInvert{}
	ret.Value_JS = value
	return ret
}

// CSSMathInvertFromJS is casting from something that holds a js.Value into CSSMathInvert.
func CSSMathInvertFromWrapper(input core.Wrapper) *CSSMathInvert {
	return CSSMathInvertFromJS(input.JSValue())
}

func NewCSSMathInvert(arg *Union) (_result *CSSMathInvert) {
	_klass := js.Global().Get("CSSMathInvert")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := arg.JSValue()
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSMathInvert // javascript: CSSMathInvert _what_return_name
	)
	_converted = CSSMathInvertFromJS(_returned)
	_result = _converted
	return
}

// Value returning attribute 'value' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSMathInvert) Value() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("value")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// class: CSSMathMax
type CSSMathMax struct {
	CSSMathValue
}

// CSSMathMaxFromJS is casting a js.Value into CSSMathMax.
func CSSMathMaxFromJS(value js.Value) *CSSMathMax {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSMathMax{}
	ret.Value_JS = value
	return ret
}

// CSSMathMaxFromJS is casting from something that holds a js.Value into CSSMathMax.
func CSSMathMaxFromWrapper(input core.Wrapper) *CSSMathMax {
	return CSSMathMaxFromJS(input.JSValue())
}

func NewCSSMathMax(args ...*Union) (_result *CSSMathMax) {
	_klass := js.Global().Get("CSSMathMax")
	var (
		_args []interface{} = make([]interface{}, 0+len(args))
		_end  int
	)
	for _, __in := range args {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSMathMax // javascript: CSSMathMax _what_return_name
	)
	_converted = CSSMathMaxFromJS(_returned)
	_result = _converted
	return
}

// Values returning attribute 'values' with
// type CSSNumericArray (idl: CSSNumericArray).
func (_this *CSSMathMax) Values() *CSSNumericArray {
	var ret *CSSNumericArray
	value := _this.Value_JS.Get("values")
	ret = CSSNumericArrayFromJS(value)
	return ret
}

// class: CSSMathMin
type CSSMathMin struct {
	CSSMathValue
}

// CSSMathMinFromJS is casting a js.Value into CSSMathMin.
func CSSMathMinFromJS(value js.Value) *CSSMathMin {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSMathMin{}
	ret.Value_JS = value
	return ret
}

// CSSMathMinFromJS is casting from something that holds a js.Value into CSSMathMin.
func CSSMathMinFromWrapper(input core.Wrapper) *CSSMathMin {
	return CSSMathMinFromJS(input.JSValue())
}

func NewCSSMathMin(args ...*Union) (_result *CSSMathMin) {
	_klass := js.Global().Get("CSSMathMin")
	var (
		_args []interface{} = make([]interface{}, 0+len(args))
		_end  int
	)
	for _, __in := range args {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSMathMin // javascript: CSSMathMin _what_return_name
	)
	_converted = CSSMathMinFromJS(_returned)
	_result = _converted
	return
}

// Values returning attribute 'values' with
// type CSSNumericArray (idl: CSSNumericArray).
func (_this *CSSMathMin) Values() *CSSNumericArray {
	var ret *CSSNumericArray
	value := _this.Value_JS.Get("values")
	ret = CSSNumericArrayFromJS(value)
	return ret
}

// class: CSSMathNegate
type CSSMathNegate struct {
	CSSMathValue
}

// CSSMathNegateFromJS is casting a js.Value into CSSMathNegate.
func CSSMathNegateFromJS(value js.Value) *CSSMathNegate {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSMathNegate{}
	ret.Value_JS = value
	return ret
}

// CSSMathNegateFromJS is casting from something that holds a js.Value into CSSMathNegate.
func CSSMathNegateFromWrapper(input core.Wrapper) *CSSMathNegate {
	return CSSMathNegateFromJS(input.JSValue())
}

func NewCSSMathNegate(arg *Union) (_result *CSSMathNegate) {
	_klass := js.Global().Get("CSSMathNegate")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := arg.JSValue()
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSMathNegate // javascript: CSSMathNegate _what_return_name
	)
	_converted = CSSMathNegateFromJS(_returned)
	_result = _converted
	return
}

// Value returning attribute 'value' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSMathNegate) Value() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("value")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// class: CSSMathProduct
type CSSMathProduct struct {
	CSSMathValue
}

// CSSMathProductFromJS is casting a js.Value into CSSMathProduct.
func CSSMathProductFromJS(value js.Value) *CSSMathProduct {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSMathProduct{}
	ret.Value_JS = value
	return ret
}

// CSSMathProductFromJS is casting from something that holds a js.Value into CSSMathProduct.
func CSSMathProductFromWrapper(input core.Wrapper) *CSSMathProduct {
	return CSSMathProductFromJS(input.JSValue())
}

func NewCSSMathProduct(args ...*Union) (_result *CSSMathProduct) {
	_klass := js.Global().Get("CSSMathProduct")
	var (
		_args []interface{} = make([]interface{}, 0+len(args))
		_end  int
	)
	for _, __in := range args {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSMathProduct // javascript: CSSMathProduct _what_return_name
	)
	_converted = CSSMathProductFromJS(_returned)
	_result = _converted
	return
}

// Values returning attribute 'values' with
// type CSSNumericArray (idl: CSSNumericArray).
func (_this *CSSMathProduct) Values() *CSSNumericArray {
	var ret *CSSNumericArray
	value := _this.Value_JS.Get("values")
	ret = CSSNumericArrayFromJS(value)
	return ret
}

// class: CSSMathSum
type CSSMathSum struct {
	CSSMathValue
}

// CSSMathSumFromJS is casting a js.Value into CSSMathSum.
func CSSMathSumFromJS(value js.Value) *CSSMathSum {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSMathSum{}
	ret.Value_JS = value
	return ret
}

// CSSMathSumFromJS is casting from something that holds a js.Value into CSSMathSum.
func CSSMathSumFromWrapper(input core.Wrapper) *CSSMathSum {
	return CSSMathSumFromJS(input.JSValue())
}

func NewCSSMathSum(args ...*Union) (_result *CSSMathSum) {
	_klass := js.Global().Get("CSSMathSum")
	var (
		_args []interface{} = make([]interface{}, 0+len(args))
		_end  int
	)
	for _, __in := range args {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSMathSum // javascript: CSSMathSum _what_return_name
	)
	_converted = CSSMathSumFromJS(_returned)
	_result = _converted
	return
}

// Values returning attribute 'values' with
// type CSSNumericArray (idl: CSSNumericArray).
func (_this *CSSMathSum) Values() *CSSNumericArray {
	var ret *CSSNumericArray
	value := _this.Value_JS.Get("values")
	ret = CSSNumericArrayFromJS(value)
	return ret
}

// class: CSSMathValue
type CSSMathValue struct {
	CSSNumericValue
}

// CSSMathValueFromJS is casting a js.Value into CSSMathValue.
func CSSMathValueFromJS(value js.Value) *CSSMathValue {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSMathValue{}
	ret.Value_JS = value
	return ret
}

// CSSMathValueFromJS is casting from something that holds a js.Value into CSSMathValue.
func CSSMathValueFromWrapper(input core.Wrapper) *CSSMathValue {
	return CSSMathValueFromJS(input.JSValue())
}

// Operator returning attribute 'operator' with
// type CSSMathOperator (idl: CSSMathOperator).
func (_this *CSSMathValue) Operator() CSSMathOperator {
	var ret CSSMathOperator
	value := _this.Value_JS.Get("operator")
	ret = CSSMathOperatorFromJS(value)
	return ret
}

// class: CSSMatrixComponent
type CSSMatrixComponent struct {
	CSSTransformComponent
}

// CSSMatrixComponentFromJS is casting a js.Value into CSSMatrixComponent.
func CSSMatrixComponentFromJS(value js.Value) *CSSMatrixComponent {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSMatrixComponent{}
	ret.Value_JS = value
	return ret
}

// CSSMatrixComponentFromJS is casting from something that holds a js.Value into CSSMatrixComponent.
func CSSMatrixComponentFromWrapper(input core.Wrapper) *CSSMatrixComponent {
	return CSSMatrixComponentFromJS(input.JSValue())
}

func NewCSSMatrixComponent(matrix *geometry.DOMMatrixReadOnly, options *CSSMatrixComponentOptions) (_result *CSSMatrixComponent) {
	_klass := js.Global().Get("CSSMatrixComponent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := matrix.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSMatrixComponent // javascript: CSSMatrixComponent _what_return_name
	)
	_converted = CSSMatrixComponentFromJS(_returned)
	_result = _converted
	return
}

// Matrix returning attribute 'matrix' with
// type geometry.DOMMatrix (idl: DOMMatrix).
func (_this *CSSMatrixComponent) Matrix() *geometry.DOMMatrix {
	var ret *geometry.DOMMatrix
	value := _this.Value_JS.Get("matrix")
	ret = geometry.DOMMatrixFromJS(value)
	return ret
}

// SetMatrix setting attribute 'matrix' with
// type geometry.DOMMatrix (idl: DOMMatrix).
func (_this *CSSMatrixComponent) SetMatrix(value *geometry.DOMMatrix) {
	input := value.JSValue()
	_this.Value_JS.Set("matrix", input)
}

// class: CSSNumericArray
type CSSNumericArray struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *CSSNumericArray) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// CSSNumericArrayFromJS is casting a js.Value into CSSNumericArray.
func CSSNumericArrayFromJS(value js.Value) *CSSNumericArray {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSNumericArray{}
	ret.Value_JS = value
	return ret
}

// CSSNumericArrayFromJS is casting from something that holds a js.Value into CSSNumericArray.
func CSSNumericArrayFromWrapper(input core.Wrapper) *CSSNumericArray {
	return CSSNumericArrayFromJS(input.JSValue())
}

// Length returning attribute 'length' with
// type uint (idl: unsigned long).
func (_this *CSSNumericArray) Length() uint {
	var ret uint
	value := _this.Value_JS.Get("length")
	ret = (uint)((value).Int())
	return ret
}

func (_this *CSSNumericArray) Index(index uint) (_result *CSSNumericValue) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := index
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("", _args[0:_end]...)
	var (
		_converted *CSSNumericValue // javascript: CSSNumericValue _what_return_name
	)
	_converted = CSSNumericValueFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericArray) Entries() (_result *CSSNumericArrayEntryIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("entries", _args[0:_end]...)
	var (
		_converted *CSSNumericArrayEntryIterator // javascript: CSSNumericArrayEntryIterator _what_return_name
	)
	_converted = CSSNumericArrayEntryIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericArray) ForEach(callback *CSSNumericArrayForEach, optionalThisForCallbackArgument interface{}) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if callback != nil {
		__callback0 = (*callback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if optionalThisForCallbackArgument != nil {
		_p1 := optionalThisForCallbackArgument
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("forEach", _args[0:_end]...)
	return
}

func (_this *CSSNumericArray) Keys() (_result *CSSNumericArrayKeyIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("keys", _args[0:_end]...)
	var (
		_converted *CSSNumericArrayKeyIterator // javascript: CSSNumericArrayKeyIterator _what_return_name
	)
	_converted = CSSNumericArrayKeyIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericArray) Values() (_result *CSSNumericArrayValueIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("values", _args[0:_end]...)
	var (
		_converted *CSSNumericArrayValueIterator // javascript: CSSNumericArrayValueIterator _what_return_name
	)
	_converted = CSSNumericArrayValueIteratorFromJS(_returned)
	_result = _converted
	return
}

// class: CSSNumericArrayEntryIterator
type CSSNumericArrayEntryIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *CSSNumericArrayEntryIterator) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// CSSNumericArrayEntryIteratorFromJS is casting a js.Value into CSSNumericArrayEntryIterator.
func CSSNumericArrayEntryIteratorFromJS(value js.Value) *CSSNumericArrayEntryIterator {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSNumericArrayEntryIterator{}
	ret.Value_JS = value
	return ret
}

// CSSNumericArrayEntryIteratorFromJS is casting from something that holds a js.Value into CSSNumericArrayEntryIterator.
func CSSNumericArrayEntryIteratorFromWrapper(input core.Wrapper) *CSSNumericArrayEntryIterator {
	return CSSNumericArrayEntryIteratorFromJS(input.JSValue())
}

func (_this *CSSNumericArrayEntryIterator) Next() (_result *CSSNumericArrayEntryIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *CSSNumericArrayEntryIteratorValue // javascript: CSSNumericArrayEntryIteratorValue _what_return_name
	)
	_converted = CSSNumericArrayEntryIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: CSSNumericArrayKeyIterator
type CSSNumericArrayKeyIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *CSSNumericArrayKeyIterator) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// CSSNumericArrayKeyIteratorFromJS is casting a js.Value into CSSNumericArrayKeyIterator.
func CSSNumericArrayKeyIteratorFromJS(value js.Value) *CSSNumericArrayKeyIterator {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSNumericArrayKeyIterator{}
	ret.Value_JS = value
	return ret
}

// CSSNumericArrayKeyIteratorFromJS is casting from something that holds a js.Value into CSSNumericArrayKeyIterator.
func CSSNumericArrayKeyIteratorFromWrapper(input core.Wrapper) *CSSNumericArrayKeyIterator {
	return CSSNumericArrayKeyIteratorFromJS(input.JSValue())
}

func (_this *CSSNumericArrayKeyIterator) Next() (_result *CSSNumericArrayKeyIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *CSSNumericArrayKeyIteratorValue // javascript: CSSNumericArrayKeyIteratorValue _what_return_name
	)
	_converted = CSSNumericArrayKeyIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: CSSNumericArrayValueIterator
type CSSNumericArrayValueIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *CSSNumericArrayValueIterator) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// CSSNumericArrayValueIteratorFromJS is casting a js.Value into CSSNumericArrayValueIterator.
func CSSNumericArrayValueIteratorFromJS(value js.Value) *CSSNumericArrayValueIterator {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSNumericArrayValueIterator{}
	ret.Value_JS = value
	return ret
}

// CSSNumericArrayValueIteratorFromJS is casting from something that holds a js.Value into CSSNumericArrayValueIterator.
func CSSNumericArrayValueIteratorFromWrapper(input core.Wrapper) *CSSNumericArrayValueIterator {
	return CSSNumericArrayValueIteratorFromJS(input.JSValue())
}

func (_this *CSSNumericArrayValueIterator) Next() (_result *CSSNumericArrayValueIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *CSSNumericArrayValueIteratorValue // javascript: CSSNumericArrayValueIteratorValue _what_return_name
	)
	_converted = CSSNumericArrayValueIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: CSSNumericValue
type CSSNumericValue struct {
	CSSStyleValue
}

// CSSNumericValueFromJS is casting a js.Value into CSSNumericValue.
func CSSNumericValueFromJS(value js.Value) *CSSNumericValue {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSNumericValue{}
	ret.Value_JS = value
	return ret
}

// CSSNumericValueFromJS is casting from something that holds a js.Value into CSSNumericValue.
func CSSNumericValueFromWrapper(input core.Wrapper) *CSSNumericValue {
	return CSSNumericValueFromJS(input.JSValue())
}

func Parse(cssText string) (_result *CSSNumericValue) {
	_klass := js.Global().Get("CSSNumericValue")
	_method := _klass.Get("parse")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := cssText
	_args[0] = _p0
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted *CSSNumericValue // javascript: CSSNumericValue _what_return_name
	)
	_converted = CSSNumericValueFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericValue) Add(values ...*Union) (_result *CSSNumericValue) {
	var (
		_args []interface{} = make([]interface{}, 0+len(values))
		_end  int
	)
	for _, __in := range values {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("add", _args[0:_end]...)
	var (
		_converted *CSSNumericValue // javascript: CSSNumericValue _what_return_name
	)
	_converted = CSSNumericValueFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericValue) Sub(values ...*Union) (_result *CSSNumericValue) {
	var (
		_args []interface{} = make([]interface{}, 0+len(values))
		_end  int
	)
	for _, __in := range values {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("sub", _args[0:_end]...)
	var (
		_converted *CSSNumericValue // javascript: CSSNumericValue _what_return_name
	)
	_converted = CSSNumericValueFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericValue) Mul(values ...*Union) (_result *CSSNumericValue) {
	var (
		_args []interface{} = make([]interface{}, 0+len(values))
		_end  int
	)
	for _, __in := range values {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("mul", _args[0:_end]...)
	var (
		_converted *CSSNumericValue // javascript: CSSNumericValue _what_return_name
	)
	_converted = CSSNumericValueFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericValue) Div(values ...*Union) (_result *CSSNumericValue) {
	var (
		_args []interface{} = make([]interface{}, 0+len(values))
		_end  int
	)
	for _, __in := range values {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("div", _args[0:_end]...)
	var (
		_converted *CSSNumericValue // javascript: CSSNumericValue _what_return_name
	)
	_converted = CSSNumericValueFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericValue) Min(values ...*Union) (_result *CSSNumericValue) {
	var (
		_args []interface{} = make([]interface{}, 0+len(values))
		_end  int
	)
	for _, __in := range values {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("min", _args[0:_end]...)
	var (
		_converted *CSSNumericValue // javascript: CSSNumericValue _what_return_name
	)
	_converted = CSSNumericValueFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericValue) Max(values ...*Union) (_result *CSSNumericValue) {
	var (
		_args []interface{} = make([]interface{}, 0+len(values))
		_end  int
	)
	for _, __in := range values {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("max", _args[0:_end]...)
	var (
		_converted *CSSNumericValue // javascript: CSSNumericValue _what_return_name
	)
	_converted = CSSNumericValueFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericValue) Equals(value ...*Union) (_result bool) {
	var (
		_args []interface{} = make([]interface{}, 0+len(value))
		_end  int
	)
	for _, __in := range value {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("equals", _args[0:_end]...)
	var (
		_converted bool // javascript: boolean _what_return_name
	)
	_converted = (_returned).Bool()
	_result = _converted
	return
}

func (_this *CSSNumericValue) To(unit string) (_result *CSSUnitValue) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := unit
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("to", _args[0:_end]...)
	var (
		_converted *CSSUnitValue // javascript: CSSUnitValue _what_return_name
	)
	_converted = CSSUnitValueFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericValue) ToSum(units ...string) (_result *CSSMathSum) {
	var (
		_args []interface{} = make([]interface{}, 0+len(units))
		_end  int
	)
	for _, __in := range units {
		__out := __in
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("toSum", _args[0:_end]...)
	var (
		_converted *CSSMathSum // javascript: CSSMathSum _what_return_name
	)
	_converted = CSSMathSumFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSNumericValue) Type() (_result *CSSNumericType) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("type", _args[0:_end]...)
	var (
		_converted *CSSNumericType // javascript: CSSNumericType _what_return_name
	)
	_converted = CSSNumericTypeFromJS(_returned)
	_result = _converted
	return
}

// class: CSSPerspective
type CSSPerspective struct {
	CSSTransformComponent
}

// CSSPerspectiveFromJS is casting a js.Value into CSSPerspective.
func CSSPerspectiveFromJS(value js.Value) *CSSPerspective {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSPerspective{}
	ret.Value_JS = value
	return ret
}

// CSSPerspectiveFromJS is casting from something that holds a js.Value into CSSPerspective.
func CSSPerspectiveFromWrapper(input core.Wrapper) *CSSPerspective {
	return CSSPerspectiveFromJS(input.JSValue())
}

func NewCSSPerspective(length *CSSNumericValue) (_result *CSSPerspective) {
	_klass := js.Global().Get("CSSPerspective")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := length.JSValue()
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSPerspective // javascript: CSSPerspective _what_return_name
	)
	_converted = CSSPerspectiveFromJS(_returned)
	_result = _converted
	return
}

// Length returning attribute 'length' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSPerspective) Length() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("length")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// SetLength setting attribute 'length' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSPerspective) SetLength(value *CSSNumericValue) {
	input := value.JSValue()
	_this.Value_JS.Set("length", input)
}

// class: CSSRotate
type CSSRotate struct {
	CSSTransformComponent
}

// CSSRotateFromJS is casting a js.Value into CSSRotate.
func CSSRotateFromJS(value js.Value) *CSSRotate {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSRotate{}
	ret.Value_JS = value
	return ret
}

// CSSRotateFromJS is casting from something that holds a js.Value into CSSRotate.
func CSSRotateFromWrapper(input core.Wrapper) *CSSRotate {
	return CSSRotateFromJS(input.JSValue())
}

func NewCSSRotate(x *Union, y *Union, z *Union, angle *CSSNumericValue) (_result *CSSRotate) {
	_klass := js.Global().Get("CSSRotate")
	var (
		_args [4]interface{}
		_end  int
	)
	_p0 := x.JSValue()
	_args[0] = _p0
	_end++
	_p1 := y.JSValue()
	_args[1] = _p1
	_end++
	_p2 := z.JSValue()
	_args[2] = _p2
	_end++
	_p3 := angle.JSValue()
	_args[3] = _p3
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSRotate // javascript: CSSRotate _what_return_name
	)
	_converted = CSSRotateFromJS(_returned)
	_result = _converted
	return
}

// X returning attribute 'x' with
// type Union (idl: Union).
func (_this *CSSRotate) X() *Union {
	var ret *Union
	value := _this.Value_JS.Get("x")
	ret = UnionFromJS(value)
	return ret
}

// SetX setting attribute 'x' with
// type Union (idl: Union).
func (_this *CSSRotate) SetX(value *Union) {
	input := value.JSValue()
	_this.Value_JS.Set("x", input)
}

// Y returning attribute 'y' with
// type Union (idl: Union).
func (_this *CSSRotate) Y() *Union {
	var ret *Union
	value := _this.Value_JS.Get("y")
	ret = UnionFromJS(value)
	return ret
}

// SetY setting attribute 'y' with
// type Union (idl: Union).
func (_this *CSSRotate) SetY(value *Union) {
	input := value.JSValue()
	_this.Value_JS.Set("y", input)
}

// Z returning attribute 'z' with
// type Union (idl: Union).
func (_this *CSSRotate) Z() *Union {
	var ret *Union
	value := _this.Value_JS.Get("z")
	ret = UnionFromJS(value)
	return ret
}

// SetZ setting attribute 'z' with
// type Union (idl: Union).
func (_this *CSSRotate) SetZ(value *Union) {
	input := value.JSValue()
	_this.Value_JS.Set("z", input)
}

// Angle returning attribute 'angle' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSRotate) Angle() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("angle")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// SetAngle setting attribute 'angle' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSRotate) SetAngle(value *CSSNumericValue) {
	input := value.JSValue()
	_this.Value_JS.Set("angle", input)
}

// class: CSSScale
type CSSScale struct {
	CSSTransformComponent
}

// CSSScaleFromJS is casting a js.Value into CSSScale.
func CSSScaleFromJS(value js.Value) *CSSScale {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSScale{}
	ret.Value_JS = value
	return ret
}

// CSSScaleFromJS is casting from something that holds a js.Value into CSSScale.
func CSSScaleFromWrapper(input core.Wrapper) *CSSScale {
	return CSSScaleFromJS(input.JSValue())
}

func NewCSSScale(x *Union, y *Union, z *Union) (_result *CSSScale) {
	_klass := js.Global().Get("CSSScale")
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := x.JSValue()
	_args[0] = _p0
	_end++
	_p1 := y.JSValue()
	_args[1] = _p1
	_end++
	if z != nil {
		_p2 := z.JSValue()
		_args[2] = _p2
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSScale // javascript: CSSScale _what_return_name
	)
	_converted = CSSScaleFromJS(_returned)
	_result = _converted
	return
}

// X returning attribute 'x' with
// type Union (idl: Union).
func (_this *CSSScale) X() *Union {
	var ret *Union
	value := _this.Value_JS.Get("x")
	ret = UnionFromJS(value)
	return ret
}

// SetX setting attribute 'x' with
// type Union (idl: Union).
func (_this *CSSScale) SetX(value *Union) {
	input := value.JSValue()
	_this.Value_JS.Set("x", input)
}

// Y returning attribute 'y' with
// type Union (idl: Union).
func (_this *CSSScale) Y() *Union {
	var ret *Union
	value := _this.Value_JS.Get("y")
	ret = UnionFromJS(value)
	return ret
}

// SetY setting attribute 'y' with
// type Union (idl: Union).
func (_this *CSSScale) SetY(value *Union) {
	input := value.JSValue()
	_this.Value_JS.Set("y", input)
}

// Z returning attribute 'z' with
// type Union (idl: Union).
func (_this *CSSScale) Z() *Union {
	var ret *Union
	value := _this.Value_JS.Get("z")
	ret = UnionFromJS(value)
	return ret
}

// SetZ setting attribute 'z' with
// type Union (idl: Union).
func (_this *CSSScale) SetZ(value *Union) {
	input := value.JSValue()
	_this.Value_JS.Set("z", input)
}

// class: CSSSkew
type CSSSkew struct {
	CSSTransformComponent
}

// CSSSkewFromJS is casting a js.Value into CSSSkew.
func CSSSkewFromJS(value js.Value) *CSSSkew {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSSkew{}
	ret.Value_JS = value
	return ret
}

// CSSSkewFromJS is casting from something that holds a js.Value into CSSSkew.
func CSSSkewFromWrapper(input core.Wrapper) *CSSSkew {
	return CSSSkewFromJS(input.JSValue())
}

func NewCSSSkew(ax *CSSNumericValue, ay *CSSNumericValue) (_result *CSSSkew) {
	_klass := js.Global().Get("CSSSkew")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := ax.JSValue()
	_args[0] = _p0
	_end++
	_p1 := ay.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSSkew // javascript: CSSSkew _what_return_name
	)
	_converted = CSSSkewFromJS(_returned)
	_result = _converted
	return
}

// Ax returning attribute 'ax' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSSkew) Ax() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("ax")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// SetAx setting attribute 'ax' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSSkew) SetAx(value *CSSNumericValue) {
	input := value.JSValue()
	_this.Value_JS.Set("ax", input)
}

// Ay returning attribute 'ay' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSSkew) Ay() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("ay")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// SetAy setting attribute 'ay' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSSkew) SetAy(value *CSSNumericValue) {
	input := value.JSValue()
	_this.Value_JS.Set("ay", input)
}

// class: CSSSkewX
type CSSSkewX struct {
	CSSTransformComponent
}

// CSSSkewXFromJS is casting a js.Value into CSSSkewX.
func CSSSkewXFromJS(value js.Value) *CSSSkewX {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSSkewX{}
	ret.Value_JS = value
	return ret
}

// CSSSkewXFromJS is casting from something that holds a js.Value into CSSSkewX.
func CSSSkewXFromWrapper(input core.Wrapper) *CSSSkewX {
	return CSSSkewXFromJS(input.JSValue())
}

func NewCSSSkewX(ax *CSSNumericValue) (_result *CSSSkewX) {
	_klass := js.Global().Get("CSSSkewX")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := ax.JSValue()
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSSkewX // javascript: CSSSkewX _what_return_name
	)
	_converted = CSSSkewXFromJS(_returned)
	_result = _converted
	return
}

// Ax returning attribute 'ax' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSSkewX) Ax() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("ax")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// SetAx setting attribute 'ax' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSSkewX) SetAx(value *CSSNumericValue) {
	input := value.JSValue()
	_this.Value_JS.Set("ax", input)
}

// class: CSSSkewY
type CSSSkewY struct {
	CSSTransformComponent
}

// CSSSkewYFromJS is casting a js.Value into CSSSkewY.
func CSSSkewYFromJS(value js.Value) *CSSSkewY {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSSkewY{}
	ret.Value_JS = value
	return ret
}

// CSSSkewYFromJS is casting from something that holds a js.Value into CSSSkewY.
func CSSSkewYFromWrapper(input core.Wrapper) *CSSSkewY {
	return CSSSkewYFromJS(input.JSValue())
}

func NewCSSSkewY(ay *CSSNumericValue) (_result *CSSSkewY) {
	_klass := js.Global().Get("CSSSkewY")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := ay.JSValue()
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSSkewY // javascript: CSSSkewY _what_return_name
	)
	_converted = CSSSkewYFromJS(_returned)
	_result = _converted
	return
}

// Ay returning attribute 'ay' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSSkewY) Ay() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("ay")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// SetAy setting attribute 'ay' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSSkewY) SetAy(value *CSSNumericValue) {
	input := value.JSValue()
	_this.Value_JS.Set("ay", input)
}

// class: CSSStyleValue
type CSSStyleValue struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *CSSStyleValue) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// CSSStyleValueFromJS is casting a js.Value into CSSStyleValue.
func CSSStyleValueFromJS(value js.Value) *CSSStyleValue {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSStyleValue{}
	ret.Value_JS = value
	return ret
}

// CSSStyleValueFromJS is casting from something that holds a js.Value into CSSStyleValue.
func CSSStyleValueFromWrapper(input core.Wrapper) *CSSStyleValue {
	return CSSStyleValueFromJS(input.JSValue())
}

func Parse2(property string, cssText string) (_result *CSSStyleValue) {
	_klass := js.Global().Get("CSSStyleValue")
	_method := _klass.Get("parse")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := property
	_args[0] = _p0
	_end++
	_p1 := cssText
	_args[1] = _p1
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted *CSSStyleValue // javascript: CSSStyleValue _what_return_name
	)
	_converted = CSSStyleValueFromJS(_returned)
	_result = _converted
	return
}

func ParseAll(property string, cssText string) (_result []*CSSStyleValue) {
	_klass := js.Global().Get("CSSStyleValue")
	_method := _klass.Get("parseAll")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := property
	_args[0] = _p0
	_end++
	_p1 := cssText
	_args[1] = _p1
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted []*CSSStyleValue // javascript: sequence<CSSStyleValue> _what_return_name
	)
	__length0 := _returned.Length()
	__array0 := make([]*CSSStyleValue, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *CSSStyleValue
		__seq_in0 := _returned.Index(__idx0)
		__seq_out0 = CSSStyleValueFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	_converted = __array0
	_result = _converted
	return
}

func (_this *CSSStyleValue) ToString() (_result string) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("toString", _args[0:_end]...)
	var (
		_converted string // javascript: USVString _what_return_name
	)
	_converted = (_returned).String()
	_result = _converted
	return
}

// class: CSSTransformComponent
type CSSTransformComponent struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *CSSTransformComponent) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// CSSTransformComponentFromJS is casting a js.Value into CSSTransformComponent.
func CSSTransformComponentFromJS(value js.Value) *CSSTransformComponent {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSTransformComponent{}
	ret.Value_JS = value
	return ret
}

// CSSTransformComponentFromJS is casting from something that holds a js.Value into CSSTransformComponent.
func CSSTransformComponentFromWrapper(input core.Wrapper) *CSSTransformComponent {
	return CSSTransformComponentFromJS(input.JSValue())
}

// Is2D returning attribute 'is2D' with
// type bool (idl: boolean).
func (_this *CSSTransformComponent) Is2D() bool {
	var ret bool
	value := _this.Value_JS.Get("is2D")
	ret = (value).Bool()
	return ret
}

// SetIs2D setting attribute 'is2D' with
// type bool (idl: boolean).
func (_this *CSSTransformComponent) SetIs2D(value bool) {
	input := value
	_this.Value_JS.Set("is2D", input)
}

func (_this *CSSTransformComponent) ToMatrix() (_result *geometry.DOMMatrix) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("toMatrix", _args[0:_end]...)
	var (
		_converted *geometry.DOMMatrix // javascript: DOMMatrix _what_return_name
	)
	_converted = geometry.DOMMatrixFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSTransformComponent) ToString() (_result string) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("toString", _args[0:_end]...)
	var (
		_converted string // javascript: USVString _what_return_name
	)
	_converted = (_returned).String()
	_result = _converted
	return
}

// class: CSSTransformValue
type CSSTransformValue struct {
	CSSStyleValue
}

// CSSTransformValueFromJS is casting a js.Value into CSSTransformValue.
func CSSTransformValueFromJS(value js.Value) *CSSTransformValue {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSTransformValue{}
	ret.Value_JS = value
	return ret
}

// CSSTransformValueFromJS is casting from something that holds a js.Value into CSSTransformValue.
func CSSTransformValueFromWrapper(input core.Wrapper) *CSSTransformValue {
	return CSSTransformValueFromJS(input.JSValue())
}

func NewCSSTransformValue(transforms []*CSSTransformComponent) (_result *CSSTransformValue) {
	_klass := js.Global().Get("CSSTransformValue")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := js.Global().Get("Array").New(len(transforms))
	for __idx0, __seq_in0 := range transforms {
		__seq_out0 := __seq_in0.JSValue()
		_p0.SetIndex(__idx0, __seq_out0)
	}
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSTransformValue // javascript: CSSTransformValue _what_return_name
	)
	_converted = CSSTransformValueFromJS(_returned)
	_result = _converted
	return
}

// Length returning attribute 'length' with
// type uint (idl: unsigned long).
func (_this *CSSTransformValue) Length() uint {
	var ret uint
	value := _this.Value_JS.Get("length")
	ret = (uint)((value).Int())
	return ret
}

// Is2D returning attribute 'is2D' with
// type bool (idl: boolean).
func (_this *CSSTransformValue) Is2D() bool {
	var ret bool
	value := _this.Value_JS.Get("is2D")
	ret = (value).Bool()
	return ret
}

func (_this *CSSTransformValue) Index(index uint) (_result *CSSTransformComponent) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := index
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("", _args[0:_end]...)
	var (
		_converted *CSSTransformComponent // javascript: CSSTransformComponent _what_return_name
	)
	_converted = CSSTransformComponentFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSTransformValue) SetIndex(index uint, val *CSSTransformComponent) (_result *CSSTransformComponent) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := index
	_args[0] = _p0
	_end++
	_p1 := val.JSValue()
	_args[1] = _p1
	_end++
	_returned := _this.Value_JS.Call("", _args[0:_end]...)
	var (
		_converted *CSSTransformComponent // javascript: CSSTransformComponent _what_return_name
	)
	_converted = CSSTransformComponentFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSTransformValue) ToMatrix() (_result *geometry.DOMMatrix) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("toMatrix", _args[0:_end]...)
	var (
		_converted *geometry.DOMMatrix // javascript: DOMMatrix _what_return_name
	)
	_converted = geometry.DOMMatrixFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSTransformValue) Entries() (_result *CSSTransformValueEntryIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("entries", _args[0:_end]...)
	var (
		_converted *CSSTransformValueEntryIterator // javascript: CSSTransformValueEntryIterator _what_return_name
	)
	_converted = CSSTransformValueEntryIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSTransformValue) ForEach(callback *CSSTransformValueForEach, optionalThisForCallbackArgument interface{}) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if callback != nil {
		__callback0 = (*callback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if optionalThisForCallbackArgument != nil {
		_p1 := optionalThisForCallbackArgument
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("forEach", _args[0:_end]...)
	return
}

func (_this *CSSTransformValue) Keys() (_result *CSSTransformValueKeyIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("keys", _args[0:_end]...)
	var (
		_converted *CSSTransformValueKeyIterator // javascript: CSSTransformValueKeyIterator _what_return_name
	)
	_converted = CSSTransformValueKeyIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSTransformValue) Values() (_result *CSSTransformValueValueIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("values", _args[0:_end]...)
	var (
		_converted *CSSTransformValueValueIterator // javascript: CSSTransformValueValueIterator _what_return_name
	)
	_converted = CSSTransformValueValueIteratorFromJS(_returned)
	_result = _converted
	return
}

// class: CSSTransformValueEntryIterator
type CSSTransformValueEntryIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *CSSTransformValueEntryIterator) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// CSSTransformValueEntryIteratorFromJS is casting a js.Value into CSSTransformValueEntryIterator.
func CSSTransformValueEntryIteratorFromJS(value js.Value) *CSSTransformValueEntryIterator {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSTransformValueEntryIterator{}
	ret.Value_JS = value
	return ret
}

// CSSTransformValueEntryIteratorFromJS is casting from something that holds a js.Value into CSSTransformValueEntryIterator.
func CSSTransformValueEntryIteratorFromWrapper(input core.Wrapper) *CSSTransformValueEntryIterator {
	return CSSTransformValueEntryIteratorFromJS(input.JSValue())
}

func (_this *CSSTransformValueEntryIterator) Next() (_result *CSSTransformValueEntryIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *CSSTransformValueEntryIteratorValue // javascript: CSSTransformValueEntryIteratorValue _what_return_name
	)
	_converted = CSSTransformValueEntryIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: CSSTransformValueKeyIterator
type CSSTransformValueKeyIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *CSSTransformValueKeyIterator) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// CSSTransformValueKeyIteratorFromJS is casting a js.Value into CSSTransformValueKeyIterator.
func CSSTransformValueKeyIteratorFromJS(value js.Value) *CSSTransformValueKeyIterator {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSTransformValueKeyIterator{}
	ret.Value_JS = value
	return ret
}

// CSSTransformValueKeyIteratorFromJS is casting from something that holds a js.Value into CSSTransformValueKeyIterator.
func CSSTransformValueKeyIteratorFromWrapper(input core.Wrapper) *CSSTransformValueKeyIterator {
	return CSSTransformValueKeyIteratorFromJS(input.JSValue())
}

func (_this *CSSTransformValueKeyIterator) Next() (_result *CSSTransformValueKeyIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *CSSTransformValueKeyIteratorValue // javascript: CSSTransformValueKeyIteratorValue _what_return_name
	)
	_converted = CSSTransformValueKeyIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: CSSTransformValueValueIterator
type CSSTransformValueValueIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *CSSTransformValueValueIterator) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// CSSTransformValueValueIteratorFromJS is casting a js.Value into CSSTransformValueValueIterator.
func CSSTransformValueValueIteratorFromJS(value js.Value) *CSSTransformValueValueIterator {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSTransformValueValueIterator{}
	ret.Value_JS = value
	return ret
}

// CSSTransformValueValueIteratorFromJS is casting from something that holds a js.Value into CSSTransformValueValueIterator.
func CSSTransformValueValueIteratorFromWrapper(input core.Wrapper) *CSSTransformValueValueIterator {
	return CSSTransformValueValueIteratorFromJS(input.JSValue())
}

func (_this *CSSTransformValueValueIterator) Next() (_result *CSSTransformValueValueIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *CSSTransformValueValueIteratorValue // javascript: CSSTransformValueValueIteratorValue _what_return_name
	)
	_converted = CSSTransformValueValueIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: CSSTranslate
type CSSTranslate struct {
	CSSTransformComponent
}

// CSSTranslateFromJS is casting a js.Value into CSSTranslate.
func CSSTranslateFromJS(value js.Value) *CSSTranslate {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSTranslate{}
	ret.Value_JS = value
	return ret
}

// CSSTranslateFromJS is casting from something that holds a js.Value into CSSTranslate.
func CSSTranslateFromWrapper(input core.Wrapper) *CSSTranslate {
	return CSSTranslateFromJS(input.JSValue())
}

func NewCSSTranslate(x *CSSNumericValue, y *CSSNumericValue, z *CSSNumericValue) (_result *CSSTranslate) {
	_klass := js.Global().Get("CSSTranslate")
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := x.JSValue()
	_args[0] = _p0
	_end++
	_p1 := y.JSValue()
	_args[1] = _p1
	_end++
	if z != nil {
		_p2 := z.JSValue()
		_args[2] = _p2
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSTranslate // javascript: CSSTranslate _what_return_name
	)
	_converted = CSSTranslateFromJS(_returned)
	_result = _converted
	return
}

// X returning attribute 'x' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSTranslate) X() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("x")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// SetX setting attribute 'x' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSTranslate) SetX(value *CSSNumericValue) {
	input := value.JSValue()
	_this.Value_JS.Set("x", input)
}

// Y returning attribute 'y' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSTranslate) Y() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("y")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// SetY setting attribute 'y' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSTranslate) SetY(value *CSSNumericValue) {
	input := value.JSValue()
	_this.Value_JS.Set("y", input)
}

// Z returning attribute 'z' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSTranslate) Z() *CSSNumericValue {
	var ret *CSSNumericValue
	value := _this.Value_JS.Get("z")
	ret = CSSNumericValueFromJS(value)
	return ret
}

// SetZ setting attribute 'z' with
// type CSSNumericValue (idl: CSSNumericValue).
func (_this *CSSTranslate) SetZ(value *CSSNumericValue) {
	input := value.JSValue()
	_this.Value_JS.Set("z", input)
}

// class: CSSUnitValue
type CSSUnitValue struct {
	CSSNumericValue
}

// CSSUnitValueFromJS is casting a js.Value into CSSUnitValue.
func CSSUnitValueFromJS(value js.Value) *CSSUnitValue {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSUnitValue{}
	ret.Value_JS = value
	return ret
}

// CSSUnitValueFromJS is casting from something that holds a js.Value into CSSUnitValue.
func CSSUnitValueFromWrapper(input core.Wrapper) *CSSUnitValue {
	return CSSUnitValueFromJS(input.JSValue())
}

func NewCSSUnitValue(value float64, unit string) (_result *CSSUnitValue) {
	_klass := js.Global().Get("CSSUnitValue")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := value
	_args[0] = _p0
	_end++
	_p1 := unit
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSUnitValue // javascript: CSSUnitValue _what_return_name
	)
	_converted = CSSUnitValueFromJS(_returned)
	_result = _converted
	return
}

// Value returning attribute 'value' with
// type float64 (idl: double).
func (_this *CSSUnitValue) Value() float64 {
	var ret float64
	value := _this.Value_JS.Get("value")
	ret = (value).Float()
	return ret
}

// SetValue setting attribute 'value' with
// type float64 (idl: double).
func (_this *CSSUnitValue) SetValue(value float64) {
	input := value
	_this.Value_JS.Set("value", input)
}

// Unit returning attribute 'unit' with
// type string (idl: USVString).
func (_this *CSSUnitValue) Unit() string {
	var ret string
	value := _this.Value_JS.Get("unit")
	ret = (value).String()
	return ret
}

// class: CSSUnparsedValue
type CSSUnparsedValue struct {
	CSSStyleValue
}

// CSSUnparsedValueFromJS is casting a js.Value into CSSUnparsedValue.
func CSSUnparsedValueFromJS(value js.Value) *CSSUnparsedValue {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSUnparsedValue{}
	ret.Value_JS = value
	return ret
}

// CSSUnparsedValueFromJS is casting from something that holds a js.Value into CSSUnparsedValue.
func CSSUnparsedValueFromWrapper(input core.Wrapper) *CSSUnparsedValue {
	return CSSUnparsedValueFromJS(input.JSValue())
}

func NewCSSUnparsedValue(members []*Union) (_result *CSSUnparsedValue) {
	_klass := js.Global().Get("CSSUnparsedValue")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := js.Global().Get("Array").New(len(members))
	for __idx0, __seq_in0 := range members {
		__seq_out0 := __seq_in0.JSValue()
		_p0.SetIndex(__idx0, __seq_out0)
	}
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSUnparsedValue // javascript: CSSUnparsedValue _what_return_name
	)
	_converted = CSSUnparsedValueFromJS(_returned)
	_result = _converted
	return
}

// Length returning attribute 'length' with
// type uint (idl: unsigned long).
func (_this *CSSUnparsedValue) Length() uint {
	var ret uint
	value := _this.Value_JS.Get("length")
	ret = (uint)((value).Int())
	return ret
}

func (_this *CSSUnparsedValue) Index(index uint) (_result *Union) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := index
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("", _args[0:_end]...)
	var (
		_converted *Union // javascript: Union _what_return_name
	)
	_converted = UnionFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSUnparsedValue) SetIndex(index uint, val *Union) (_result *Union) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := index
	_args[0] = _p0
	_end++
	_p1 := val.JSValue()
	_args[1] = _p1
	_end++
	_returned := _this.Value_JS.Call("", _args[0:_end]...)
	var (
		_converted *Union // javascript: Union _what_return_name
	)
	_converted = UnionFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSUnparsedValue) Entries() (_result *CSSUnparsedValueEntryIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("entries", _args[0:_end]...)
	var (
		_converted *CSSUnparsedValueEntryIterator // javascript: CSSUnparsedValueEntryIterator _what_return_name
	)
	_converted = CSSUnparsedValueEntryIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSUnparsedValue) ForEach(callback *CSSUnparsedValueForEach, optionalThisForCallbackArgument interface{}) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if callback != nil {
		__callback0 = (*callback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if optionalThisForCallbackArgument != nil {
		_p1 := optionalThisForCallbackArgument
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("forEach", _args[0:_end]...)
	return
}

func (_this *CSSUnparsedValue) Keys() (_result *CSSUnparsedValueKeyIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("keys", _args[0:_end]...)
	var (
		_converted *CSSUnparsedValueKeyIterator // javascript: CSSUnparsedValueKeyIterator _what_return_name
	)
	_converted = CSSUnparsedValueKeyIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *CSSUnparsedValue) Values() (_result *CSSUnparsedValueValueIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("values", _args[0:_end]...)
	var (
		_converted *CSSUnparsedValueValueIterator // javascript: CSSUnparsedValueValueIterator _what_return_name
	)
	_converted = CSSUnparsedValueValueIteratorFromJS(_returned)
	_result = _converted
	return
}

// class: CSSUnparsedValueEntryIterator
type CSSUnparsedValueEntryIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *CSSUnparsedValueEntryIterator) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// CSSUnparsedValueEntryIteratorFromJS is casting a js.Value into CSSUnparsedValueEntryIterator.
func CSSUnparsedValueEntryIteratorFromJS(value js.Value) *CSSUnparsedValueEntryIterator {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSUnparsedValueEntryIterator{}
	ret.Value_JS = value
	return ret
}

// CSSUnparsedValueEntryIteratorFromJS is casting from something that holds a js.Value into CSSUnparsedValueEntryIterator.
func CSSUnparsedValueEntryIteratorFromWrapper(input core.Wrapper) *CSSUnparsedValueEntryIterator {
	return CSSUnparsedValueEntryIteratorFromJS(input.JSValue())
}

func (_this *CSSUnparsedValueEntryIterator) Next() (_result *CSSUnparsedValueEntryIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *CSSUnparsedValueEntryIteratorValue // javascript: CSSUnparsedValueEntryIteratorValue _what_return_name
	)
	_converted = CSSUnparsedValueEntryIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: CSSUnparsedValueKeyIterator
type CSSUnparsedValueKeyIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *CSSUnparsedValueKeyIterator) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// CSSUnparsedValueKeyIteratorFromJS is casting a js.Value into CSSUnparsedValueKeyIterator.
func CSSUnparsedValueKeyIteratorFromJS(value js.Value) *CSSUnparsedValueKeyIterator {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSUnparsedValueKeyIterator{}
	ret.Value_JS = value
	return ret
}

// CSSUnparsedValueKeyIteratorFromJS is casting from something that holds a js.Value into CSSUnparsedValueKeyIterator.
func CSSUnparsedValueKeyIteratorFromWrapper(input core.Wrapper) *CSSUnparsedValueKeyIterator {
	return CSSUnparsedValueKeyIteratorFromJS(input.JSValue())
}

func (_this *CSSUnparsedValueKeyIterator) Next() (_result *CSSUnparsedValueKeyIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *CSSUnparsedValueKeyIteratorValue // javascript: CSSUnparsedValueKeyIteratorValue _what_return_name
	)
	_converted = CSSUnparsedValueKeyIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: CSSUnparsedValueValueIterator
type CSSUnparsedValueValueIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *CSSUnparsedValueValueIterator) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// CSSUnparsedValueValueIteratorFromJS is casting a js.Value into CSSUnparsedValueValueIterator.
func CSSUnparsedValueValueIteratorFromJS(value js.Value) *CSSUnparsedValueValueIterator {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSUnparsedValueValueIterator{}
	ret.Value_JS = value
	return ret
}

// CSSUnparsedValueValueIteratorFromJS is casting from something that holds a js.Value into CSSUnparsedValueValueIterator.
func CSSUnparsedValueValueIteratorFromWrapper(input core.Wrapper) *CSSUnparsedValueValueIterator {
	return CSSUnparsedValueValueIteratorFromJS(input.JSValue())
}

func (_this *CSSUnparsedValueValueIterator) Next() (_result *CSSUnparsedValueValueIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *CSSUnparsedValueValueIteratorValue // javascript: CSSUnparsedValueValueIteratorValue _what_return_name
	)
	_converted = CSSUnparsedValueValueIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: CSSVariableReferenceValue
type CSSVariableReferenceValue struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *CSSVariableReferenceValue) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// CSSVariableReferenceValueFromJS is casting a js.Value into CSSVariableReferenceValue.
func CSSVariableReferenceValueFromJS(value js.Value) *CSSVariableReferenceValue {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &CSSVariableReferenceValue{}
	ret.Value_JS = value
	return ret
}

// CSSVariableReferenceValueFromJS is casting from something that holds a js.Value into CSSVariableReferenceValue.
func CSSVariableReferenceValueFromWrapper(input core.Wrapper) *CSSVariableReferenceValue {
	return CSSVariableReferenceValueFromJS(input.JSValue())
}

func NewCSSVariableReferenceValue(variable string, fallback *CSSUnparsedValue) (_result *CSSVariableReferenceValue) {
	_klass := js.Global().Get("CSSVariableReferenceValue")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := variable
	_args[0] = _p0
	_end++
	if fallback != nil {
		_p1 := fallback.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CSSVariableReferenceValue // javascript: CSSVariableReferenceValue _what_return_name
	)
	_converted = CSSVariableReferenceValueFromJS(_returned)
	_result = _converted
	return
}

// Variable returning attribute 'variable' with
// type string (idl: USVString).
func (_this *CSSVariableReferenceValue) Variable() string {
	var ret string
	value := _this.Value_JS.Get("variable")
	ret = (value).String()
	return ret
}

// SetVariable setting attribute 'variable' with
// type string (idl: USVString).
func (_this *CSSVariableReferenceValue) SetVariable(value string) {
	input := value
	_this.Value_JS.Set("variable", input)
}

// Fallback returning attribute 'fallback' with
// type CSSUnparsedValue (idl: CSSUnparsedValue).
func (_this *CSSVariableReferenceValue) Fallback() *CSSUnparsedValue {
	var ret *CSSUnparsedValue
	value := _this.Value_JS.Get("fallback")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = CSSUnparsedValueFromJS(value)
	}
	return ret
}

// class: StylePropertyMap
type StylePropertyMap struct {
	StylePropertyMapReadOnly
}

// StylePropertyMapFromJS is casting a js.Value into StylePropertyMap.
func StylePropertyMapFromJS(value js.Value) *StylePropertyMap {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &StylePropertyMap{}
	ret.Value_JS = value
	return ret
}

// StylePropertyMapFromJS is casting from something that holds a js.Value into StylePropertyMap.
func StylePropertyMapFromWrapper(input core.Wrapper) *StylePropertyMap {
	return StylePropertyMapFromJS(input.JSValue())
}

func (_this *StylePropertyMap) Set(property string, values ...*Union) {
	var (
		_args []interface{} = make([]interface{}, 1+len(values))
		_end  int
	)
	_p0 := property
	_args[0] = _p0
	_end++
	for _, __in := range values {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_this.Value_JS.Call("set", _args[0:_end]...)
	return
}

func (_this *StylePropertyMap) Append(property string, values ...*Union) {
	var (
		_args []interface{} = make([]interface{}, 1+len(values))
		_end  int
	)
	_p0 := property
	_args[0] = _p0
	_end++
	for _, __in := range values {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_this.Value_JS.Call("append", _args[0:_end]...)
	return
}

func (_this *StylePropertyMap) Delete(property string) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := property
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("delete", _args[0:_end]...)
	return
}

func (_this *StylePropertyMap) Clear() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("clear", _args[0:_end]...)
	return
}

// class: StylePropertyMapReadOnly
type StylePropertyMapReadOnly struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *StylePropertyMapReadOnly) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// StylePropertyMapReadOnlyFromJS is casting a js.Value into StylePropertyMapReadOnly.
func StylePropertyMapReadOnlyFromJS(value js.Value) *StylePropertyMapReadOnly {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &StylePropertyMapReadOnly{}
	ret.Value_JS = value
	return ret
}

// StylePropertyMapReadOnlyFromJS is casting from something that holds a js.Value into StylePropertyMapReadOnly.
func StylePropertyMapReadOnlyFromWrapper(input core.Wrapper) *StylePropertyMapReadOnly {
	return StylePropertyMapReadOnlyFromJS(input.JSValue())
}

// Size returning attribute 'size' with
// type uint (idl: unsigned long).
func (_this *StylePropertyMapReadOnly) Size() uint {
	var ret uint
	value := _this.Value_JS.Get("size")
	ret = (uint)((value).Int())
	return ret
}

func (_this *StylePropertyMapReadOnly) Get(property string) (_result js.Value) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := property
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("get", _args[0:_end]...)
	var (
		_converted js.Value // javascript: any _what_return_name
	)
	_converted = _returned
	_result = _converted
	return
}

func (_this *StylePropertyMapReadOnly) GetAll(property string) (_result []*CSSStyleValue) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := property
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("getAll", _args[0:_end]...)
	var (
		_converted []*CSSStyleValue // javascript: sequence<CSSStyleValue> _what_return_name
	)
	__length0 := _returned.Length()
	__array0 := make([]*CSSStyleValue, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *CSSStyleValue
		__seq_in0 := _returned.Index(__idx0)
		__seq_out0 = CSSStyleValueFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	_converted = __array0
	_result = _converted
	return
}

func (_this *StylePropertyMapReadOnly) Has(property string) (_result bool) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := property
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("has", _args[0:_end]...)
	var (
		_converted bool // javascript: boolean _what_return_name
	)
	_converted = (_returned).Bool()
	_result = _converted
	return
}

func (_this *StylePropertyMapReadOnly) Entries() (_result *StylePropertyMapReadOnlyEntryIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("entries", _args[0:_end]...)
	var (
		_converted *StylePropertyMapReadOnlyEntryIterator // javascript: StylePropertyMapReadOnlyEntryIterator _what_return_name
	)
	_converted = StylePropertyMapReadOnlyEntryIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *StylePropertyMapReadOnly) ForEach(callback *StylePropertyMapReadOnlyForEach, optionalThisForCallbackArgument interface{}) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if callback != nil {
		__callback0 = (*callback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if optionalThisForCallbackArgument != nil {
		_p1 := optionalThisForCallbackArgument
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("forEach", _args[0:_end]...)
	return
}

func (_this *StylePropertyMapReadOnly) Keys() (_result *StylePropertyMapReadOnlyKeyIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("keys", _args[0:_end]...)
	var (
		_converted *StylePropertyMapReadOnlyKeyIterator // javascript: StylePropertyMapReadOnlyKeyIterator _what_return_name
	)
	_converted = StylePropertyMapReadOnlyKeyIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *StylePropertyMapReadOnly) Values() (_result *StylePropertyMapReadOnlyValueIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("values", _args[0:_end]...)
	var (
		_converted *StylePropertyMapReadOnlyValueIterator // javascript: StylePropertyMapReadOnlyValueIterator _what_return_name
	)
	_converted = StylePropertyMapReadOnlyValueIteratorFromJS(_returned)
	_result = _converted
	return
}

// class: StylePropertyMapReadOnlyEntryIterator
type StylePropertyMapReadOnlyEntryIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *StylePropertyMapReadOnlyEntryIterator) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// StylePropertyMapReadOnlyEntryIteratorFromJS is casting a js.Value into StylePropertyMapReadOnlyEntryIterator.
func StylePropertyMapReadOnlyEntryIteratorFromJS(value js.Value) *StylePropertyMapReadOnlyEntryIterator {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &StylePropertyMapReadOnlyEntryIterator{}
	ret.Value_JS = value
	return ret
}

// StylePropertyMapReadOnlyEntryIteratorFromJS is casting from something that holds a js.Value into StylePropertyMapReadOnlyEntryIterator.
func StylePropertyMapReadOnlyEntryIteratorFromWrapper(input core.Wrapper) *StylePropertyMapReadOnlyEntryIterator {
	return StylePropertyMapReadOnlyEntryIteratorFromJS(input.JSValue())
}

func (_this *StylePropertyMapReadOnlyEntryIterator) Next() (_result *StylePropertyMapReadOnlyEntryIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *StylePropertyMapReadOnlyEntryIteratorValue // javascript: StylePropertyMapReadOnlyEntryIteratorValue _what_return_name
	)
	_converted = StylePropertyMapReadOnlyEntryIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: StylePropertyMapReadOnlyKeyIterator
type StylePropertyMapReadOnlyKeyIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *StylePropertyMapReadOnlyKeyIterator) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// StylePropertyMapReadOnlyKeyIteratorFromJS is casting a js.Value into StylePropertyMapReadOnlyKeyIterator.
func StylePropertyMapReadOnlyKeyIteratorFromJS(value js.Value) *StylePropertyMapReadOnlyKeyIterator {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &StylePropertyMapReadOnlyKeyIterator{}
	ret.Value_JS = value
	return ret
}

// StylePropertyMapReadOnlyKeyIteratorFromJS is casting from something that holds a js.Value into StylePropertyMapReadOnlyKeyIterator.
func StylePropertyMapReadOnlyKeyIteratorFromWrapper(input core.Wrapper) *StylePropertyMapReadOnlyKeyIterator {
	return StylePropertyMapReadOnlyKeyIteratorFromJS(input.JSValue())
}

func (_this *StylePropertyMapReadOnlyKeyIterator) Next() (_result *StylePropertyMapReadOnlyKeyIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *StylePropertyMapReadOnlyKeyIteratorValue // javascript: StylePropertyMapReadOnlyKeyIteratorValue _what_return_name
	)
	_converted = StylePropertyMapReadOnlyKeyIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: StylePropertyMapReadOnlyValueIterator
type StylePropertyMapReadOnlyValueIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *StylePropertyMapReadOnlyValueIterator) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// StylePropertyMapReadOnlyValueIteratorFromJS is casting a js.Value into StylePropertyMapReadOnlyValueIterator.
func StylePropertyMapReadOnlyValueIteratorFromJS(value js.Value) *StylePropertyMapReadOnlyValueIterator {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &StylePropertyMapReadOnlyValueIterator{}
	ret.Value_JS = value
	return ret
}

// StylePropertyMapReadOnlyValueIteratorFromJS is casting from something that holds a js.Value into StylePropertyMapReadOnlyValueIterator.
func StylePropertyMapReadOnlyValueIteratorFromWrapper(input core.Wrapper) *StylePropertyMapReadOnlyValueIterator {
	return StylePropertyMapReadOnlyValueIteratorFromJS(input.JSValue())
}

func (_this *StylePropertyMapReadOnlyValueIterator) Next() (_result *StylePropertyMapReadOnlyValueIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *StylePropertyMapReadOnlyValueIteratorValue // javascript: StylePropertyMapReadOnlyValueIteratorValue _what_return_name
	)
	_converted = StylePropertyMapReadOnlyValueIteratorValueFromJS(_returned)
	_result = _converted
	return
}
