// Code generated by webidl-bind. DO NOT EDIT.

// +build !js

package midi

import js "github.com/gowebapi/webapi/core/js"

import (
	"github.com/gowebapi/webapi/core"
	"github.com/gowebapi/webapi/dom/domcore"
	"github.com/gowebapi/webapi/javascript"
)

// using following types:
// domcore.Event
// domcore.EventHandler
// domcore.EventTarget
// javascript.PromiseFinally
// javascript.Uint8Array

// source idl files:
// promises.idl
// webmidi.idl

// transform files:
// promises.go.md
// webmidi.go.md

// workaround for compiler error
func unused(value interface{}) {
	// TODO remove this method
}

type Union struct {
	Value js.Value
}

func (u *Union) JSValue() js.Value {
	return u.Value
}

func UnionFromJS(value js.Value) *Union {
	return &Union{Value: value}
}

// enum: MIDIPortConnectionState
type PortConnectionState int

const (
	Open PortConnectionState = iota
	Closed
	Pending
)

var mIDIPortConnectionStateToWasmTable = []string{
	"open", "closed", "pending",
}

var mIDIPortConnectionStateFromWasmTable = map[string]PortConnectionState{
	"open": Open, "closed": Closed, "pending": Pending,
}

// JSValue is converting this enum into a javascript object
func (this *PortConnectionState) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this PortConnectionState) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(mIDIPortConnectionStateToWasmTable) {
		return mIDIPortConnectionStateToWasmTable[idx]
	}
	panic("unknown input value")
}

// PortConnectionStateFromJS is converting a javascript value into
// a PortConnectionState enum value.
func PortConnectionStateFromJS(value js.Value) PortConnectionState {
	key := value.String()
	conv, ok := mIDIPortConnectionStateFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: MIDIPortDeviceState
type PortDeviceState int

const (
	Disconnected PortDeviceState = iota
	Connected
)

var mIDIPortDeviceStateToWasmTable = []string{
	"disconnected", "connected",
}

var mIDIPortDeviceStateFromWasmTable = map[string]PortDeviceState{
	"disconnected": Disconnected, "connected": Connected,
}

// JSValue is converting this enum into a javascript object
func (this *PortDeviceState) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this PortDeviceState) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(mIDIPortDeviceStateToWasmTable) {
		return mIDIPortDeviceStateToWasmTable[idx]
	}
	panic("unknown input value")
}

// PortDeviceStateFromJS is converting a javascript value into
// a PortDeviceState enum value.
func PortDeviceStateFromJS(value js.Value) PortDeviceState {
	key := value.String()
	conv, ok := mIDIPortDeviceStateFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: MIDIPortType
type PortType int

const (
	InputPort PortType = iota
	OutputPort
)

var mIDIPortTypeToWasmTable = []string{
	"input", "output",
}

var mIDIPortTypeFromWasmTable = map[string]PortType{
	"input": InputPort, "output": OutputPort,
}

// JSValue is converting this enum into a javascript object
func (this *PortType) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this PortType) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(mIDIPortTypeToWasmTable) {
		return mIDIPortTypeToWasmTable[idx]
	}
	panic("unknown input value")
}

// PortTypeFromJS is converting a javascript value into
// a PortType enum value.
func PortTypeFromJS(value js.Value) PortType {
	key := value.String()
	conv, ok := mIDIPortTypeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// callback: MIDIInputMapForEach
type InputMapForEachFunc func(currentValue *Input, currentKey string, listObj *InputMap)

// InputMapForEach is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type InputMapForEach js.Func

func InputMapForEachToJS(callback InputMapForEachFunc) *InputMapForEach {
	if callback == nil {
		return nil
	}
	ret := InputMapForEach(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *Input    // javascript: MIDIInput currentValue
			_p1 string    // javascript: DOMString currentKey
			_p2 *InputMap // javascript: MIDIInputMap listObj
		)
		_p0 = InputFromJS(args[0])
		_p1 = (args[1]).String()
		_p2 = InputMapFromJS(args[2])
		callback(_p0, _p1, _p2)

		// returning no return value
		return nil
	}))
	return &ret
}

func InputMapForEachFromJS(_value js.Value) InputMapForEachFunc {
	return func(currentValue *Input, currentKey string, listObj *InputMap) {
		var (
			_args [3]interface{}
			_end  int
		)
		_p0 := currentValue.JSValue()
		_args[0] = _p0
		_end++
		_p1 := currentKey
		_args[1] = _p1
		_end++
		_p2 := listObj.JSValue()
		_args[2] = _p2
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: MIDIOutputMapForEach
type OutputMapForEachFunc func(currentValue *Output, currentKey string, listObj *OutputMap)

// OutputMapForEach is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type OutputMapForEach js.Func

func OutputMapForEachToJS(callback OutputMapForEachFunc) *OutputMapForEach {
	if callback == nil {
		return nil
	}
	ret := OutputMapForEach(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *Output    // javascript: MIDIOutput currentValue
			_p1 string     // javascript: DOMString currentKey
			_p2 *OutputMap // javascript: MIDIOutputMap listObj
		)
		_p0 = OutputFromJS(args[0])
		_p1 = (args[1]).String()
		_p2 = OutputMapFromJS(args[2])
		callback(_p0, _p1, _p2)

		// returning no return value
		return nil
	}))
	return &ret
}

func OutputMapForEachFromJS(_value js.Value) OutputMapForEachFunc {
	return func(currentValue *Output, currentKey string, listObj *OutputMap) {
		var (
			_args [3]interface{}
			_end  int
		)
		_p0 := currentValue.JSValue()
		_args[0] = _p0
		_end++
		_p1 := currentKey
		_args[1] = _p1
		_end++
		_p2 := listObj.JSValue()
		_args[2] = _p2
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromiseAccessOnFulfilledFunc func(value *Access)

// PromiseAccessOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseAccessOnFulfilled js.Func

func PromiseAccessOnFulfilledToJS(callback PromiseAccessOnFulfilledFunc) *PromiseAccessOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseAccessOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *Access // javascript: MIDIAccess value
		)
		_p0 = AccessFromJS(args[0])
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseAccessOnFulfilledFromJS(_value js.Value) PromiseAccessOnFulfilledFunc {
	return func(value *Access) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseAccessOnRejectedFunc func(reason js.Value)

// PromiseAccessOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseAccessOnRejected js.Func

func PromiseAccessOnRejectedToJS(callback PromiseAccessOnRejectedFunc) *PromiseAccessOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseAccessOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseAccessOnRejectedFromJS(_value js.Value) PromiseAccessOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromisePortOnFulfilledFunc func(value *Port)

// PromisePortOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromisePortOnFulfilled js.Func

func PromisePortOnFulfilledToJS(callback PromisePortOnFulfilledFunc) *PromisePortOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromisePortOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *Port // javascript: MIDIPort value
		)
		_p0 = PortFromJS(args[0])
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromisePortOnFulfilledFromJS(_value js.Value) PromisePortOnFulfilledFunc {
	return func(value *Port) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromisePortOnRejectedFunc func(reason js.Value)

// PromisePortOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromisePortOnRejected js.Func

func PromisePortOnRejectedToJS(callback PromisePortOnRejectedFunc) *PromisePortOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromisePortOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromisePortOnRejectedFromJS(_value js.Value) PromisePortOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// dictionary: MIDIConnectionEventInit
type ConnectionEventInit struct {
	Bubbles    bool
	Cancelable bool
	Composed   bool
	Port       *Port
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *ConnectionEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Port.JSValue()
	out.Set("port", value3)
	return out
}

// ConnectionEventInitFromJS is allocating a new
// ConnectionEventInit object and copy all values in the value javascript object.
func ConnectionEventInitFromJS(value js.Value) *ConnectionEventInit {
	var out ConnectionEventInit
	var (
		value0 bool  // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool  // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool  // javascript: boolean {composed Composed composed}
		value3 *Port // javascript: MIDIPort {port Port port}
	)
	value0 = (value.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (value.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (value.Get("composed")).Bool()
	out.Composed = value2
	value3 = PortFromJS(value.Get("port"))
	out.Port = value3
	return &out
}

// dictionary: MIDIInputMapEntryIteratorValue
type InputMapEntryIteratorValue struct {
	Value []js.Value
	Done  bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *InputMapEntryIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.Value))
	for __idx0, __seq_in0 := range _this.Value {
		__seq_out0 := __seq_in0
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// InputMapEntryIteratorValueFromJS is allocating a new
// InputMapEntryIteratorValue object and copy all values in the value javascript object.
func InputMapEntryIteratorValueFromJS(value js.Value) *InputMapEntryIteratorValue {
	var out InputMapEntryIteratorValue
	var (
		value0 []js.Value // javascript: sequence<any> {value Value value}
		value1 bool       // javascript: boolean {done Done done}
	)
	__length0 := value.Get("value").Length()
	__array0 := make([]js.Value, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 js.Value
		__seq_in0 := value.Get("value").Index(__idx0)
		__seq_out0 = __seq_in0
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.Value = value0
	value1 = (value.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: MIDIInputMapKeyIteratorValue
type InputMapKeyIteratorValue struct {
	Value string
	Done  bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *InputMapKeyIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Value
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// InputMapKeyIteratorValueFromJS is allocating a new
// InputMapKeyIteratorValue object and copy all values in the value javascript object.
func InputMapKeyIteratorValueFromJS(value js.Value) *InputMapKeyIteratorValue {
	var out InputMapKeyIteratorValue
	var (
		value0 string // javascript: DOMString {value Value value}
		value1 bool   // javascript: boolean {done Done done}
	)
	value0 = (value.Get("value")).String()
	out.Value = value0
	value1 = (value.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: MIDIInputMapValueIteratorValue
type InputMapValueIteratorValue struct {
	Value *Input
	Done  bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *InputMapValueIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Value.JSValue()
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// InputMapValueIteratorValueFromJS is allocating a new
// InputMapValueIteratorValue object and copy all values in the value javascript object.
func InputMapValueIteratorValueFromJS(value js.Value) *InputMapValueIteratorValue {
	var out InputMapValueIteratorValue
	var (
		value0 *Input // javascript: MIDIInput {value Value value}
		value1 bool   // javascript: boolean {done Done done}
	)
	value0 = InputFromJS(value.Get("value"))
	out.Value = value0
	value1 = (value.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: MIDIMessageEventInit
type MessageEventInit struct {
	Bubbles    bool
	Cancelable bool
	Composed   bool
	Data       *javascript.Uint8Array
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *MessageEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Data.JSValue()
	out.Set("data", value3)
	return out
}

// MessageEventInitFromJS is allocating a new
// MessageEventInit object and copy all values in the value javascript object.
func MessageEventInitFromJS(value js.Value) *MessageEventInit {
	var out MessageEventInit
	var (
		value0 bool                   // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool                   // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool                   // javascript: boolean {composed Composed composed}
		value3 *javascript.Uint8Array // javascript: Uint8Array {data Data data}
	)
	value0 = (value.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (value.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (value.Get("composed")).Bool()
	out.Composed = value2
	value3 = javascript.Uint8ArrayFromJS(value.Get("data"))
	out.Data = value3
	return &out
}

// dictionary: MIDIOptions
type Options struct {
	Sysex    bool
	Software bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *Options) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Sysex
	out.Set("sysex", value0)
	value1 := _this.Software
	out.Set("software", value1)
	return out
}

// OptionsFromJS is allocating a new
// Options object and copy all values in the value javascript object.
func OptionsFromJS(value js.Value) *Options {
	var out Options
	var (
		value0 bool // javascript: boolean {sysex Sysex sysex}
		value1 bool // javascript: boolean {software Software software}
	)
	value0 = (value.Get("sysex")).Bool()
	out.Sysex = value0
	value1 = (value.Get("software")).Bool()
	out.Software = value1
	return &out
}

// dictionary: MIDIOutputMapEntryIteratorValue
type OutputMapEntryIteratorValue struct {
	Value []js.Value
	Done  bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *OutputMapEntryIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.Value))
	for __idx0, __seq_in0 := range _this.Value {
		__seq_out0 := __seq_in0
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// OutputMapEntryIteratorValueFromJS is allocating a new
// OutputMapEntryIteratorValue object and copy all values in the value javascript object.
func OutputMapEntryIteratorValueFromJS(value js.Value) *OutputMapEntryIteratorValue {
	var out OutputMapEntryIteratorValue
	var (
		value0 []js.Value // javascript: sequence<any> {value Value value}
		value1 bool       // javascript: boolean {done Done done}
	)
	__length0 := value.Get("value").Length()
	__array0 := make([]js.Value, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 js.Value
		__seq_in0 := value.Get("value").Index(__idx0)
		__seq_out0 = __seq_in0
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.Value = value0
	value1 = (value.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: MIDIOutputMapKeyIteratorValue
type OutputMapKeyIteratorValue struct {
	Value string
	Done  bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *OutputMapKeyIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Value
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// OutputMapKeyIteratorValueFromJS is allocating a new
// OutputMapKeyIteratorValue object and copy all values in the value javascript object.
func OutputMapKeyIteratorValueFromJS(value js.Value) *OutputMapKeyIteratorValue {
	var out OutputMapKeyIteratorValue
	var (
		value0 string // javascript: DOMString {value Value value}
		value1 bool   // javascript: boolean {done Done done}
	)
	value0 = (value.Get("value")).String()
	out.Value = value0
	value1 = (value.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: MIDIOutputMapValueIteratorValue
type OutputMapValueIteratorValue struct {
	Value *Output
	Done  bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *OutputMapValueIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Value.JSValue()
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// OutputMapValueIteratorValueFromJS is allocating a new
// OutputMapValueIteratorValue object and copy all values in the value javascript object.
func OutputMapValueIteratorValueFromJS(value js.Value) *OutputMapValueIteratorValue {
	var out OutputMapValueIteratorValue
	var (
		value0 *Output // javascript: MIDIOutput {value Value value}
		value1 bool    // javascript: boolean {done Done done}
	)
	value0 = OutputFromJS(value.Get("value"))
	out.Value = value0
	value1 = (value.Get("done")).Bool()
	out.Done = value1
	return &out
}

// class: MIDIAccess
type Access struct {
	domcore.EventTarget
}

// AccessFromJS is casting a js.Value into Access.
func AccessFromJS(value js.Value) *Access {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Access{}
	ret.Value_JS = value
	return ret
}

// AccessFromJS is casting from something that holds a js.Value into Access.
func AccessFromWrapper(input core.Wrapper) *Access {
	return AccessFromJS(input.JSValue())
}

// Inputs returning attribute 'inputs' with
// type InputMap (idl: MIDIInputMap).
func (_this *Access) Inputs() *InputMap {
	var ret *InputMap
	value := _this.Value_JS.Get("inputs")
	ret = InputMapFromJS(value)
	return ret
}

// Outputs returning attribute 'outputs' with
// type OutputMap (idl: MIDIOutputMap).
func (_this *Access) Outputs() *OutputMap {
	var ret *OutputMap
	value := _this.Value_JS.Get("outputs")
	ret = OutputMapFromJS(value)
	return ret
}

// OnStateChange returning attribute 'onstatechange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *Access) OnStateChange() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onstatechange")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SysexEnabled returning attribute 'sysexEnabled' with
// type bool (idl: boolean).
func (_this *Access) SysexEnabled() bool {
	var ret bool
	value := _this.Value_JS.Get("sysexEnabled")
	ret = (value).Bool()
	return ret
}

// event attribute: ConnectionEvent
func eventFuncAccess_ConnectionEvent(listener func(event *ConnectionEvent, target *Access)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *ConnectionEvent
		value := args[0]
		incoming := value.Get("target")
		ret = ConnectionEventFromJS(value)
		src := AccessFromJS(incoming)
		listener(ret, src)
		return js.Undefined()
	}
	return js.FuncOf(fn)
}

// AddStateChange is adding doing AddEventListener for 'StateChange' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *Access) AddEventStateChange(listener func(event *ConnectionEvent, currentTarget *Access)) js.Func {
	cb := eventFuncAccess_ConnectionEvent(listener)
	_this.Value_JS.Call("addEventListener", "statechange", cb)
	return cb
}

// SetOnStateChange is assigning a function to 'onstatechange'. This
// This method is returning allocated javascript function that need to be released.
func (_this *Access) SetOnStateChange(listener func(event *ConnectionEvent, currentTarget *Access)) js.Func {
	cb := eventFuncAccess_ConnectionEvent(listener)
	_this.Value_JS.Set("onstatechange", cb)
	return cb
}

// class: MIDIConnectionEvent
type ConnectionEvent struct {
	domcore.Event
}

// ConnectionEventFromJS is casting a js.Value into ConnectionEvent.
func ConnectionEventFromJS(value js.Value) *ConnectionEvent {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &ConnectionEvent{}
	ret.Value_JS = value
	return ret
}

// ConnectionEventFromJS is casting from something that holds a js.Value into ConnectionEvent.
func ConnectionEventFromWrapper(input core.Wrapper) *ConnectionEvent {
	return ConnectionEventFromJS(input.JSValue())
}

func NewMIDIConnectionEvent(_type string, eventInitDict *ConnectionEventInit) (_result *ConnectionEvent) {
	_klass := js.Global().Get("MIDIConnectionEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	if eventInitDict != nil {
		_p1 := eventInitDict.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *ConnectionEvent // javascript: MIDIConnectionEvent _what_return_name
	)
	_converted = ConnectionEventFromJS(_returned)
	_result = _converted
	return
}

// Port returning attribute 'port' with
// type Port (idl: MIDIPort).
func (_this *ConnectionEvent) Port() *Port {
	var ret *Port
	value := _this.Value_JS.Get("port")
	ret = PortFromJS(value)
	return ret
}

// class: MIDIInput
type Input struct {
	Port
}

// InputFromJS is casting a js.Value into Input.
func InputFromJS(value js.Value) *Input {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Input{}
	ret.Value_JS = value
	return ret
}

// InputFromJS is casting from something that holds a js.Value into Input.
func InputFromWrapper(input core.Wrapper) *Input {
	return InputFromJS(input.JSValue())
}

// OnMIDIMessage returning attribute 'onmidimessage' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *Input) OnMIDIMessage() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onmidimessage")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// event attribute: MessageEvent
func eventFuncInput_MessageEvent(listener func(event *MessageEvent, target *Input)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *MessageEvent
		value := args[0]
		incoming := value.Get("target")
		ret = MessageEventFromJS(value)
		src := InputFromJS(incoming)
		listener(ret, src)
		return js.Undefined()
	}
	return js.FuncOf(fn)
}

// AddMIDIMessage is adding doing AddEventListener for 'MIDIMessage' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *Input) AddEventMIDIMessage(listener func(event *MessageEvent, currentTarget *Input)) js.Func {
	cb := eventFuncInput_MessageEvent(listener)
	_this.Value_JS.Call("addEventListener", "midimessage", cb)
	return cb
}

// SetOnMIDIMessage is assigning a function to 'onmidimessage'. This
// This method is returning allocated javascript function that need to be released.
func (_this *Input) SetOnMIDIMessage(listener func(event *MessageEvent, currentTarget *Input)) js.Func {
	cb := eventFuncInput_MessageEvent(listener)
	_this.Value_JS.Set("onmidimessage", cb)
	return cb
}

// class: MIDIInputMap
type InputMap struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *InputMap) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// InputMapFromJS is casting a js.Value into InputMap.
func InputMapFromJS(value js.Value) *InputMap {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &InputMap{}
	ret.Value_JS = value
	return ret
}

// InputMapFromJS is casting from something that holds a js.Value into InputMap.
func InputMapFromWrapper(input core.Wrapper) *InputMap {
	return InputMapFromJS(input.JSValue())
}

// Size returning attribute 'size' with
// type int (idl: long).
func (_this *InputMap) Size() int {
	var ret int
	value := _this.Value_JS.Get("size")
	ret = (value).Int()
	return ret
}

func (_this *InputMap) Entries() (_result *InputMapEntryIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("entries", _args[0:_end]...)
	var (
		_converted *InputMapEntryIterator // javascript: MIDIInputMapEntryIterator _what_return_name
	)
	_converted = InputMapEntryIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *InputMap) ForEach(callback *InputMapForEach, optionalThisForCallbackArgument interface{}) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if callback != nil {
		__callback0 = (*callback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if optionalThisForCallbackArgument != nil {
		_p1 := optionalThisForCallbackArgument
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("forEach", _args[0:_end]...)
	return
}

func (_this *InputMap) Keys() (_result *InputMapKeyIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("keys", _args[0:_end]...)
	var (
		_converted *InputMapKeyIterator // javascript: MIDIInputMapKeyIterator _what_return_name
	)
	_converted = InputMapKeyIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *InputMap) Values() (_result *InputMapValueIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("values", _args[0:_end]...)
	var (
		_converted *InputMapValueIterator // javascript: MIDIInputMapValueIterator _what_return_name
	)
	_converted = InputMapValueIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *InputMap) Get(key string) (_result *Input) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := key
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("get", _args[0:_end]...)
	var (
		_converted *Input // javascript: MIDIInput _what_return_name
	)
	if _returned.Type() != js.TypeNull && _returned.Type() != js.TypeUndefined {
		_converted = InputFromJS(_returned)
	}
	_result = _converted
	return
}

func (_this *InputMap) Has(key string) (_result bool) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := key
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("has", _args[0:_end]...)
	var (
		_converted bool // javascript: boolean _what_return_name
	)
	_converted = (_returned).Bool()
	_result = _converted
	return
}

// class: MIDIInputMapEntryIterator
type InputMapEntryIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *InputMapEntryIterator) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// InputMapEntryIteratorFromJS is casting a js.Value into InputMapEntryIterator.
func InputMapEntryIteratorFromJS(value js.Value) *InputMapEntryIterator {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &InputMapEntryIterator{}
	ret.Value_JS = value
	return ret
}

// InputMapEntryIteratorFromJS is casting from something that holds a js.Value into InputMapEntryIterator.
func InputMapEntryIteratorFromWrapper(input core.Wrapper) *InputMapEntryIterator {
	return InputMapEntryIteratorFromJS(input.JSValue())
}

func (_this *InputMapEntryIterator) Next() (_result *InputMapEntryIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *InputMapEntryIteratorValue // javascript: MIDIInputMapEntryIteratorValue _what_return_name
	)
	_converted = InputMapEntryIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: MIDIInputMapKeyIterator
type InputMapKeyIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *InputMapKeyIterator) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// InputMapKeyIteratorFromJS is casting a js.Value into InputMapKeyIterator.
func InputMapKeyIteratorFromJS(value js.Value) *InputMapKeyIterator {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &InputMapKeyIterator{}
	ret.Value_JS = value
	return ret
}

// InputMapKeyIteratorFromJS is casting from something that holds a js.Value into InputMapKeyIterator.
func InputMapKeyIteratorFromWrapper(input core.Wrapper) *InputMapKeyIterator {
	return InputMapKeyIteratorFromJS(input.JSValue())
}

func (_this *InputMapKeyIterator) Next() (_result *InputMapKeyIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *InputMapKeyIteratorValue // javascript: MIDIInputMapKeyIteratorValue _what_return_name
	)
	_converted = InputMapKeyIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: MIDIInputMapValueIterator
type InputMapValueIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *InputMapValueIterator) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// InputMapValueIteratorFromJS is casting a js.Value into InputMapValueIterator.
func InputMapValueIteratorFromJS(value js.Value) *InputMapValueIterator {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &InputMapValueIterator{}
	ret.Value_JS = value
	return ret
}

// InputMapValueIteratorFromJS is casting from something that holds a js.Value into InputMapValueIterator.
func InputMapValueIteratorFromWrapper(input core.Wrapper) *InputMapValueIterator {
	return InputMapValueIteratorFromJS(input.JSValue())
}

func (_this *InputMapValueIterator) Next() (_result *InputMapValueIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *InputMapValueIteratorValue // javascript: MIDIInputMapValueIteratorValue _what_return_name
	)
	_converted = InputMapValueIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: MIDIMessageEvent
type MessageEvent struct {
	domcore.Event
}

// MessageEventFromJS is casting a js.Value into MessageEvent.
func MessageEventFromJS(value js.Value) *MessageEvent {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &MessageEvent{}
	ret.Value_JS = value
	return ret
}

// MessageEventFromJS is casting from something that holds a js.Value into MessageEvent.
func MessageEventFromWrapper(input core.Wrapper) *MessageEvent {
	return MessageEventFromJS(input.JSValue())
}

func NewMIDIMessageEvent(_type string, eventInitDict *MessageEventInit) (_result *MessageEvent) {
	_klass := js.Global().Get("MIDIMessageEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	if eventInitDict != nil {
		_p1 := eventInitDict.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *MessageEvent // javascript: MIDIMessageEvent _what_return_name
	)
	_converted = MessageEventFromJS(_returned)
	_result = _converted
	return
}

// Data returning attribute 'data' with
// type javascript.Uint8Array (idl: Uint8Array).
func (_this *MessageEvent) Data() *javascript.Uint8Array {
	var ret *javascript.Uint8Array
	value := _this.Value_JS.Get("data")
	ret = javascript.Uint8ArrayFromJS(value)
	return ret
}

// class: MIDIOutput
type Output struct {
	Port
}

// OutputFromJS is casting a js.Value into Output.
func OutputFromJS(value js.Value) *Output {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Output{}
	ret.Value_JS = value
	return ret
}

// OutputFromJS is casting from something that holds a js.Value into Output.
func OutputFromWrapper(input core.Wrapper) *Output {
	return OutputFromJS(input.JSValue())
}

func (_this *Output) Send(data []int, timestamp *float64) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := js.Global().Get("Array").New(len(data))
	for __idx0, __seq_in0 := range data {
		__seq_out0 := __seq_in0
		_p0.SetIndex(__idx0, __seq_out0)
	}
	_args[0] = _p0
	_end++
	if timestamp != nil {

		var _p1 interface{}
		if timestamp != nil {
			_p1 = *(timestamp)
		} else {
			_p1 = nil
		}
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("send", _args[0:_end]...)
	return
}

func (_this *Output) Clear() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("clear", _args[0:_end]...)
	return
}

// class: MIDIOutputMap
type OutputMap struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *OutputMap) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// OutputMapFromJS is casting a js.Value into OutputMap.
func OutputMapFromJS(value js.Value) *OutputMap {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &OutputMap{}
	ret.Value_JS = value
	return ret
}

// OutputMapFromJS is casting from something that holds a js.Value into OutputMap.
func OutputMapFromWrapper(input core.Wrapper) *OutputMap {
	return OutputMapFromJS(input.JSValue())
}

// Size returning attribute 'size' with
// type int (idl: long).
func (_this *OutputMap) Size() int {
	var ret int
	value := _this.Value_JS.Get("size")
	ret = (value).Int()
	return ret
}

func (_this *OutputMap) Entries() (_result *OutputMapEntryIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("entries", _args[0:_end]...)
	var (
		_converted *OutputMapEntryIterator // javascript: MIDIOutputMapEntryIterator _what_return_name
	)
	_converted = OutputMapEntryIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *OutputMap) ForEach(callback *OutputMapForEach, optionalThisForCallbackArgument interface{}) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if callback != nil {
		__callback0 = (*callback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if optionalThisForCallbackArgument != nil {
		_p1 := optionalThisForCallbackArgument
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("forEach", _args[0:_end]...)
	return
}

func (_this *OutputMap) Keys() (_result *OutputMapKeyIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("keys", _args[0:_end]...)
	var (
		_converted *OutputMapKeyIterator // javascript: MIDIOutputMapKeyIterator _what_return_name
	)
	_converted = OutputMapKeyIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *OutputMap) Values() (_result *OutputMapValueIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("values", _args[0:_end]...)
	var (
		_converted *OutputMapValueIterator // javascript: MIDIOutputMapValueIterator _what_return_name
	)
	_converted = OutputMapValueIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *OutputMap) Get(key string) (_result *Output) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := key
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("get", _args[0:_end]...)
	var (
		_converted *Output // javascript: MIDIOutput _what_return_name
	)
	if _returned.Type() != js.TypeNull && _returned.Type() != js.TypeUndefined {
		_converted = OutputFromJS(_returned)
	}
	_result = _converted
	return
}

func (_this *OutputMap) Has(key string) (_result bool) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := key
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("has", _args[0:_end]...)
	var (
		_converted bool // javascript: boolean _what_return_name
	)
	_converted = (_returned).Bool()
	_result = _converted
	return
}

// class: MIDIOutputMapEntryIterator
type OutputMapEntryIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *OutputMapEntryIterator) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// OutputMapEntryIteratorFromJS is casting a js.Value into OutputMapEntryIterator.
func OutputMapEntryIteratorFromJS(value js.Value) *OutputMapEntryIterator {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &OutputMapEntryIterator{}
	ret.Value_JS = value
	return ret
}

// OutputMapEntryIteratorFromJS is casting from something that holds a js.Value into OutputMapEntryIterator.
func OutputMapEntryIteratorFromWrapper(input core.Wrapper) *OutputMapEntryIterator {
	return OutputMapEntryIteratorFromJS(input.JSValue())
}

func (_this *OutputMapEntryIterator) Next() (_result *OutputMapEntryIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *OutputMapEntryIteratorValue // javascript: MIDIOutputMapEntryIteratorValue _what_return_name
	)
	_converted = OutputMapEntryIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: MIDIOutputMapKeyIterator
type OutputMapKeyIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *OutputMapKeyIterator) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// OutputMapKeyIteratorFromJS is casting a js.Value into OutputMapKeyIterator.
func OutputMapKeyIteratorFromJS(value js.Value) *OutputMapKeyIterator {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &OutputMapKeyIterator{}
	ret.Value_JS = value
	return ret
}

// OutputMapKeyIteratorFromJS is casting from something that holds a js.Value into OutputMapKeyIterator.
func OutputMapKeyIteratorFromWrapper(input core.Wrapper) *OutputMapKeyIterator {
	return OutputMapKeyIteratorFromJS(input.JSValue())
}

func (_this *OutputMapKeyIterator) Next() (_result *OutputMapKeyIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *OutputMapKeyIteratorValue // javascript: MIDIOutputMapKeyIteratorValue _what_return_name
	)
	_converted = OutputMapKeyIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: MIDIOutputMapValueIterator
type OutputMapValueIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *OutputMapValueIterator) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// OutputMapValueIteratorFromJS is casting a js.Value into OutputMapValueIterator.
func OutputMapValueIteratorFromJS(value js.Value) *OutputMapValueIterator {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &OutputMapValueIterator{}
	ret.Value_JS = value
	return ret
}

// OutputMapValueIteratorFromJS is casting from something that holds a js.Value into OutputMapValueIterator.
func OutputMapValueIteratorFromWrapper(input core.Wrapper) *OutputMapValueIterator {
	return OutputMapValueIteratorFromJS(input.JSValue())
}

func (_this *OutputMapValueIterator) Next() (_result *OutputMapValueIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *OutputMapValueIteratorValue // javascript: MIDIOutputMapValueIteratorValue _what_return_name
	)
	_converted = OutputMapValueIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: MIDIPort
type Port struct {
	domcore.EventTarget
}

// PortFromJS is casting a js.Value into Port.
func PortFromJS(value js.Value) *Port {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Port{}
	ret.Value_JS = value
	return ret
}

// PortFromJS is casting from something that holds a js.Value into Port.
func PortFromWrapper(input core.Wrapper) *Port {
	return PortFromJS(input.JSValue())
}

// Id returning attribute 'id' with
// type string (idl: DOMString).
func (_this *Port) Id() string {
	var ret string
	value := _this.Value_JS.Get("id")
	ret = (value).String()
	return ret
}

// Manufacturer returning attribute 'manufacturer' with
// type string (idl: DOMString).
func (_this *Port) Manufacturer() *string {
	var ret *string
	value := _this.Value_JS.Get("manufacturer")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).String()
		ret = &__tmp
	}
	return ret
}

// Name returning attribute 'name' with
// type string (idl: DOMString).
func (_this *Port) Name() *string {
	var ret *string
	value := _this.Value_JS.Get("name")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).String()
		ret = &__tmp
	}
	return ret
}

// Type returning attribute 'type' with
// type PortType (idl: MIDIPortType).
func (_this *Port) Type() PortType {
	var ret PortType
	value := _this.Value_JS.Get("type")
	ret = PortTypeFromJS(value)
	return ret
}

// Version returning attribute 'version' with
// type string (idl: DOMString).
func (_this *Port) Version() *string {
	var ret *string
	value := _this.Value_JS.Get("version")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).String()
		ret = &__tmp
	}
	return ret
}

// State returning attribute 'state' with
// type PortDeviceState (idl: MIDIPortDeviceState).
func (_this *Port) State() PortDeviceState {
	var ret PortDeviceState
	value := _this.Value_JS.Get("state")
	ret = PortDeviceStateFromJS(value)
	return ret
}

// Connection returning attribute 'connection' with
// type PortConnectionState (idl: MIDIPortConnectionState).
func (_this *Port) Connection() PortConnectionState {
	var ret PortConnectionState
	value := _this.Value_JS.Get("connection")
	ret = PortConnectionStateFromJS(value)
	return ret
}

// OnStateChange returning attribute 'onstatechange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *Port) OnStateChange() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onstatechange")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// event attribute: ConnectionEvent
func eventFuncPort_ConnectionEvent(listener func(event *ConnectionEvent, target *Port)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *ConnectionEvent
		value := args[0]
		incoming := value.Get("target")
		ret = ConnectionEventFromJS(value)
		src := PortFromJS(incoming)
		listener(ret, src)
		return js.Undefined()
	}
	return js.FuncOf(fn)
}

// AddStateChange is adding doing AddEventListener for 'StateChange' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *Port) AddEventStateChange(listener func(event *ConnectionEvent, currentTarget *Port)) js.Func {
	cb := eventFuncPort_ConnectionEvent(listener)
	_this.Value_JS.Call("addEventListener", "statechange", cb)
	return cb
}

// SetOnStateChange is assigning a function to 'onstatechange'. This
// This method is returning allocated javascript function that need to be released.
func (_this *Port) SetOnStateChange(listener func(event *ConnectionEvent, currentTarget *Port)) js.Func {
	cb := eventFuncPort_ConnectionEvent(listener)
	_this.Value_JS.Set("onstatechange", cb)
	return cb
}

func (_this *Port) Open() (_result *PromisePort) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("open", _args[0:_end]...)
	var (
		_converted *PromisePort // javascript: Promise _what_return_name
	)
	_converted = PromisePortFromJS(_returned)
	_result = _converted
	return
}

func (_this *Port) Close() (_result *PromisePort) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("close", _args[0:_end]...)
	var (
		_converted *PromisePort // javascript: Promise _what_return_name
	)
	_converted = PromisePortFromJS(_returned)
	_result = _converted
	return
}

// class: Promise
type PromiseAccess struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *PromiseAccess) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// PromiseAccessFromJS is casting a js.Value into PromiseAccess.
func PromiseAccessFromJS(value js.Value) *PromiseAccess {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseAccess{}
	ret.Value_JS = value
	return ret
}

// PromiseAccessFromJS is casting from something that holds a js.Value into PromiseAccess.
func PromiseAccessFromWrapper(input core.Wrapper) *PromiseAccess {
	return PromiseAccessFromJS(input.JSValue())
}

func (_this *PromiseAccess) Then(onFulfilled *PromiseAccessOnFulfilled, onRejected *PromiseAccessOnRejected) (_result *PromiseAccess) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseAccess // javascript: Promise _what_return_name
	)
	_converted = PromiseAccessFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseAccess) Catch(onRejected *PromiseAccessOnRejected) (_result *PromiseAccess) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseAccess // javascript: Promise _what_return_name
	)
	_converted = PromiseAccessFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseAccess) Finally(onFinally *javascript.PromiseFinally) (_result *PromiseAccess) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseAccess // javascript: Promise _what_return_name
	)
	_converted = PromiseAccessFromJS(_returned)
	_result = _converted
	return
}

// class: Promise
type PromisePort struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *PromisePort) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// PromisePortFromJS is casting a js.Value into PromisePort.
func PromisePortFromJS(value js.Value) *PromisePort {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromisePort{}
	ret.Value_JS = value
	return ret
}

// PromisePortFromJS is casting from something that holds a js.Value into PromisePort.
func PromisePortFromWrapper(input core.Wrapper) *PromisePort {
	return PromisePortFromJS(input.JSValue())
}

func (_this *PromisePort) Then(onFulfilled *PromisePortOnFulfilled, onRejected *PromisePortOnRejected) (_result *PromisePort) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromisePort // javascript: Promise _what_return_name
	)
	_converted = PromisePortFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromisePort) Catch(onRejected *PromisePortOnRejected) (_result *PromisePort) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromisePort // javascript: Promise _what_return_name
	)
	_converted = PromisePortFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromisePort) Finally(onFinally *javascript.PromiseFinally) (_result *PromisePort) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromisePort // javascript: Promise _what_return_name
	)
	_converted = PromisePortFromJS(_returned)
	_result = _converted
	return
}
