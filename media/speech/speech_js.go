// Code generated by webidl-bind. DO NOT EDIT.

package speech

import "syscall/js"

import (
	"github.com/gowebapi/webapi/dom/domcore"
)

// using following types:
// domcore.Event
// domcore.EventHandler
// domcore.EventTarget

// source idl files:
// speech-api.idl

// transform files:
// speech-api.go.md

// ReleasableApiResource is used to release underlaying
// allocated resources.
type ReleasableApiResource interface {
	Release()
}

type releasableApiResourceList []ReleasableApiResource

func (a releasableApiResourceList) Release() {
	for _, v := range a {
		v.Release()
	}
}

// workaround for compiler error
func unused(value interface{}) {
	// TODO remove this method
}

type Union struct {
	Value js.Value
}

func (u *Union) JSValue() js.Value {
	return u.Value
}

func UnionFromJS(value js.Value) *Union {
	return &Union{Value: value}
}

// enum: SpeechRecognitionErrorCode
type SpeechRecognitionErrorCode int

const (
	NoSpeechSpeechRecognitionErrorCode SpeechRecognitionErrorCode = iota
	AbortedSpeechRecognitionErrorCode
	AudioCaptureSpeechRecognitionErrorCode
	NetworkSpeechRecognitionErrorCode
	NotAllowedSpeechRecognitionErrorCode
	ServiceNotAllowedSpeechRecognitionErrorCode
	BadGrammarSpeechRecognitionErrorCode
	LanguageNotSupportedSpeechRecognitionErrorCode
)

var speechRecognitionErrorCodeToWasmTable = []string{
	"no-speech", "aborted", "audio-capture", "network", "not-allowed", "service-not-allowed", "bad-grammar", "language-not-supported",
}

var speechRecognitionErrorCodeFromWasmTable = map[string]SpeechRecognitionErrorCode{
	"no-speech": NoSpeechSpeechRecognitionErrorCode, "aborted": AbortedSpeechRecognitionErrorCode, "audio-capture": AudioCaptureSpeechRecognitionErrorCode, "network": NetworkSpeechRecognitionErrorCode, "not-allowed": NotAllowedSpeechRecognitionErrorCode, "service-not-allowed": ServiceNotAllowedSpeechRecognitionErrorCode, "bad-grammar": BadGrammarSpeechRecognitionErrorCode, "language-not-supported": LanguageNotSupportedSpeechRecognitionErrorCode,
}

// JSValue is converting this enum into a java object
func (this *SpeechRecognitionErrorCode) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this SpeechRecognitionErrorCode) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(speechRecognitionErrorCodeToWasmTable) {
		return speechRecognitionErrorCodeToWasmTable[idx]
	}
	panic("unknown input value")
}

// SpeechRecognitionErrorCodeFromJS is converting a javascript value into
// a SpeechRecognitionErrorCode enum value.
func SpeechRecognitionErrorCodeFromJS(value js.Value) SpeechRecognitionErrorCode {
	key := value.String()
	conv, ok := speechRecognitionErrorCodeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: SpeechSynthesisErrorCode
type SpeechSynthesisErrorCode int

const (
	CanceledSpeechSynthesisErrorCode SpeechSynthesisErrorCode = iota
	InterruptedSpeechSynthesisErrorCode
	AudioBusySpeechSynthesisErrorCode
	AudioHardwareSpeechSynthesisErrorCode
	NetworkSpeechSynthesisErrorCode
	SynthesisUnavailableSpeechSynthesisErrorCode
	SynthesisFailedSpeechSynthesisErrorCode
	LanguageUnavailableSpeechSynthesisErrorCode
	VoiceUnavailableSpeechSynthesisErrorCode
	TextTooLongSpeechSynthesisErrorCode
	InvalidArgumentSpeechSynthesisErrorCode
	NotAllowedSpeechSynthesisErrorCode
)

var speechSynthesisErrorCodeToWasmTable = []string{
	"canceled", "interrupted", "audio-busy", "audio-hardware", "network", "synthesis-unavailable", "synthesis-failed", "language-unavailable", "voice-unavailable", "text-too-long", "invalid-argument", "not-allowed",
}

var speechSynthesisErrorCodeFromWasmTable = map[string]SpeechSynthesisErrorCode{
	"canceled": CanceledSpeechSynthesisErrorCode, "interrupted": InterruptedSpeechSynthesisErrorCode, "audio-busy": AudioBusySpeechSynthesisErrorCode, "audio-hardware": AudioHardwareSpeechSynthesisErrorCode, "network": NetworkSpeechSynthesisErrorCode, "synthesis-unavailable": SynthesisUnavailableSpeechSynthesisErrorCode, "synthesis-failed": SynthesisFailedSpeechSynthesisErrorCode, "language-unavailable": LanguageUnavailableSpeechSynthesisErrorCode, "voice-unavailable": VoiceUnavailableSpeechSynthesisErrorCode, "text-too-long": TextTooLongSpeechSynthesisErrorCode, "invalid-argument": InvalidArgumentSpeechSynthesisErrorCode, "not-allowed": NotAllowedSpeechSynthesisErrorCode,
}

// JSValue is converting this enum into a java object
func (this *SpeechSynthesisErrorCode) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this SpeechSynthesisErrorCode) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(speechSynthesisErrorCodeToWasmTable) {
		return speechSynthesisErrorCodeToWasmTable[idx]
	}
	panic("unknown input value")
}

// SpeechSynthesisErrorCodeFromJS is converting a javascript value into
// a SpeechSynthesisErrorCode enum value.
func SpeechSynthesisErrorCodeFromJS(value js.Value) SpeechSynthesisErrorCode {
	key := value.String()
	conv, ok := speechSynthesisErrorCodeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// dictionary: SpeechRecognitionErrorEventInit
type SpeechRecognitionErrorEventInit struct {
	Bubbles    bool
	Cancelable bool
	Composed   bool
	Error      SpeechRecognitionErrorCode
	Message    string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *SpeechRecognitionErrorEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Error.JSValue()
	out.Set("error", value3)
	value4 := _this.Message
	out.Set("message", value4)
	return out
}

// SpeechRecognitionErrorEventInitFromJS is allocating a new
// SpeechRecognitionErrorEventInit object and copy all values from
// input javascript object
func SpeechRecognitionErrorEventInitFromJS(value js.Wrapper) *SpeechRecognitionErrorEventInit {
	input := value.JSValue()
	var out SpeechRecognitionErrorEventInit
	var (
		value0 bool                       // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool                       // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool                       // javascript: boolean {composed Composed composed}
		value3 SpeechRecognitionErrorCode // javascript: SpeechRecognitionErrorCode {error Error _error}
		value4 string                     // javascript: DOMString {message Message message}
	)
	value0 = (input.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (input.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (input.Get("composed")).Bool()
	out.Composed = value2
	value3 = SpeechRecognitionErrorCodeFromJS(input.Get("error"))
	out.Error = value3
	value4 = (input.Get("message")).String()
	out.Message = value4
	return &out
}

// dictionary: SpeechRecognitionEventInit
type SpeechRecognitionEventInit struct {
	Bubbles        bool
	Cancelable     bool
	Composed       bool
	ResultIndex    uint
	Results        *SpeechRecognitionResultList
	Interpretation js.Value
	Emma           js.Value
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *SpeechRecognitionEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.ResultIndex
	out.Set("resultIndex", value3)
	value4 := _this.Results.JSValue()
	out.Set("results", value4)
	value5 := _this.Interpretation
	out.Set("interpretation", value5)
	value6 := _this.Emma
	out.Set("emma", value6)
	return out
}

// SpeechRecognitionEventInitFromJS is allocating a new
// SpeechRecognitionEventInit object and copy all values from
// input javascript object
func SpeechRecognitionEventInitFromJS(value js.Wrapper) *SpeechRecognitionEventInit {
	input := value.JSValue()
	var out SpeechRecognitionEventInit
	var (
		value0 bool                         // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool                         // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool                         // javascript: boolean {composed Composed composed}
		value3 uint                         // javascript: unsigned long {resultIndex ResultIndex resultIndex}
		value4 *SpeechRecognitionResultList // javascript: SpeechRecognitionResultList {results Results results}
		value5 js.Value                     // javascript: any {interpretation Interpretation interpretation}
		value6 js.Value                     // javascript: <rawjs> {emma Emma emma}
	)
	value0 = (input.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (input.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (input.Get("composed")).Bool()
	out.Composed = value2
	value3 = (uint)((input.Get("resultIndex")).Int())
	out.ResultIndex = value3
	value4 = SpeechRecognitionResultListFromJS(input.Get("results"))
	out.Results = value4
	value5 = input.Get("interpretation")
	out.Interpretation = value5
	value6 = input.Get("emma")
	out.Emma = value6
	return &out
}

// dictionary: SpeechSynthesisErrorEventInit
type SpeechSynthesisErrorEventInit struct {
	Bubbles     bool
	Cancelable  bool
	Composed    bool
	Utterance   *SpeechSynthesisUtterance
	CharIndex   uint
	ElapsedTime float32
	Name        string
	Error       SpeechSynthesisErrorCode
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *SpeechSynthesisErrorEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Utterance.JSValue()
	out.Set("utterance", value3)
	value4 := _this.CharIndex
	out.Set("charIndex", value4)
	value5 := _this.ElapsedTime
	out.Set("elapsedTime", value5)
	value6 := _this.Name
	out.Set("name", value6)
	value7 := _this.Error.JSValue()
	out.Set("error", value7)
	return out
}

// SpeechSynthesisErrorEventInitFromJS is allocating a new
// SpeechSynthesisErrorEventInit object and copy all values from
// input javascript object
func SpeechSynthesisErrorEventInitFromJS(value js.Wrapper) *SpeechSynthesisErrorEventInit {
	input := value.JSValue()
	var out SpeechSynthesisErrorEventInit
	var (
		value0 bool                      // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool                      // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool                      // javascript: boolean {composed Composed composed}
		value3 *SpeechSynthesisUtterance // javascript: SpeechSynthesisUtterance {utterance Utterance utterance}
		value4 uint                      // javascript: unsigned long {charIndex CharIndex charIndex}
		value5 float32                   // javascript: float {elapsedTime ElapsedTime elapsedTime}
		value6 string                    // javascript: DOMString {name Name name}
		value7 SpeechSynthesisErrorCode  // javascript: SpeechSynthesisErrorCode {error Error _error}
	)
	value0 = (input.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (input.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (input.Get("composed")).Bool()
	out.Composed = value2
	value3 = SpeechSynthesisUtteranceFromJS(input.Get("utterance"))
	out.Utterance = value3
	value4 = (uint)((input.Get("charIndex")).Int())
	out.CharIndex = value4
	value5 = (float32)((input.Get("elapsedTime")).Float())
	out.ElapsedTime = value5
	value6 = (input.Get("name")).String()
	out.Name = value6
	value7 = SpeechSynthesisErrorCodeFromJS(input.Get("error"))
	out.Error = value7
	return &out
}

// dictionary: SpeechSynthesisEventInit
type SpeechSynthesisEventInit struct {
	Bubbles     bool
	Cancelable  bool
	Composed    bool
	Utterance   *SpeechSynthesisUtterance
	CharIndex   uint
	ElapsedTime float32
	Name        string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *SpeechSynthesisEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Utterance.JSValue()
	out.Set("utterance", value3)
	value4 := _this.CharIndex
	out.Set("charIndex", value4)
	value5 := _this.ElapsedTime
	out.Set("elapsedTime", value5)
	value6 := _this.Name
	out.Set("name", value6)
	return out
}

// SpeechSynthesisEventInitFromJS is allocating a new
// SpeechSynthesisEventInit object and copy all values from
// input javascript object
func SpeechSynthesisEventInitFromJS(value js.Wrapper) *SpeechSynthesisEventInit {
	input := value.JSValue()
	var out SpeechSynthesisEventInit
	var (
		value0 bool                      // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool                      // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool                      // javascript: boolean {composed Composed composed}
		value3 *SpeechSynthesisUtterance // javascript: SpeechSynthesisUtterance {utterance Utterance utterance}
		value4 uint                      // javascript: unsigned long {charIndex CharIndex charIndex}
		value5 float32                   // javascript: float {elapsedTime ElapsedTime elapsedTime}
		value6 string                    // javascript: DOMString {name Name name}
	)
	value0 = (input.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (input.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (input.Get("composed")).Bool()
	out.Composed = value2
	value3 = SpeechSynthesisUtteranceFromJS(input.Get("utterance"))
	out.Utterance = value3
	value4 = (uint)((input.Get("charIndex")).Int())
	out.CharIndex = value4
	value5 = (float32)((input.Get("elapsedTime")).Float())
	out.ElapsedTime = value5
	value6 = (input.Get("name")).String()
	out.Name = value6
	return &out
}

// interface: SpeechGrammar
type SpeechGrammar struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *SpeechGrammar) JSValue() js.Value {
	return _this.Value_JS
}

// SpeechGrammarFromJS is casting a js.Wrapper into SpeechGrammar.
func SpeechGrammarFromJS(value js.Wrapper) *SpeechGrammar {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &SpeechGrammar{}
	ret.Value_JS = input
	return ret
}

func NewSpeechGrammar() (_result *SpeechGrammar) {
	_klass := js.Global().Get("SpeechGrammar")
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SpeechGrammar // javascript: SpeechGrammar _what_return_name
	)
	_converted = SpeechGrammarFromJS(_returned)
	_result = _converted
	return
}

// Src returning attribute 'src' with
// type string (idl: DOMString).
func (_this *SpeechGrammar) Src() string {
	var ret string
	value := _this.Value_JS.Get("src")
	ret = (value).String()
	return ret
}

// SetSrc setting attribute 'src' with
// type string (idl: DOMString).
func (_this *SpeechGrammar) SetSrc(value string) {
	input := value
	_this.Value_JS.Set("src", input)
}

// Weight returning attribute 'weight' with
// type float32 (idl: float).
func (_this *SpeechGrammar) Weight() float32 {
	var ret float32
	value := _this.Value_JS.Get("weight")
	ret = (float32)((value).Float())
	return ret
}

// SetWeight setting attribute 'weight' with
// type float32 (idl: float).
func (_this *SpeechGrammar) SetWeight(value float32) {
	input := value
	_this.Value_JS.Set("weight", input)
}

// interface: SpeechGrammarList
type SpeechGrammarList struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *SpeechGrammarList) JSValue() js.Value {
	return _this.Value_JS
}

// SpeechGrammarListFromJS is casting a js.Wrapper into SpeechGrammarList.
func SpeechGrammarListFromJS(value js.Wrapper) *SpeechGrammarList {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &SpeechGrammarList{}
	ret.Value_JS = input
	return ret
}

func NewSpeechGrammarList() (_result *SpeechGrammarList) {
	_klass := js.Global().Get("SpeechGrammarList")
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SpeechGrammarList // javascript: SpeechGrammarList _what_return_name
	)
	_converted = SpeechGrammarListFromJS(_returned)
	_result = _converted
	return
}

// Length returning attribute 'length' with
// type uint (idl: unsigned long).
func (_this *SpeechGrammarList) Length() uint {
	var ret uint
	value := _this.Value_JS.Get("length")
	ret = (uint)((value).Int())
	return ret
}

func (_this *SpeechGrammarList) Item(index uint) (_result *SpeechGrammar) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := index
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("item", _args[0:_end]...)
	var (
		_converted *SpeechGrammar // javascript: SpeechGrammar _what_return_name
	)
	_converted = SpeechGrammarFromJS(_returned)
	_result = _converted
	return
}

func (_this *SpeechGrammarList) AddFromURI(src string, weight *float32) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := src
	_args[0] = _p0
	_end++
	if weight != nil {
		_p1 := weight
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("addFromURI", _args[0:_end]...)
	return
}

func (_this *SpeechGrammarList) AddFromString(string string, weight *float32) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := string
	_args[0] = _p0
	_end++
	if weight != nil {
		_p1 := weight
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("addFromString", _args[0:_end]...)
	return
}

// interface: SpeechRecognition
type SpeechRecognition struct {
	domcore.EventTarget
}

// SpeechRecognitionFromJS is casting a js.Wrapper into SpeechRecognition.
func SpeechRecognitionFromJS(value js.Wrapper) *SpeechRecognition {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &SpeechRecognition{}
	ret.Value_JS = input
	return ret
}

func NewSpeechRecognition() (_result *SpeechRecognition) {
	_klass := js.Global().Get("SpeechRecognition")
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SpeechRecognition // javascript: SpeechRecognition _what_return_name
	)
	_converted = SpeechRecognitionFromJS(_returned)
	_result = _converted
	return
}

// Grammars returning attribute 'grammars' with
// type SpeechGrammarList (idl: SpeechGrammarList).
func (_this *SpeechRecognition) Grammars() *SpeechGrammarList {
	var ret *SpeechGrammarList
	value := _this.Value_JS.Get("grammars")
	ret = SpeechGrammarListFromJS(value)
	return ret
}

// SetGrammars setting attribute 'grammars' with
// type SpeechGrammarList (idl: SpeechGrammarList).
func (_this *SpeechRecognition) SetGrammars(value *SpeechGrammarList) {
	input := value.JSValue()
	_this.Value_JS.Set("grammars", input)
}

// Lang returning attribute 'lang' with
// type string (idl: DOMString).
func (_this *SpeechRecognition) Lang() string {
	var ret string
	value := _this.Value_JS.Get("lang")
	ret = (value).String()
	return ret
}

// SetLang setting attribute 'lang' with
// type string (idl: DOMString).
func (_this *SpeechRecognition) SetLang(value string) {
	input := value
	_this.Value_JS.Set("lang", input)
}

// Continuous returning attribute 'continuous' with
// type bool (idl: boolean).
func (_this *SpeechRecognition) Continuous() bool {
	var ret bool
	value := _this.Value_JS.Get("continuous")
	ret = (value).Bool()
	return ret
}

// SetContinuous setting attribute 'continuous' with
// type bool (idl: boolean).
func (_this *SpeechRecognition) SetContinuous(value bool) {
	input := value
	_this.Value_JS.Set("continuous", input)
}

// InterimResults returning attribute 'interimResults' with
// type bool (idl: boolean).
func (_this *SpeechRecognition) InterimResults() bool {
	var ret bool
	value := _this.Value_JS.Get("interimResults")
	ret = (value).Bool()
	return ret
}

// SetInterimResults setting attribute 'interimResults' with
// type bool (idl: boolean).
func (_this *SpeechRecognition) SetInterimResults(value bool) {
	input := value
	_this.Value_JS.Set("interimResults", input)
}

// MaxAlternatives returning attribute 'maxAlternatives' with
// type uint (idl: unsigned long).
func (_this *SpeechRecognition) MaxAlternatives() uint {
	var ret uint
	value := _this.Value_JS.Get("maxAlternatives")
	ret = (uint)((value).Int())
	return ret
}

// SetMaxAlternatives setting attribute 'maxAlternatives' with
// type uint (idl: unsigned long).
func (_this *SpeechRecognition) SetMaxAlternatives(value uint) {
	input := value
	_this.Value_JS.Set("maxAlternatives", input)
}

// ServiceURI returning attribute 'serviceURI' with
// type string (idl: DOMString).
func (_this *SpeechRecognition) ServiceURI() string {
	var ret string
	value := _this.Value_JS.Get("serviceURI")
	ret = (value).String()
	return ret
}

// SetServiceURI setting attribute 'serviceURI' with
// type string (idl: DOMString).
func (_this *SpeechRecognition) SetServiceURI(value string) {
	input := value
	_this.Value_JS.Set("serviceURI", input)
}

// Onaudiostart returning attribute 'onaudiostart' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) Onaudiostart() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onaudiostart")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnaudiostart setting attribute 'onaudiostart' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) SetOnaudiostart(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onaudiostart", input)
}

// Onsoundstart returning attribute 'onsoundstart' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) Onsoundstart() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onsoundstart")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnsoundstart setting attribute 'onsoundstart' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) SetOnsoundstart(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onsoundstart", input)
}

// Onspeechstart returning attribute 'onspeechstart' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) Onspeechstart() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onspeechstart")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnspeechstart setting attribute 'onspeechstart' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) SetOnspeechstart(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onspeechstart", input)
}

// Onspeechend returning attribute 'onspeechend' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) Onspeechend() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onspeechend")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnspeechend setting attribute 'onspeechend' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) SetOnspeechend(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onspeechend", input)
}

// Onsoundend returning attribute 'onsoundend' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) Onsoundend() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onsoundend")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnsoundend setting attribute 'onsoundend' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) SetOnsoundend(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onsoundend", input)
}

// Onaudioend returning attribute 'onaudioend' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) Onaudioend() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onaudioend")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnaudioend setting attribute 'onaudioend' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) SetOnaudioend(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onaudioend", input)
}

// Onresult returning attribute 'onresult' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) Onresult() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onresult")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnresult setting attribute 'onresult' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) SetOnresult(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onresult", input)
}

// Onnomatch returning attribute 'onnomatch' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) Onnomatch() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onnomatch")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnnomatch setting attribute 'onnomatch' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) SetOnnomatch(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onnomatch", input)
}

// Onerror returning attribute 'onerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) Onerror() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onerror")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnerror setting attribute 'onerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) SetOnerror(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onerror", input)
}

// Onstart returning attribute 'onstart' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) Onstart() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onstart")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnstart setting attribute 'onstart' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) SetOnstart(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onstart", input)
}

// Onend returning attribute 'onend' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) Onend() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onend")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnend setting attribute 'onend' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) SetOnend(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onend", input)
}

func (_this *SpeechRecognition) Start() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("start", _args[0:_end]...)
	return
}

func (_this *SpeechRecognition) Stop() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("stop", _args[0:_end]...)
	return
}

func (_this *SpeechRecognition) Abort() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("abort", _args[0:_end]...)
	return
}

// interface: SpeechRecognitionAlternative
type SpeechRecognitionAlternative struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *SpeechRecognitionAlternative) JSValue() js.Value {
	return _this.Value_JS
}

// SpeechRecognitionAlternativeFromJS is casting a js.Wrapper into SpeechRecognitionAlternative.
func SpeechRecognitionAlternativeFromJS(value js.Wrapper) *SpeechRecognitionAlternative {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &SpeechRecognitionAlternative{}
	ret.Value_JS = input
	return ret
}

// Transcript returning attribute 'transcript' with
// type string (idl: DOMString).
func (_this *SpeechRecognitionAlternative) Transcript() string {
	var ret string
	value := _this.Value_JS.Get("transcript")
	ret = (value).String()
	return ret
}

// Confidence returning attribute 'confidence' with
// type float32 (idl: float).
func (_this *SpeechRecognitionAlternative) Confidence() float32 {
	var ret float32
	value := _this.Value_JS.Get("confidence")
	ret = (float32)((value).Float())
	return ret
}

// interface: SpeechRecognitionErrorEvent
type SpeechRecognitionErrorEvent struct {
	domcore.Event
}

// SpeechRecognitionErrorEventFromJS is casting a js.Wrapper into SpeechRecognitionErrorEvent.
func SpeechRecognitionErrorEventFromJS(value js.Wrapper) *SpeechRecognitionErrorEvent {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &SpeechRecognitionErrorEvent{}
	ret.Value_JS = input
	return ret
}

func NewSpeechRecognitionErrorEvent(_type string, eventInitDict *SpeechRecognitionErrorEventInit) (_result *SpeechRecognitionErrorEvent) {
	_klass := js.Global().Get("SpeechRecognitionErrorEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := eventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SpeechRecognitionErrorEvent // javascript: SpeechRecognitionErrorEvent _what_return_name
	)
	_converted = SpeechRecognitionErrorEventFromJS(_returned)
	_result = _converted
	return
}

// Error returning attribute 'error' with
// type SpeechRecognitionErrorCode (idl: SpeechRecognitionErrorCode).
func (_this *SpeechRecognitionErrorEvent) Error() SpeechRecognitionErrorCode {
	var ret SpeechRecognitionErrorCode
	value := _this.Value_JS.Get("error")
	ret = SpeechRecognitionErrorCodeFromJS(value)
	return ret
}

// Message returning attribute 'message' with
// type string (idl: DOMString).
func (_this *SpeechRecognitionErrorEvent) Message() string {
	var ret string
	value := _this.Value_JS.Get("message")
	ret = (value).String()
	return ret
}

// interface: SpeechRecognitionEvent
type SpeechRecognitionEvent struct {
	domcore.Event
}

// SpeechRecognitionEventFromJS is casting a js.Wrapper into SpeechRecognitionEvent.
func SpeechRecognitionEventFromJS(value js.Wrapper) *SpeechRecognitionEvent {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &SpeechRecognitionEvent{}
	ret.Value_JS = input
	return ret
}

func NewSpeechRecognitionEvent(_type string, eventInitDict *SpeechRecognitionEventInit) (_result *SpeechRecognitionEvent) {
	_klass := js.Global().Get("SpeechRecognitionEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := eventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SpeechRecognitionEvent // javascript: SpeechRecognitionEvent _what_return_name
	)
	_converted = SpeechRecognitionEventFromJS(_returned)
	_result = _converted
	return
}

// ResultIndex returning attribute 'resultIndex' with
// type uint (idl: unsigned long).
func (_this *SpeechRecognitionEvent) ResultIndex() uint {
	var ret uint
	value := _this.Value_JS.Get("resultIndex")
	ret = (uint)((value).Int())
	return ret
}

// Results returning attribute 'results' with
// type SpeechRecognitionResultList (idl: SpeechRecognitionResultList).
func (_this *SpeechRecognitionEvent) Results() *SpeechRecognitionResultList {
	var ret *SpeechRecognitionResultList
	value := _this.Value_JS.Get("results")
	ret = SpeechRecognitionResultListFromJS(value)
	return ret
}

// Interpretation returning attribute 'interpretation' with
// type Any (idl: any).
func (_this *SpeechRecognitionEvent) Interpretation() js.Value {
	var ret js.Value
	value := _this.Value_JS.Get("interpretation")
	ret = value
	return ret
}

// Emma returning attribute 'emma' with
// type js.Value (idl: <rawjs>).
func (_this *SpeechRecognitionEvent) Emma() js.Value {
	var ret js.Value
	value := _this.Value_JS.Get("emma")
	ret = value
	return ret
}

// interface: SpeechRecognitionResult
type SpeechRecognitionResult struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *SpeechRecognitionResult) JSValue() js.Value {
	return _this.Value_JS
}

// SpeechRecognitionResultFromJS is casting a js.Wrapper into SpeechRecognitionResult.
func SpeechRecognitionResultFromJS(value js.Wrapper) *SpeechRecognitionResult {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &SpeechRecognitionResult{}
	ret.Value_JS = input
	return ret
}

// Length returning attribute 'length' with
// type uint (idl: unsigned long).
func (_this *SpeechRecognitionResult) Length() uint {
	var ret uint
	value := _this.Value_JS.Get("length")
	ret = (uint)((value).Int())
	return ret
}

// IsFinal returning attribute 'isFinal' with
// type bool (idl: boolean).
func (_this *SpeechRecognitionResult) IsFinal() bool {
	var ret bool
	value := _this.Value_JS.Get("isFinal")
	ret = (value).Bool()
	return ret
}

func (_this *SpeechRecognitionResult) Item(index uint) (_result *SpeechRecognitionAlternative) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := index
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("item", _args[0:_end]...)
	var (
		_converted *SpeechRecognitionAlternative // javascript: SpeechRecognitionAlternative _what_return_name
	)
	_converted = SpeechRecognitionAlternativeFromJS(_returned)
	_result = _converted
	return
}

// interface: SpeechRecognitionResultList
type SpeechRecognitionResultList struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *SpeechRecognitionResultList) JSValue() js.Value {
	return _this.Value_JS
}

// SpeechRecognitionResultListFromJS is casting a js.Wrapper into SpeechRecognitionResultList.
func SpeechRecognitionResultListFromJS(value js.Wrapper) *SpeechRecognitionResultList {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &SpeechRecognitionResultList{}
	ret.Value_JS = input
	return ret
}

// Length returning attribute 'length' with
// type uint (idl: unsigned long).
func (_this *SpeechRecognitionResultList) Length() uint {
	var ret uint
	value := _this.Value_JS.Get("length")
	ret = (uint)((value).Int())
	return ret
}

func (_this *SpeechRecognitionResultList) Item(index uint) (_result *SpeechRecognitionResult) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := index
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("item", _args[0:_end]...)
	var (
		_converted *SpeechRecognitionResult // javascript: SpeechRecognitionResult _what_return_name
	)
	_converted = SpeechRecognitionResultFromJS(_returned)
	_result = _converted
	return
}

// interface: SpeechSynthesis
type SpeechSynthesis struct {
	domcore.EventTarget
}

// SpeechSynthesisFromJS is casting a js.Wrapper into SpeechSynthesis.
func SpeechSynthesisFromJS(value js.Wrapper) *SpeechSynthesis {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &SpeechSynthesis{}
	ret.Value_JS = input
	return ret
}

// Pending returning attribute 'pending' with
// type bool (idl: boolean).
func (_this *SpeechSynthesis) Pending() bool {
	var ret bool
	value := _this.Value_JS.Get("pending")
	ret = (value).Bool()
	return ret
}

// Speaking returning attribute 'speaking' with
// type bool (idl: boolean).
func (_this *SpeechSynthesis) Speaking() bool {
	var ret bool
	value := _this.Value_JS.Get("speaking")
	ret = (value).Bool()
	return ret
}

// Paused returning attribute 'paused' with
// type bool (idl: boolean).
func (_this *SpeechSynthesis) Paused() bool {
	var ret bool
	value := _this.Value_JS.Get("paused")
	ret = (value).Bool()
	return ret
}

// Onvoiceschanged returning attribute 'onvoiceschanged' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesis) Onvoiceschanged() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onvoiceschanged")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnvoiceschanged setting attribute 'onvoiceschanged' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesis) SetOnvoiceschanged(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onvoiceschanged", input)
}

func (_this *SpeechSynthesis) Speak(utterance *SpeechSynthesisUtterance) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := utterance.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("speak", _args[0:_end]...)
	return
}

func (_this *SpeechSynthesis) Cancel() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("cancel", _args[0:_end]...)
	return
}

func (_this *SpeechSynthesis) Pause() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("pause", _args[0:_end]...)
	return
}

func (_this *SpeechSynthesis) Resume() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("resume", _args[0:_end]...)
	return
}

func (_this *SpeechSynthesis) GetVoices() (_result []*SpeechSynthesisVoice) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getVoices", _args[0:_end]...)
	var (
		_converted []*SpeechSynthesisVoice // javascript: sequence<SpeechSynthesisVoice> _what_return_name
	)
	__length0 := _returned.Length()
	__array0 := make([]*SpeechSynthesisVoice, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *SpeechSynthesisVoice
		__seq_in0 := _returned.Index(__idx0)
		__seq_out0 = SpeechSynthesisVoiceFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	_converted = __array0
	_result = _converted
	return
}

// interface: SpeechSynthesisErrorEvent
type SpeechSynthesisErrorEvent struct {
	SpeechSynthesisEvent
}

// SpeechSynthesisErrorEventFromJS is casting a js.Wrapper into SpeechSynthesisErrorEvent.
func SpeechSynthesisErrorEventFromJS(value js.Wrapper) *SpeechSynthesisErrorEvent {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &SpeechSynthesisErrorEvent{}
	ret.Value_JS = input
	return ret
}

func NewSpeechSynthesisErrorEvent(_type string, eventInitDict *SpeechSynthesisErrorEventInit) (_result *SpeechSynthesisErrorEvent) {
	_klass := js.Global().Get("SpeechSynthesisErrorEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := eventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SpeechSynthesisErrorEvent // javascript: SpeechSynthesisErrorEvent _what_return_name
	)
	_converted = SpeechSynthesisErrorEventFromJS(_returned)
	_result = _converted
	return
}

// Error returning attribute 'error' with
// type SpeechSynthesisErrorCode (idl: SpeechSynthesisErrorCode).
func (_this *SpeechSynthesisErrorEvent) Error() SpeechSynthesisErrorCode {
	var ret SpeechSynthesisErrorCode
	value := _this.Value_JS.Get("error")
	ret = SpeechSynthesisErrorCodeFromJS(value)
	return ret
}

// interface: SpeechSynthesisEvent
type SpeechSynthesisEvent struct {
	domcore.Event
}

// SpeechSynthesisEventFromJS is casting a js.Wrapper into SpeechSynthesisEvent.
func SpeechSynthesisEventFromJS(value js.Wrapper) *SpeechSynthesisEvent {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &SpeechSynthesisEvent{}
	ret.Value_JS = input
	return ret
}

func NewSpeechSynthesisEvent(_type string, eventInitDict *SpeechSynthesisEventInit) (_result *SpeechSynthesisEvent) {
	_klass := js.Global().Get("SpeechSynthesisEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := eventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SpeechSynthesisEvent // javascript: SpeechSynthesisEvent _what_return_name
	)
	_converted = SpeechSynthesisEventFromJS(_returned)
	_result = _converted
	return
}

// Utterance returning attribute 'utterance' with
// type SpeechSynthesisUtterance (idl: SpeechSynthesisUtterance).
func (_this *SpeechSynthesisEvent) Utterance() *SpeechSynthesisUtterance {
	var ret *SpeechSynthesisUtterance
	value := _this.Value_JS.Get("utterance")
	ret = SpeechSynthesisUtteranceFromJS(value)
	return ret
}

// CharIndex returning attribute 'charIndex' with
// type uint (idl: unsigned long).
func (_this *SpeechSynthesisEvent) CharIndex() uint {
	var ret uint
	value := _this.Value_JS.Get("charIndex")
	ret = (uint)((value).Int())
	return ret
}

// ElapsedTime returning attribute 'elapsedTime' with
// type float32 (idl: float).
func (_this *SpeechSynthesisEvent) ElapsedTime() float32 {
	var ret float32
	value := _this.Value_JS.Get("elapsedTime")
	ret = (float32)((value).Float())
	return ret
}

// Name returning attribute 'name' with
// type string (idl: DOMString).
func (_this *SpeechSynthesisEvent) Name() string {
	var ret string
	value := _this.Value_JS.Get("name")
	ret = (value).String()
	return ret
}

// interface: SpeechSynthesisUtterance
type SpeechSynthesisUtterance struct {
	domcore.EventTarget
}

// SpeechSynthesisUtteranceFromJS is casting a js.Wrapper into SpeechSynthesisUtterance.
func SpeechSynthesisUtteranceFromJS(value js.Wrapper) *SpeechSynthesisUtterance {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &SpeechSynthesisUtterance{}
	ret.Value_JS = input
	return ret
}

func NewSpeechSynthesisUtterance(text *string) (_result *SpeechSynthesisUtterance) {
	_klass := js.Global().Get("SpeechSynthesisUtterance")
	var (
		_args [1]interface{}
		_end  int
	)
	if text != nil {
		_p0 := text
		_args[0] = _p0
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SpeechSynthesisUtterance // javascript: SpeechSynthesisUtterance _what_return_name
	)
	_converted = SpeechSynthesisUtteranceFromJS(_returned)
	_result = _converted
	return
}

// Text returning attribute 'text' with
// type string (idl: DOMString).
func (_this *SpeechSynthesisUtterance) Text() string {
	var ret string
	value := _this.Value_JS.Get("text")
	ret = (value).String()
	return ret
}

// SetText setting attribute 'text' with
// type string (idl: DOMString).
func (_this *SpeechSynthesisUtterance) SetText(value string) {
	input := value
	_this.Value_JS.Set("text", input)
}

// Lang returning attribute 'lang' with
// type string (idl: DOMString).
func (_this *SpeechSynthesisUtterance) Lang() string {
	var ret string
	value := _this.Value_JS.Get("lang")
	ret = (value).String()
	return ret
}

// SetLang setting attribute 'lang' with
// type string (idl: DOMString).
func (_this *SpeechSynthesisUtterance) SetLang(value string) {
	input := value
	_this.Value_JS.Set("lang", input)
}

// Voice returning attribute 'voice' with
// type SpeechSynthesisVoice (idl: SpeechSynthesisVoice).
func (_this *SpeechSynthesisUtterance) Voice() *SpeechSynthesisVoice {
	var ret *SpeechSynthesisVoice
	value := _this.Value_JS.Get("voice")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = SpeechSynthesisVoiceFromJS(value)
	}
	return ret
}

// SetVoice setting attribute 'voice' with
// type SpeechSynthesisVoice (idl: SpeechSynthesisVoice).
func (_this *SpeechSynthesisUtterance) SetVoice(value *SpeechSynthesisVoice) {
	input := value.JSValue()
	_this.Value_JS.Set("voice", input)
}

// Volume returning attribute 'volume' with
// type float32 (idl: float).
func (_this *SpeechSynthesisUtterance) Volume() float32 {
	var ret float32
	value := _this.Value_JS.Get("volume")
	ret = (float32)((value).Float())
	return ret
}

// SetVolume setting attribute 'volume' with
// type float32 (idl: float).
func (_this *SpeechSynthesisUtterance) SetVolume(value float32) {
	input := value
	_this.Value_JS.Set("volume", input)
}

// Rate returning attribute 'rate' with
// type float32 (idl: float).
func (_this *SpeechSynthesisUtterance) Rate() float32 {
	var ret float32
	value := _this.Value_JS.Get("rate")
	ret = (float32)((value).Float())
	return ret
}

// SetRate setting attribute 'rate' with
// type float32 (idl: float).
func (_this *SpeechSynthesisUtterance) SetRate(value float32) {
	input := value
	_this.Value_JS.Set("rate", input)
}

// Pitch returning attribute 'pitch' with
// type float32 (idl: float).
func (_this *SpeechSynthesisUtterance) Pitch() float32 {
	var ret float32
	value := _this.Value_JS.Get("pitch")
	ret = (float32)((value).Float())
	return ret
}

// SetPitch setting attribute 'pitch' with
// type float32 (idl: float).
func (_this *SpeechSynthesisUtterance) SetPitch(value float32) {
	input := value
	_this.Value_JS.Set("pitch", input)
}

// Onstart returning attribute 'onstart' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) Onstart() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onstart")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnstart setting attribute 'onstart' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) SetOnstart(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onstart", input)
}

// Onend returning attribute 'onend' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) Onend() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onend")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnend setting attribute 'onend' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) SetOnend(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onend", input)
}

// Onerror returning attribute 'onerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) Onerror() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onerror")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnerror setting attribute 'onerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) SetOnerror(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onerror", input)
}

// Onpause returning attribute 'onpause' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) Onpause() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onpause")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnpause setting attribute 'onpause' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) SetOnpause(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onpause", input)
}

// Onresume returning attribute 'onresume' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) Onresume() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onresume")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnresume setting attribute 'onresume' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) SetOnresume(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onresume", input)
}

// Onmark returning attribute 'onmark' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) Onmark() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onmark")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnmark setting attribute 'onmark' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) SetOnmark(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onmark", input)
}

// Onboundary returning attribute 'onboundary' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) Onboundary() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onboundary")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnboundary setting attribute 'onboundary' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) SetOnboundary(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onboundary", input)
}

// interface: SpeechSynthesisVoice
type SpeechSynthesisVoice struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *SpeechSynthesisVoice) JSValue() js.Value {
	return _this.Value_JS
}

// SpeechSynthesisVoiceFromJS is casting a js.Wrapper into SpeechSynthesisVoice.
func SpeechSynthesisVoiceFromJS(value js.Wrapper) *SpeechSynthesisVoice {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &SpeechSynthesisVoice{}
	ret.Value_JS = input
	return ret
}

// VoiceURI returning attribute 'voiceURI' with
// type string (idl: DOMString).
func (_this *SpeechSynthesisVoice) VoiceURI() string {
	var ret string
	value := _this.Value_JS.Get("voiceURI")
	ret = (value).String()
	return ret
}

// Name returning attribute 'name' with
// type string (idl: DOMString).
func (_this *SpeechSynthesisVoice) Name() string {
	var ret string
	value := _this.Value_JS.Get("name")
	ret = (value).String()
	return ret
}

// Lang returning attribute 'lang' with
// type string (idl: DOMString).
func (_this *SpeechSynthesisVoice) Lang() string {
	var ret string
	value := _this.Value_JS.Get("lang")
	ret = (value).String()
	return ret
}

// LocalService returning attribute 'localService' with
// type bool (idl: boolean).
func (_this *SpeechSynthesisVoice) LocalService() bool {
	var ret bool
	value := _this.Value_JS.Get("localService")
	ret = (value).Bool()
	return ret
}

// Default returning attribute 'default' with
// type bool (idl: boolean).
func (_this *SpeechSynthesisVoice) Default() bool {
	var ret bool
	value := _this.Value_JS.Get("default")
	ret = (value).Bool()
	return ret
}
