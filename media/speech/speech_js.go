// Code generated by webidl-bind. DO NOT EDIT.

package speech

import "syscall/js"

import (
	"github.com/gowebapi/webapi/core"
	"github.com/gowebapi/webapi/dom/domcore"
)

// using following types:
// domcore.Event
// domcore.EventHandler
// domcore.EventTarget

// source idl files:
// speech-api.idl

// transform files:
// speech-api.go.md

// workaround for compiler error
func unused(value interface{}) {
	// TODO remove this method
}

type Union struct {
	Value js.Value
}

func (u *Union) JSValue() js.Value {
	return u.Value
}

func UnionFromJS(value js.Value) *Union {
	return &Union{Value: value}
}

// enum: SpeechRecognitionErrorCode
type SpeechRecognitionErrorCode int

const (
	NoSpeechSpeechRecognitionErrorCode SpeechRecognitionErrorCode = iota
	AbortedSpeechRecognitionErrorCode
	AudioCaptureSpeechRecognitionErrorCode
	NetworkSpeechRecognitionErrorCode
	NotAllowedSpeechRecognitionErrorCode
	ServiceNotAllowedSpeechRecognitionErrorCode
	BadGrammarSpeechRecognitionErrorCode
	LanguageNotSupportedSpeechRecognitionErrorCode
)

var speechRecognitionErrorCodeToWasmTable = []string{
	"no-speech", "aborted", "audio-capture", "network", "not-allowed", "service-not-allowed", "bad-grammar", "language-not-supported",
}

var speechRecognitionErrorCodeFromWasmTable = map[string]SpeechRecognitionErrorCode{
	"no-speech": NoSpeechSpeechRecognitionErrorCode, "aborted": AbortedSpeechRecognitionErrorCode, "audio-capture": AudioCaptureSpeechRecognitionErrorCode, "network": NetworkSpeechRecognitionErrorCode, "not-allowed": NotAllowedSpeechRecognitionErrorCode, "service-not-allowed": ServiceNotAllowedSpeechRecognitionErrorCode, "bad-grammar": BadGrammarSpeechRecognitionErrorCode, "language-not-supported": LanguageNotSupportedSpeechRecognitionErrorCode,
}

// JSValue is converting this enum into a javascript object
func (this *SpeechRecognitionErrorCode) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this SpeechRecognitionErrorCode) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(speechRecognitionErrorCodeToWasmTable) {
		return speechRecognitionErrorCodeToWasmTable[idx]
	}
	panic("unknown input value")
}

// SpeechRecognitionErrorCodeFromJS is converting a javascript value into
// a SpeechRecognitionErrorCode enum value.
func SpeechRecognitionErrorCodeFromJS(value js.Value) SpeechRecognitionErrorCode {
	key := value.String()
	conv, ok := speechRecognitionErrorCodeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: SpeechSynthesisErrorCode
type SpeechSynthesisErrorCode int

const (
	CanceledSpeechSynthesisErrorCode SpeechSynthesisErrorCode = iota
	InterruptedSpeechSynthesisErrorCode
	AudioBusySpeechSynthesisErrorCode
	AudioHardwareSpeechSynthesisErrorCode
	NetworkSpeechSynthesisErrorCode
	SynthesisUnavailableSpeechSynthesisErrorCode
	SynthesisFailedSpeechSynthesisErrorCode
	LanguageUnavailableSpeechSynthesisErrorCode
	VoiceUnavailableSpeechSynthesisErrorCode
	TextTooLongSpeechSynthesisErrorCode
	InvalidArgumentSpeechSynthesisErrorCode
	NotAllowedSpeechSynthesisErrorCode
)

var speechSynthesisErrorCodeToWasmTable = []string{
	"canceled", "interrupted", "audio-busy", "audio-hardware", "network", "synthesis-unavailable", "synthesis-failed", "language-unavailable", "voice-unavailable", "text-too-long", "invalid-argument", "not-allowed",
}

var speechSynthesisErrorCodeFromWasmTable = map[string]SpeechSynthesisErrorCode{
	"canceled": CanceledSpeechSynthesisErrorCode, "interrupted": InterruptedSpeechSynthesisErrorCode, "audio-busy": AudioBusySpeechSynthesisErrorCode, "audio-hardware": AudioHardwareSpeechSynthesisErrorCode, "network": NetworkSpeechSynthesisErrorCode, "synthesis-unavailable": SynthesisUnavailableSpeechSynthesisErrorCode, "synthesis-failed": SynthesisFailedSpeechSynthesisErrorCode, "language-unavailable": LanguageUnavailableSpeechSynthesisErrorCode, "voice-unavailable": VoiceUnavailableSpeechSynthesisErrorCode, "text-too-long": TextTooLongSpeechSynthesisErrorCode, "invalid-argument": InvalidArgumentSpeechSynthesisErrorCode, "not-allowed": NotAllowedSpeechSynthesisErrorCode,
}

// JSValue is converting this enum into a javascript object
func (this *SpeechSynthesisErrorCode) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this SpeechSynthesisErrorCode) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(speechSynthesisErrorCodeToWasmTable) {
		return speechSynthesisErrorCodeToWasmTable[idx]
	}
	panic("unknown input value")
}

// SpeechSynthesisErrorCodeFromJS is converting a javascript value into
// a SpeechSynthesisErrorCode enum value.
func SpeechSynthesisErrorCodeFromJS(value js.Value) SpeechSynthesisErrorCode {
	key := value.String()
	conv, ok := speechSynthesisErrorCodeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// dictionary: SpeechRecognitionErrorEventInit
type SpeechRecognitionErrorEventInit struct {
	Bubbles    bool
	Cancelable bool
	Composed   bool
	Error      SpeechRecognitionErrorCode
	Message    string
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *SpeechRecognitionErrorEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Error.JSValue()
	out.Set("error", value3)
	value4 := _this.Message
	out.Set("message", value4)
	return out
}

// SpeechRecognitionErrorEventInitFromJS is allocating a new
// SpeechRecognitionErrorEventInit object and copy all values in the value javascript object.
func SpeechRecognitionErrorEventInitFromJS(value js.Value) *SpeechRecognitionErrorEventInit {
	var out SpeechRecognitionErrorEventInit
	var (
		value0 bool                       // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool                       // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool                       // javascript: boolean {composed Composed composed}
		value3 SpeechRecognitionErrorCode // javascript: SpeechRecognitionErrorCode {error Error _error}
		value4 string                     // javascript: DOMString {message Message message}
	)
	value0 = (value.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (value.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (value.Get("composed")).Bool()
	out.Composed = value2
	value3 = SpeechRecognitionErrorCodeFromJS(value.Get("error"))
	out.Error = value3
	value4 = (value.Get("message")).String()
	out.Message = value4
	return &out
}

// dictionary: SpeechRecognitionEventInit
type SpeechRecognitionEventInit struct {
	Bubbles        bool
	Cancelable     bool
	Composed       bool
	ResultIndex    uint
	Results        *SpeechRecognitionResultList
	Interpretation js.Value
	Emma           js.Value
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *SpeechRecognitionEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.ResultIndex
	out.Set("resultIndex", value3)
	value4 := _this.Results.JSValue()
	out.Set("results", value4)
	value5 := _this.Interpretation
	out.Set("interpretation", value5)
	value6 := _this.Emma
	out.Set("emma", value6)
	return out
}

// SpeechRecognitionEventInitFromJS is allocating a new
// SpeechRecognitionEventInit object and copy all values in the value javascript object.
func SpeechRecognitionEventInitFromJS(value js.Value) *SpeechRecognitionEventInit {
	var out SpeechRecognitionEventInit
	var (
		value0 bool                         // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool                         // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool                         // javascript: boolean {composed Composed composed}
		value3 uint                         // javascript: unsigned long {resultIndex ResultIndex resultIndex}
		value4 *SpeechRecognitionResultList // javascript: SpeechRecognitionResultList {results Results results}
		value5 js.Value                     // javascript: any {interpretation Interpretation interpretation}
		value6 js.Value                     // javascript: Document {emma Emma emma}
	)
	value0 = (value.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (value.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (value.Get("composed")).Bool()
	out.Composed = value2
	value3 = (uint)((value.Get("resultIndex")).Int())
	out.ResultIndex = value3
	value4 = SpeechRecognitionResultListFromJS(value.Get("results"))
	out.Results = value4
	value5 = value.Get("interpretation")
	out.Interpretation = value5
	value6 = value.Get("emma")
	out.Emma = value6
	return &out
}

// dictionary: SpeechSynthesisErrorEventInit
type SpeechSynthesisErrorEventInit struct {
	Bubbles     bool
	Cancelable  bool
	Composed    bool
	Utterance   *SpeechSynthesisUtterance
	CharIndex   uint
	ElapsedTime float32
	Name        string
	Error       SpeechSynthesisErrorCode
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *SpeechSynthesisErrorEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Utterance.JSValue()
	out.Set("utterance", value3)
	value4 := _this.CharIndex
	out.Set("charIndex", value4)
	value5 := _this.ElapsedTime
	out.Set("elapsedTime", value5)
	value6 := _this.Name
	out.Set("name", value6)
	value7 := _this.Error.JSValue()
	out.Set("error", value7)
	return out
}

// SpeechSynthesisErrorEventInitFromJS is allocating a new
// SpeechSynthesisErrorEventInit object and copy all values in the value javascript object.
func SpeechSynthesisErrorEventInitFromJS(value js.Value) *SpeechSynthesisErrorEventInit {
	var out SpeechSynthesisErrorEventInit
	var (
		value0 bool                      // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool                      // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool                      // javascript: boolean {composed Composed composed}
		value3 *SpeechSynthesisUtterance // javascript: SpeechSynthesisUtterance {utterance Utterance utterance}
		value4 uint                      // javascript: unsigned long {charIndex CharIndex charIndex}
		value5 float32                   // javascript: float {elapsedTime ElapsedTime elapsedTime}
		value6 string                    // javascript: DOMString {name Name name}
		value7 SpeechSynthesisErrorCode  // javascript: SpeechSynthesisErrorCode {error Error _error}
	)
	value0 = (value.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (value.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (value.Get("composed")).Bool()
	out.Composed = value2
	value3 = SpeechSynthesisUtteranceFromJS(value.Get("utterance"))
	out.Utterance = value3
	value4 = (uint)((value.Get("charIndex")).Int())
	out.CharIndex = value4
	value5 = (float32)((value.Get("elapsedTime")).Float())
	out.ElapsedTime = value5
	value6 = (value.Get("name")).String()
	out.Name = value6
	value7 = SpeechSynthesisErrorCodeFromJS(value.Get("error"))
	out.Error = value7
	return &out
}

// dictionary: SpeechSynthesisEventInit
type SpeechSynthesisEventInit struct {
	Bubbles     bool
	Cancelable  bool
	Composed    bool
	Utterance   *SpeechSynthesisUtterance
	CharIndex   uint
	ElapsedTime float32
	Name        string
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *SpeechSynthesisEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Utterance.JSValue()
	out.Set("utterance", value3)
	value4 := _this.CharIndex
	out.Set("charIndex", value4)
	value5 := _this.ElapsedTime
	out.Set("elapsedTime", value5)
	value6 := _this.Name
	out.Set("name", value6)
	return out
}

// SpeechSynthesisEventInitFromJS is allocating a new
// SpeechSynthesisEventInit object and copy all values in the value javascript object.
func SpeechSynthesisEventInitFromJS(value js.Value) *SpeechSynthesisEventInit {
	var out SpeechSynthesisEventInit
	var (
		value0 bool                      // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool                      // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool                      // javascript: boolean {composed Composed composed}
		value3 *SpeechSynthesisUtterance // javascript: SpeechSynthesisUtterance {utterance Utterance utterance}
		value4 uint                      // javascript: unsigned long {charIndex CharIndex charIndex}
		value5 float32                   // javascript: float {elapsedTime ElapsedTime elapsedTime}
		value6 string                    // javascript: DOMString {name Name name}
	)
	value0 = (value.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (value.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (value.Get("composed")).Bool()
	out.Composed = value2
	value3 = SpeechSynthesisUtteranceFromJS(value.Get("utterance"))
	out.Utterance = value3
	value4 = (uint)((value.Get("charIndex")).Int())
	out.CharIndex = value4
	value5 = (float32)((value.Get("elapsedTime")).Float())
	out.ElapsedTime = value5
	value6 = (value.Get("name")).String()
	out.Name = value6
	return &out
}

// class: SpeechGrammar
type SpeechGrammar struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *SpeechGrammar) JSValue() js.Value {
	return _this.Value_JS
}

// SpeechGrammarFromJS is casting a js.Value into SpeechGrammar.
func SpeechGrammarFromJS(value js.Value) *SpeechGrammar {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &SpeechGrammar{}
	ret.Value_JS = value
	return ret
}

// SpeechGrammarFromJS is casting from something that holds a js.Value into SpeechGrammar.
func SpeechGrammarFromWrapper(input core.Wrapper) *SpeechGrammar {
	return SpeechGrammarFromJS(input.JSValue())
}

func NewSpeechGrammar() (_result *SpeechGrammar) {
	_klass := js.Global().Get("SpeechGrammar")
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SpeechGrammar // javascript: SpeechGrammar _what_return_name
	)
	_converted = SpeechGrammarFromJS(_returned)
	_result = _converted
	return
}

// Src returning attribute 'src' with
// type string (idl: DOMString).
func (_this *SpeechGrammar) Src() string {
	var ret string
	value := _this.Value_JS.Get("src")
	ret = (value).String()
	return ret
}

// SetSrc setting attribute 'src' with
// type string (idl: DOMString).
func (_this *SpeechGrammar) SetSrc(value string) {
	input := value
	_this.Value_JS.Set("src", input)
}

// Weight returning attribute 'weight' with
// type float32 (idl: float).
func (_this *SpeechGrammar) Weight() float32 {
	var ret float32
	value := _this.Value_JS.Get("weight")
	ret = (float32)((value).Float())
	return ret
}

// SetWeight setting attribute 'weight' with
// type float32 (idl: float).
func (_this *SpeechGrammar) SetWeight(value float32) {
	input := value
	_this.Value_JS.Set("weight", input)
}

// class: SpeechGrammarList
type SpeechGrammarList struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *SpeechGrammarList) JSValue() js.Value {
	return _this.Value_JS
}

// SpeechGrammarListFromJS is casting a js.Value into SpeechGrammarList.
func SpeechGrammarListFromJS(value js.Value) *SpeechGrammarList {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &SpeechGrammarList{}
	ret.Value_JS = value
	return ret
}

// SpeechGrammarListFromJS is casting from something that holds a js.Value into SpeechGrammarList.
func SpeechGrammarListFromWrapper(input core.Wrapper) *SpeechGrammarList {
	return SpeechGrammarListFromJS(input.JSValue())
}

func NewSpeechGrammarList() (_result *SpeechGrammarList) {
	_klass := js.Global().Get("SpeechGrammarList")
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SpeechGrammarList // javascript: SpeechGrammarList _what_return_name
	)
	_converted = SpeechGrammarListFromJS(_returned)
	_result = _converted
	return
}

// Length returning attribute 'length' with
// type uint (idl: unsigned long).
func (_this *SpeechGrammarList) Length() uint {
	var ret uint
	value := _this.Value_JS.Get("length")
	ret = (uint)((value).Int())
	return ret
}

func (_this *SpeechGrammarList) Index(index uint) (_result *SpeechGrammar) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := index
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("item", _args[0:_end]...)
	var (
		_converted *SpeechGrammar // javascript: SpeechGrammar _what_return_name
	)
	_converted = SpeechGrammarFromJS(_returned)
	_result = _converted
	return
}

func (_this *SpeechGrammarList) Item(index uint) (_result *SpeechGrammar) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := index
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("item", _args[0:_end]...)
	var (
		_converted *SpeechGrammar // javascript: SpeechGrammar _what_return_name
	)
	_converted = SpeechGrammarFromJS(_returned)
	_result = _converted
	return
}

func (_this *SpeechGrammarList) AddFromURI(src string, weight *float32) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := src
	_args[0] = _p0
	_end++
	if weight != nil {

		var _p1 interface{}
		if weight != nil {
			_p1 = *(weight)
		} else {
			_p1 = nil
		}
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("addFromURI", _args[0:_end]...)
	return
}

func (_this *SpeechGrammarList) AddFromString(string string, weight *float32) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := string
	_args[0] = _p0
	_end++
	if weight != nil {

		var _p1 interface{}
		if weight != nil {
			_p1 = *(weight)
		} else {
			_p1 = nil
		}
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("addFromString", _args[0:_end]...)
	return
}

// class: SpeechRecognition
type SpeechRecognition struct {
	domcore.EventTarget
}

// SpeechRecognitionFromJS is casting a js.Value into SpeechRecognition.
func SpeechRecognitionFromJS(value js.Value) *SpeechRecognition {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &SpeechRecognition{}
	ret.Value_JS = value
	return ret
}

// SpeechRecognitionFromJS is casting from something that holds a js.Value into SpeechRecognition.
func SpeechRecognitionFromWrapper(input core.Wrapper) *SpeechRecognition {
	return SpeechRecognitionFromJS(input.JSValue())
}

func NewSpeechRecognition() (_result *SpeechRecognition) {
	_klass := js.Global().Get("SpeechRecognition")
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SpeechRecognition // javascript: SpeechRecognition _what_return_name
	)
	_converted = SpeechRecognitionFromJS(_returned)
	_result = _converted
	return
}

// Grammars returning attribute 'grammars' with
// type SpeechGrammarList (idl: SpeechGrammarList).
func (_this *SpeechRecognition) Grammars() *SpeechGrammarList {
	var ret *SpeechGrammarList
	value := _this.Value_JS.Get("grammars")
	ret = SpeechGrammarListFromJS(value)
	return ret
}

// SetGrammars setting attribute 'grammars' with
// type SpeechGrammarList (idl: SpeechGrammarList).
func (_this *SpeechRecognition) SetGrammars(value *SpeechGrammarList) {
	input := value.JSValue()
	_this.Value_JS.Set("grammars", input)
}

// Lang returning attribute 'lang' with
// type string (idl: DOMString).
func (_this *SpeechRecognition) Lang() string {
	var ret string
	value := _this.Value_JS.Get("lang")
	ret = (value).String()
	return ret
}

// SetLang setting attribute 'lang' with
// type string (idl: DOMString).
func (_this *SpeechRecognition) SetLang(value string) {
	input := value
	_this.Value_JS.Set("lang", input)
}

// Continuous returning attribute 'continuous' with
// type bool (idl: boolean).
func (_this *SpeechRecognition) Continuous() bool {
	var ret bool
	value := _this.Value_JS.Get("continuous")
	ret = (value).Bool()
	return ret
}

// SetContinuous setting attribute 'continuous' with
// type bool (idl: boolean).
func (_this *SpeechRecognition) SetContinuous(value bool) {
	input := value
	_this.Value_JS.Set("continuous", input)
}

// InterimResults returning attribute 'interimResults' with
// type bool (idl: boolean).
func (_this *SpeechRecognition) InterimResults() bool {
	var ret bool
	value := _this.Value_JS.Get("interimResults")
	ret = (value).Bool()
	return ret
}

// SetInterimResults setting attribute 'interimResults' with
// type bool (idl: boolean).
func (_this *SpeechRecognition) SetInterimResults(value bool) {
	input := value
	_this.Value_JS.Set("interimResults", input)
}

// MaxAlternatives returning attribute 'maxAlternatives' with
// type uint (idl: unsigned long).
func (_this *SpeechRecognition) MaxAlternatives() uint {
	var ret uint
	value := _this.Value_JS.Get("maxAlternatives")
	ret = (uint)((value).Int())
	return ret
}

// SetMaxAlternatives setting attribute 'maxAlternatives' with
// type uint (idl: unsigned long).
func (_this *SpeechRecognition) SetMaxAlternatives(value uint) {
	input := value
	_this.Value_JS.Set("maxAlternatives", input)
}

// ServiceURI returning attribute 'serviceURI' with
// type string (idl: DOMString).
func (_this *SpeechRecognition) ServiceURI() string {
	var ret string
	value := _this.Value_JS.Get("serviceURI")
	ret = (value).String()
	return ret
}

// SetServiceURI setting attribute 'serviceURI' with
// type string (idl: DOMString).
func (_this *SpeechRecognition) SetServiceURI(value string) {
	input := value
	_this.Value_JS.Set("serviceURI", input)
}

// OnAudioStart returning attribute 'onaudiostart' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) OnAudioStart() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onaudiostart")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnSoundStart returning attribute 'onsoundstart' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) OnSoundStart() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onsoundstart")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnSpeechStart returning attribute 'onspeechstart' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) OnSpeechStart() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onspeechstart")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnSpeechEnd returning attribute 'onspeechend' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) OnSpeechEnd() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onspeechend")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnSoundEnd returning attribute 'onsoundend' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) OnSoundEnd() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onsoundend")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnAudioEnd returning attribute 'onaudioend' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) OnAudioEnd() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onaudioend")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnResult returning attribute 'onresult' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) OnResult() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onresult")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnNoMatch returning attribute 'onnomatch' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) OnNoMatch() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onnomatch")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnError returning attribute 'onerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) OnError() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onerror")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnStart returning attribute 'onstart' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) OnStart() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onstart")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnEnd returning attribute 'onend' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechRecognition) OnEnd() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onend")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// event attribute: domcore.Event
func eventFuncSpeechRecognition_domcore_Event(listener func(event *domcore.Event, target *SpeechRecognition)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *domcore.Event
		value := args[0]
		incoming := value.Get("target")
		ret = domcore.EventFromJS(value)
		src := SpeechRecognitionFromJS(incoming)
		listener(ret, src)
		return js.Undefined()
	}
	return js.FuncOf(fn)
}

// AddAudioEnd is adding doing AddEventListener for 'AudioEnd' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) AddEventAudioEnd(listener func(event *domcore.Event, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "audioend", cb)
	return cb
}

// SetOnAudioEnd is assigning a function to 'onaudioend'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) SetOnAudioEnd(listener func(event *domcore.Event, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_domcore_Event(listener)
	_this.Value_JS.Set("onaudioend", cb)
	return cb
}

// AddAudioStart is adding doing AddEventListener for 'AudioStart' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) AddEventAudioStart(listener func(event *domcore.Event, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "audiostart", cb)
	return cb
}

// SetOnAudioStart is assigning a function to 'onaudiostart'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) SetOnAudioStart(listener func(event *domcore.Event, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_domcore_Event(listener)
	_this.Value_JS.Set("onaudiostart", cb)
	return cb
}

// AddEnd is adding doing AddEventListener for 'End' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) AddEventEnd(listener func(event *domcore.Event, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "end", cb)
	return cb
}

// SetOnEnd is assigning a function to 'onend'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) SetOnEnd(listener func(event *domcore.Event, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_domcore_Event(listener)
	_this.Value_JS.Set("onend", cb)
	return cb
}

// event attribute: SpeechRecognitionErrorEvent
func eventFuncSpeechRecognition_SpeechRecognitionErrorEvent(listener func(event *SpeechRecognitionErrorEvent, target *SpeechRecognition)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *SpeechRecognitionErrorEvent
		value := args[0]
		incoming := value.Get("target")
		ret = SpeechRecognitionErrorEventFromJS(value)
		src := SpeechRecognitionFromJS(incoming)
		listener(ret, src)
		return js.Undefined()
	}
	return js.FuncOf(fn)
}

// AddError is adding doing AddEventListener for 'Error' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) AddEventError(listener func(event *SpeechRecognitionErrorEvent, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_SpeechRecognitionErrorEvent(listener)
	_this.Value_JS.Call("addEventListener", "error", cb)
	return cb
}

// SetOnError is assigning a function to 'onerror'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) SetOnError(listener func(event *SpeechRecognitionErrorEvent, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_SpeechRecognitionErrorEvent(listener)
	_this.Value_JS.Set("onerror", cb)
	return cb
}

// event attribute: SpeechRecognitionEvent
func eventFuncSpeechRecognition_SpeechRecognitionEvent(listener func(event *SpeechRecognitionEvent, target *SpeechRecognition)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *SpeechRecognitionEvent
		value := args[0]
		incoming := value.Get("target")
		ret = SpeechRecognitionEventFromJS(value)
		src := SpeechRecognitionFromJS(incoming)
		listener(ret, src)
		return js.Undefined()
	}
	return js.FuncOf(fn)
}

// AddNoMatch is adding doing AddEventListener for 'NoMatch' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) AddEventNoMatch(listener func(event *SpeechRecognitionEvent, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_SpeechRecognitionEvent(listener)
	_this.Value_JS.Call("addEventListener", "nomatch", cb)
	return cb
}

// SetOnNoMatch is assigning a function to 'onnomatch'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) SetOnNoMatch(listener func(event *SpeechRecognitionEvent, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_SpeechRecognitionEvent(listener)
	_this.Value_JS.Set("onnomatch", cb)
	return cb
}

// AddResult is adding doing AddEventListener for 'Result' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) AddEventResult(listener func(event *SpeechRecognitionEvent, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_SpeechRecognitionEvent(listener)
	_this.Value_JS.Call("addEventListener", "result", cb)
	return cb
}

// SetOnResult is assigning a function to 'onresult'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) SetOnResult(listener func(event *SpeechRecognitionEvent, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_SpeechRecognitionEvent(listener)
	_this.Value_JS.Set("onresult", cb)
	return cb
}

// AddSoundEnd is adding doing AddEventListener for 'SoundEnd' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) AddEventSoundEnd(listener func(event *domcore.Event, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "soundend", cb)
	return cb
}

// SetOnSoundEnd is assigning a function to 'onsoundend'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) SetOnSoundEnd(listener func(event *domcore.Event, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_domcore_Event(listener)
	_this.Value_JS.Set("onsoundend", cb)
	return cb
}

// AddSoundStart is adding doing AddEventListener for 'SoundStart' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) AddEventSoundStart(listener func(event *domcore.Event, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "soundstart", cb)
	return cb
}

// SetOnSoundStart is assigning a function to 'onsoundstart'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) SetOnSoundStart(listener func(event *domcore.Event, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_domcore_Event(listener)
	_this.Value_JS.Set("onsoundstart", cb)
	return cb
}

// AddSpeechEnd is adding doing AddEventListener for 'SpeechEnd' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) AddEventSpeechEnd(listener func(event *domcore.Event, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "speechend", cb)
	return cb
}

// SetOnSpeechEnd is assigning a function to 'onspeechend'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) SetOnSpeechEnd(listener func(event *domcore.Event, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_domcore_Event(listener)
	_this.Value_JS.Set("onspeechend", cb)
	return cb
}

// AddSpeechStart is adding doing AddEventListener for 'SpeechStart' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) AddEventSpeechStart(listener func(event *domcore.Event, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "speechstart", cb)
	return cb
}

// SetOnSpeechStart is assigning a function to 'onspeechstart'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) SetOnSpeechStart(listener func(event *domcore.Event, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_domcore_Event(listener)
	_this.Value_JS.Set("onspeechstart", cb)
	return cb
}

// AddStart is adding doing AddEventListener for 'Start' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) AddEventStart(listener func(event *domcore.Event, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "start", cb)
	return cb
}

// SetOnStart is assigning a function to 'onstart'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechRecognition) SetOnStart(listener func(event *domcore.Event, currentTarget *SpeechRecognition)) js.Func {
	cb := eventFuncSpeechRecognition_domcore_Event(listener)
	_this.Value_JS.Set("onstart", cb)
	return cb
}

func (_this *SpeechRecognition) Start() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("start", _args[0:_end]...)
	return
}

func (_this *SpeechRecognition) Stop() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("stop", _args[0:_end]...)
	return
}

func (_this *SpeechRecognition) Abort() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("abort", _args[0:_end]...)
	return
}

// class: SpeechRecognitionAlternative
type SpeechRecognitionAlternative struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *SpeechRecognitionAlternative) JSValue() js.Value {
	return _this.Value_JS
}

// SpeechRecognitionAlternativeFromJS is casting a js.Value into SpeechRecognitionAlternative.
func SpeechRecognitionAlternativeFromJS(value js.Value) *SpeechRecognitionAlternative {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &SpeechRecognitionAlternative{}
	ret.Value_JS = value
	return ret
}

// SpeechRecognitionAlternativeFromJS is casting from something that holds a js.Value into SpeechRecognitionAlternative.
func SpeechRecognitionAlternativeFromWrapper(input core.Wrapper) *SpeechRecognitionAlternative {
	return SpeechRecognitionAlternativeFromJS(input.JSValue())
}

// Transcript returning attribute 'transcript' with
// type string (idl: DOMString).
func (_this *SpeechRecognitionAlternative) Transcript() string {
	var ret string
	value := _this.Value_JS.Get("transcript")
	ret = (value).String()
	return ret
}

// Confidence returning attribute 'confidence' with
// type float32 (idl: float).
func (_this *SpeechRecognitionAlternative) Confidence() float32 {
	var ret float32
	value := _this.Value_JS.Get("confidence")
	ret = (float32)((value).Float())
	return ret
}

// class: SpeechRecognitionErrorEvent
type SpeechRecognitionErrorEvent struct {
	domcore.Event
}

// SpeechRecognitionErrorEventFromJS is casting a js.Value into SpeechRecognitionErrorEvent.
func SpeechRecognitionErrorEventFromJS(value js.Value) *SpeechRecognitionErrorEvent {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &SpeechRecognitionErrorEvent{}
	ret.Value_JS = value
	return ret
}

// SpeechRecognitionErrorEventFromJS is casting from something that holds a js.Value into SpeechRecognitionErrorEvent.
func SpeechRecognitionErrorEventFromWrapper(input core.Wrapper) *SpeechRecognitionErrorEvent {
	return SpeechRecognitionErrorEventFromJS(input.JSValue())
}

func NewSpeechRecognitionErrorEvent(_type string, eventInitDict *SpeechRecognitionErrorEventInit) (_result *SpeechRecognitionErrorEvent) {
	_klass := js.Global().Get("SpeechRecognitionErrorEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := eventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SpeechRecognitionErrorEvent // javascript: SpeechRecognitionErrorEvent _what_return_name
	)
	_converted = SpeechRecognitionErrorEventFromJS(_returned)
	_result = _converted
	return
}

// Error returning attribute 'error' with
// type SpeechRecognitionErrorCode (idl: SpeechRecognitionErrorCode).
func (_this *SpeechRecognitionErrorEvent) Error() SpeechRecognitionErrorCode {
	var ret SpeechRecognitionErrorCode
	value := _this.Value_JS.Get("error")
	ret = SpeechRecognitionErrorCodeFromJS(value)
	return ret
}

// Message returning attribute 'message' with
// type string (idl: DOMString).
func (_this *SpeechRecognitionErrorEvent) Message() string {
	var ret string
	value := _this.Value_JS.Get("message")
	ret = (value).String()
	return ret
}

// class: SpeechRecognitionEvent
type SpeechRecognitionEvent struct {
	domcore.Event
}

// SpeechRecognitionEventFromJS is casting a js.Value into SpeechRecognitionEvent.
func SpeechRecognitionEventFromJS(value js.Value) *SpeechRecognitionEvent {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &SpeechRecognitionEvent{}
	ret.Value_JS = value
	return ret
}

// SpeechRecognitionEventFromJS is casting from something that holds a js.Value into SpeechRecognitionEvent.
func SpeechRecognitionEventFromWrapper(input core.Wrapper) *SpeechRecognitionEvent {
	return SpeechRecognitionEventFromJS(input.JSValue())
}

func NewSpeechRecognitionEvent(_type string, eventInitDict *SpeechRecognitionEventInit) (_result *SpeechRecognitionEvent) {
	_klass := js.Global().Get("SpeechRecognitionEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := eventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SpeechRecognitionEvent // javascript: SpeechRecognitionEvent _what_return_name
	)
	_converted = SpeechRecognitionEventFromJS(_returned)
	_result = _converted
	return
}

// ResultIndex returning attribute 'resultIndex' with
// type uint (idl: unsigned long).
func (_this *SpeechRecognitionEvent) ResultIndex() uint {
	var ret uint
	value := _this.Value_JS.Get("resultIndex")
	ret = (uint)((value).Int())
	return ret
}

// Results returning attribute 'results' with
// type SpeechRecognitionResultList (idl: SpeechRecognitionResultList).
func (_this *SpeechRecognitionEvent) Results() *SpeechRecognitionResultList {
	var ret *SpeechRecognitionResultList
	value := _this.Value_JS.Get("results")
	ret = SpeechRecognitionResultListFromJS(value)
	return ret
}

// Interpretation returning attribute 'interpretation' with
// type Any (idl: any).
func (_this *SpeechRecognitionEvent) Interpretation() js.Value {
	var ret js.Value
	value := _this.Value_JS.Get("interpretation")
	ret = value
	return ret
}

// Emma returning attribute 'emma' with
// type js.Value (idl: Document).
func (_this *SpeechRecognitionEvent) Emma() js.Value {
	var ret js.Value
	value := _this.Value_JS.Get("emma")
	ret = value
	return ret
}

// class: SpeechRecognitionResult
type SpeechRecognitionResult struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *SpeechRecognitionResult) JSValue() js.Value {
	return _this.Value_JS
}

// SpeechRecognitionResultFromJS is casting a js.Value into SpeechRecognitionResult.
func SpeechRecognitionResultFromJS(value js.Value) *SpeechRecognitionResult {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &SpeechRecognitionResult{}
	ret.Value_JS = value
	return ret
}

// SpeechRecognitionResultFromJS is casting from something that holds a js.Value into SpeechRecognitionResult.
func SpeechRecognitionResultFromWrapper(input core.Wrapper) *SpeechRecognitionResult {
	return SpeechRecognitionResultFromJS(input.JSValue())
}

// Length returning attribute 'length' with
// type uint (idl: unsigned long).
func (_this *SpeechRecognitionResult) Length() uint {
	var ret uint
	value := _this.Value_JS.Get("length")
	ret = (uint)((value).Int())
	return ret
}

// IsFinal returning attribute 'isFinal' with
// type bool (idl: boolean).
func (_this *SpeechRecognitionResult) IsFinal() bool {
	var ret bool
	value := _this.Value_JS.Get("isFinal")
	ret = (value).Bool()
	return ret
}

func (_this *SpeechRecognitionResult) Index(index uint) (_result *SpeechRecognitionAlternative) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := index
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("item", _args[0:_end]...)
	var (
		_converted *SpeechRecognitionAlternative // javascript: SpeechRecognitionAlternative _what_return_name
	)
	_converted = SpeechRecognitionAlternativeFromJS(_returned)
	_result = _converted
	return
}

func (_this *SpeechRecognitionResult) Item(index uint) (_result *SpeechRecognitionAlternative) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := index
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("item", _args[0:_end]...)
	var (
		_converted *SpeechRecognitionAlternative // javascript: SpeechRecognitionAlternative _what_return_name
	)
	_converted = SpeechRecognitionAlternativeFromJS(_returned)
	_result = _converted
	return
}

// class: SpeechRecognitionResultList
type SpeechRecognitionResultList struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *SpeechRecognitionResultList) JSValue() js.Value {
	return _this.Value_JS
}

// SpeechRecognitionResultListFromJS is casting a js.Value into SpeechRecognitionResultList.
func SpeechRecognitionResultListFromJS(value js.Value) *SpeechRecognitionResultList {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &SpeechRecognitionResultList{}
	ret.Value_JS = value
	return ret
}

// SpeechRecognitionResultListFromJS is casting from something that holds a js.Value into SpeechRecognitionResultList.
func SpeechRecognitionResultListFromWrapper(input core.Wrapper) *SpeechRecognitionResultList {
	return SpeechRecognitionResultListFromJS(input.JSValue())
}

// Length returning attribute 'length' with
// type uint (idl: unsigned long).
func (_this *SpeechRecognitionResultList) Length() uint {
	var ret uint
	value := _this.Value_JS.Get("length")
	ret = (uint)((value).Int())
	return ret
}

func (_this *SpeechRecognitionResultList) Index(index uint) (_result *SpeechRecognitionResult) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := index
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("item", _args[0:_end]...)
	var (
		_converted *SpeechRecognitionResult // javascript: SpeechRecognitionResult _what_return_name
	)
	_converted = SpeechRecognitionResultFromJS(_returned)
	_result = _converted
	return
}

func (_this *SpeechRecognitionResultList) Item(index uint) (_result *SpeechRecognitionResult) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := index
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("item", _args[0:_end]...)
	var (
		_converted *SpeechRecognitionResult // javascript: SpeechRecognitionResult _what_return_name
	)
	_converted = SpeechRecognitionResultFromJS(_returned)
	_result = _converted
	return
}

// class: SpeechSynthesis
type SpeechSynthesis struct {
	domcore.EventTarget
}

// SpeechSynthesisFromJS is casting a js.Value into SpeechSynthesis.
func SpeechSynthesisFromJS(value js.Value) *SpeechSynthesis {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &SpeechSynthesis{}
	ret.Value_JS = value
	return ret
}

// SpeechSynthesisFromJS is casting from something that holds a js.Value into SpeechSynthesis.
func SpeechSynthesisFromWrapper(input core.Wrapper) *SpeechSynthesis {
	return SpeechSynthesisFromJS(input.JSValue())
}

// Pending returning attribute 'pending' with
// type bool (idl: boolean).
func (_this *SpeechSynthesis) Pending() bool {
	var ret bool
	value := _this.Value_JS.Get("pending")
	ret = (value).Bool()
	return ret
}

// Speaking returning attribute 'speaking' with
// type bool (idl: boolean).
func (_this *SpeechSynthesis) Speaking() bool {
	var ret bool
	value := _this.Value_JS.Get("speaking")
	ret = (value).Bool()
	return ret
}

// Paused returning attribute 'paused' with
// type bool (idl: boolean).
func (_this *SpeechSynthesis) Paused() bool {
	var ret bool
	value := _this.Value_JS.Get("paused")
	ret = (value).Bool()
	return ret
}

// OnVoicesChanged returning attribute 'onvoiceschanged' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesis) OnVoicesChanged() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onvoiceschanged")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// event attribute: domcore.Event
func eventFuncSpeechSynthesis_domcore_Event(listener func(event *domcore.Event, target *SpeechSynthesis)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *domcore.Event
		value := args[0]
		incoming := value.Get("target")
		ret = domcore.EventFromJS(value)
		src := SpeechSynthesisFromJS(incoming)
		listener(ret, src)
		return js.Undefined()
	}
	return js.FuncOf(fn)
}

// AddVoicesChanged is adding doing AddEventListener for 'VoicesChanged' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechSynthesis) AddEventVoicesChanged(listener func(event *domcore.Event, currentTarget *SpeechSynthesis)) js.Func {
	cb := eventFuncSpeechSynthesis_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "voiceschanged", cb)
	return cb
}

// SetOnVoicesChanged is assigning a function to 'onvoiceschanged'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechSynthesis) SetOnVoicesChanged(listener func(event *domcore.Event, currentTarget *SpeechSynthesis)) js.Func {
	cb := eventFuncSpeechSynthesis_domcore_Event(listener)
	_this.Value_JS.Set("onvoiceschanged", cb)
	return cb
}

func (_this *SpeechSynthesis) Speak(utterance *SpeechSynthesisUtterance) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := utterance.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("speak", _args[0:_end]...)
	return
}

func (_this *SpeechSynthesis) Cancel() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("cancel", _args[0:_end]...)
	return
}

func (_this *SpeechSynthesis) Pause() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("pause", _args[0:_end]...)
	return
}

func (_this *SpeechSynthesis) Resume() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("resume", _args[0:_end]...)
	return
}

func (_this *SpeechSynthesis) GetVoices() (_result []*SpeechSynthesisVoice) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getVoices", _args[0:_end]...)
	var (
		_converted []*SpeechSynthesisVoice // javascript: sequence<SpeechSynthesisVoice> _what_return_name
	)
	__length0 := _returned.Length()
	__array0 := make([]*SpeechSynthesisVoice, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *SpeechSynthesisVoice
		__seq_in0 := _returned.Index(__idx0)
		__seq_out0 = SpeechSynthesisVoiceFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	_converted = __array0
	_result = _converted
	return
}

// class: SpeechSynthesisErrorEvent
type SpeechSynthesisErrorEvent struct {
	SpeechSynthesisEvent
}

// SpeechSynthesisErrorEventFromJS is casting a js.Value into SpeechSynthesisErrorEvent.
func SpeechSynthesisErrorEventFromJS(value js.Value) *SpeechSynthesisErrorEvent {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &SpeechSynthesisErrorEvent{}
	ret.Value_JS = value
	return ret
}

// SpeechSynthesisErrorEventFromJS is casting from something that holds a js.Value into SpeechSynthesisErrorEvent.
func SpeechSynthesisErrorEventFromWrapper(input core.Wrapper) *SpeechSynthesisErrorEvent {
	return SpeechSynthesisErrorEventFromJS(input.JSValue())
}

func NewSpeechSynthesisErrorEvent(_type string, eventInitDict *SpeechSynthesisErrorEventInit) (_result *SpeechSynthesisErrorEvent) {
	_klass := js.Global().Get("SpeechSynthesisErrorEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := eventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SpeechSynthesisErrorEvent // javascript: SpeechSynthesisErrorEvent _what_return_name
	)
	_converted = SpeechSynthesisErrorEventFromJS(_returned)
	_result = _converted
	return
}

// Error returning attribute 'error' with
// type SpeechSynthesisErrorCode (idl: SpeechSynthesisErrorCode).
func (_this *SpeechSynthesisErrorEvent) Error() SpeechSynthesisErrorCode {
	var ret SpeechSynthesisErrorCode
	value := _this.Value_JS.Get("error")
	ret = SpeechSynthesisErrorCodeFromJS(value)
	return ret
}

// class: SpeechSynthesisEvent
type SpeechSynthesisEvent struct {
	domcore.Event
}

// SpeechSynthesisEventFromJS is casting a js.Value into SpeechSynthesisEvent.
func SpeechSynthesisEventFromJS(value js.Value) *SpeechSynthesisEvent {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &SpeechSynthesisEvent{}
	ret.Value_JS = value
	return ret
}

// SpeechSynthesisEventFromJS is casting from something that holds a js.Value into SpeechSynthesisEvent.
func SpeechSynthesisEventFromWrapper(input core.Wrapper) *SpeechSynthesisEvent {
	return SpeechSynthesisEventFromJS(input.JSValue())
}

func NewSpeechSynthesisEvent(_type string, eventInitDict *SpeechSynthesisEventInit) (_result *SpeechSynthesisEvent) {
	_klass := js.Global().Get("SpeechSynthesisEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := eventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SpeechSynthesisEvent // javascript: SpeechSynthesisEvent _what_return_name
	)
	_converted = SpeechSynthesisEventFromJS(_returned)
	_result = _converted
	return
}

// Utterance returning attribute 'utterance' with
// type SpeechSynthesisUtterance (idl: SpeechSynthesisUtterance).
func (_this *SpeechSynthesisEvent) Utterance() *SpeechSynthesisUtterance {
	var ret *SpeechSynthesisUtterance
	value := _this.Value_JS.Get("utterance")
	ret = SpeechSynthesisUtteranceFromJS(value)
	return ret
}

// CharIndex returning attribute 'charIndex' with
// type uint (idl: unsigned long).
func (_this *SpeechSynthesisEvent) CharIndex() uint {
	var ret uint
	value := _this.Value_JS.Get("charIndex")
	ret = (uint)((value).Int())
	return ret
}

// ElapsedTime returning attribute 'elapsedTime' with
// type float32 (idl: float).
func (_this *SpeechSynthesisEvent) ElapsedTime() float32 {
	var ret float32
	value := _this.Value_JS.Get("elapsedTime")
	ret = (float32)((value).Float())
	return ret
}

// Name returning attribute 'name' with
// type string (idl: DOMString).
func (_this *SpeechSynthesisEvent) Name() string {
	var ret string
	value := _this.Value_JS.Get("name")
	ret = (value).String()
	return ret
}

// class: SpeechSynthesisUtterance
type SpeechSynthesisUtterance struct {
	domcore.EventTarget
}

// SpeechSynthesisUtteranceFromJS is casting a js.Value into SpeechSynthesisUtterance.
func SpeechSynthesisUtteranceFromJS(value js.Value) *SpeechSynthesisUtterance {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &SpeechSynthesisUtterance{}
	ret.Value_JS = value
	return ret
}

// SpeechSynthesisUtteranceFromJS is casting from something that holds a js.Value into SpeechSynthesisUtterance.
func SpeechSynthesisUtteranceFromWrapper(input core.Wrapper) *SpeechSynthesisUtterance {
	return SpeechSynthesisUtteranceFromJS(input.JSValue())
}

func NewSpeechSynthesisUtterance(text *string) (_result *SpeechSynthesisUtterance) {
	_klass := js.Global().Get("SpeechSynthesisUtterance")
	var (
		_args [1]interface{}
		_end  int
	)
	if text != nil {

		var _p0 interface{}
		if text != nil {
			_p0 = *(text)
		} else {
			_p0 = nil
		}
		_args[0] = _p0
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SpeechSynthesisUtterance // javascript: SpeechSynthesisUtterance _what_return_name
	)
	_converted = SpeechSynthesisUtteranceFromJS(_returned)
	_result = _converted
	return
}

// Text returning attribute 'text' with
// type string (idl: DOMString).
func (_this *SpeechSynthesisUtterance) Text() string {
	var ret string
	value := _this.Value_JS.Get("text")
	ret = (value).String()
	return ret
}

// SetText setting attribute 'text' with
// type string (idl: DOMString).
func (_this *SpeechSynthesisUtterance) SetText(value string) {
	input := value
	_this.Value_JS.Set("text", input)
}

// Lang returning attribute 'lang' with
// type string (idl: DOMString).
func (_this *SpeechSynthesisUtterance) Lang() string {
	var ret string
	value := _this.Value_JS.Get("lang")
	ret = (value).String()
	return ret
}

// SetLang setting attribute 'lang' with
// type string (idl: DOMString).
func (_this *SpeechSynthesisUtterance) SetLang(value string) {
	input := value
	_this.Value_JS.Set("lang", input)
}

// Voice returning attribute 'voice' with
// type SpeechSynthesisVoice (idl: SpeechSynthesisVoice).
func (_this *SpeechSynthesisUtterance) Voice() *SpeechSynthesisVoice {
	var ret *SpeechSynthesisVoice
	value := _this.Value_JS.Get("voice")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = SpeechSynthesisVoiceFromJS(value)
	}
	return ret
}

// SetVoice setting attribute 'voice' with
// type SpeechSynthesisVoice (idl: SpeechSynthesisVoice).
func (_this *SpeechSynthesisUtterance) SetVoice(value *SpeechSynthesisVoice) {
	input := value.JSValue()
	_this.Value_JS.Set("voice", input)
}

// Volume returning attribute 'volume' with
// type float32 (idl: float).
func (_this *SpeechSynthesisUtterance) Volume() float32 {
	var ret float32
	value := _this.Value_JS.Get("volume")
	ret = (float32)((value).Float())
	return ret
}

// SetVolume setting attribute 'volume' with
// type float32 (idl: float).
func (_this *SpeechSynthesisUtterance) SetVolume(value float32) {
	input := value
	_this.Value_JS.Set("volume", input)
}

// Rate returning attribute 'rate' with
// type float32 (idl: float).
func (_this *SpeechSynthesisUtterance) Rate() float32 {
	var ret float32
	value := _this.Value_JS.Get("rate")
	ret = (float32)((value).Float())
	return ret
}

// SetRate setting attribute 'rate' with
// type float32 (idl: float).
func (_this *SpeechSynthesisUtterance) SetRate(value float32) {
	input := value
	_this.Value_JS.Set("rate", input)
}

// Pitch returning attribute 'pitch' with
// type float32 (idl: float).
func (_this *SpeechSynthesisUtterance) Pitch() float32 {
	var ret float32
	value := _this.Value_JS.Get("pitch")
	ret = (float32)((value).Float())
	return ret
}

// SetPitch setting attribute 'pitch' with
// type float32 (idl: float).
func (_this *SpeechSynthesisUtterance) SetPitch(value float32) {
	input := value
	_this.Value_JS.Set("pitch", input)
}

// OnStart returning attribute 'onstart' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) OnStart() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onstart")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnEnd returning attribute 'onend' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) OnEnd() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onend")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnError returning attribute 'onerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) OnError() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onerror")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnPause returning attribute 'onpause' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) OnPause() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onpause")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnResume returning attribute 'onresume' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) OnResume() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onresume")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnMark returning attribute 'onmark' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) OnMark() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onmark")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnBoundary returning attribute 'onboundary' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SpeechSynthesisUtterance) OnBoundary() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onboundary")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// event attribute: SpeechSynthesisEvent
func eventFuncSpeechSynthesisUtterance_SpeechSynthesisEvent(listener func(event *SpeechSynthesisEvent, target *SpeechSynthesisUtterance)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *SpeechSynthesisEvent
		value := args[0]
		incoming := value.Get("target")
		ret = SpeechSynthesisEventFromJS(value)
		src := SpeechSynthesisUtteranceFromJS(incoming)
		listener(ret, src)
		return js.Undefined()
	}
	return js.FuncOf(fn)
}

// AddBoundary is adding doing AddEventListener for 'Boundary' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechSynthesisUtterance) AddEventBoundary(listener func(event *SpeechSynthesisEvent, currentTarget *SpeechSynthesisUtterance)) js.Func {
	cb := eventFuncSpeechSynthesisUtterance_SpeechSynthesisEvent(listener)
	_this.Value_JS.Call("addEventListener", "boundary", cb)
	return cb
}

// SetOnBoundary is assigning a function to 'onboundary'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechSynthesisUtterance) SetOnBoundary(listener func(event *SpeechSynthesisEvent, currentTarget *SpeechSynthesisUtterance)) js.Func {
	cb := eventFuncSpeechSynthesisUtterance_SpeechSynthesisEvent(listener)
	_this.Value_JS.Set("onboundary", cb)
	return cb
}

// AddEnd is adding doing AddEventListener for 'End' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechSynthesisUtterance) AddEventEnd(listener func(event *SpeechSynthesisEvent, currentTarget *SpeechSynthesisUtterance)) js.Func {
	cb := eventFuncSpeechSynthesisUtterance_SpeechSynthesisEvent(listener)
	_this.Value_JS.Call("addEventListener", "end", cb)
	return cb
}

// SetOnEnd is assigning a function to 'onend'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechSynthesisUtterance) SetOnEnd(listener func(event *SpeechSynthesisEvent, currentTarget *SpeechSynthesisUtterance)) js.Func {
	cb := eventFuncSpeechSynthesisUtterance_SpeechSynthesisEvent(listener)
	_this.Value_JS.Set("onend", cb)
	return cb
}

// event attribute: SpeechSynthesisErrorEvent
func eventFuncSpeechSynthesisUtterance_SpeechSynthesisErrorEvent(listener func(event *SpeechSynthesisErrorEvent, target *SpeechSynthesisUtterance)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *SpeechSynthesisErrorEvent
		value := args[0]
		incoming := value.Get("target")
		ret = SpeechSynthesisErrorEventFromJS(value)
		src := SpeechSynthesisUtteranceFromJS(incoming)
		listener(ret, src)
		return js.Undefined()
	}
	return js.FuncOf(fn)
}

// AddError is adding doing AddEventListener for 'Error' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechSynthesisUtterance) AddEventError(listener func(event *SpeechSynthesisErrorEvent, currentTarget *SpeechSynthesisUtterance)) js.Func {
	cb := eventFuncSpeechSynthesisUtterance_SpeechSynthesisErrorEvent(listener)
	_this.Value_JS.Call("addEventListener", "error", cb)
	return cb
}

// SetOnError is assigning a function to 'onerror'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechSynthesisUtterance) SetOnError(listener func(event *SpeechSynthesisErrorEvent, currentTarget *SpeechSynthesisUtterance)) js.Func {
	cb := eventFuncSpeechSynthesisUtterance_SpeechSynthesisErrorEvent(listener)
	_this.Value_JS.Set("onerror", cb)
	return cb
}

// AddMark is adding doing AddEventListener for 'Mark' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechSynthesisUtterance) AddEventMark(listener func(event *SpeechSynthesisEvent, currentTarget *SpeechSynthesisUtterance)) js.Func {
	cb := eventFuncSpeechSynthesisUtterance_SpeechSynthesisEvent(listener)
	_this.Value_JS.Call("addEventListener", "mark", cb)
	return cb
}

// SetOnMark is assigning a function to 'onmark'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechSynthesisUtterance) SetOnMark(listener func(event *SpeechSynthesisEvent, currentTarget *SpeechSynthesisUtterance)) js.Func {
	cb := eventFuncSpeechSynthesisUtterance_SpeechSynthesisEvent(listener)
	_this.Value_JS.Set("onmark", cb)
	return cb
}

// AddPause is adding doing AddEventListener for 'Pause' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechSynthesisUtterance) AddEventPause(listener func(event *SpeechSynthesisEvent, currentTarget *SpeechSynthesisUtterance)) js.Func {
	cb := eventFuncSpeechSynthesisUtterance_SpeechSynthesisEvent(listener)
	_this.Value_JS.Call("addEventListener", "pause", cb)
	return cb
}

// SetOnPause is assigning a function to 'onpause'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechSynthesisUtterance) SetOnPause(listener func(event *SpeechSynthesisEvent, currentTarget *SpeechSynthesisUtterance)) js.Func {
	cb := eventFuncSpeechSynthesisUtterance_SpeechSynthesisEvent(listener)
	_this.Value_JS.Set("onpause", cb)
	return cb
}

// AddResume is adding doing AddEventListener for 'Resume' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechSynthesisUtterance) AddEventResume(listener func(event *SpeechSynthesisEvent, currentTarget *SpeechSynthesisUtterance)) js.Func {
	cb := eventFuncSpeechSynthesisUtterance_SpeechSynthesisEvent(listener)
	_this.Value_JS.Call("addEventListener", "resume", cb)
	return cb
}

// SetOnResume is assigning a function to 'onresume'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechSynthesisUtterance) SetOnResume(listener func(event *SpeechSynthesisEvent, currentTarget *SpeechSynthesisUtterance)) js.Func {
	cb := eventFuncSpeechSynthesisUtterance_SpeechSynthesisEvent(listener)
	_this.Value_JS.Set("onresume", cb)
	return cb
}

// AddStart is adding doing AddEventListener for 'Start' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechSynthesisUtterance) AddEventStart(listener func(event *SpeechSynthesisEvent, currentTarget *SpeechSynthesisUtterance)) js.Func {
	cb := eventFuncSpeechSynthesisUtterance_SpeechSynthesisEvent(listener)
	_this.Value_JS.Call("addEventListener", "start", cb)
	return cb
}

// SetOnStart is assigning a function to 'onstart'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SpeechSynthesisUtterance) SetOnStart(listener func(event *SpeechSynthesisEvent, currentTarget *SpeechSynthesisUtterance)) js.Func {
	cb := eventFuncSpeechSynthesisUtterance_SpeechSynthesisEvent(listener)
	_this.Value_JS.Set("onstart", cb)
	return cb
}

// class: SpeechSynthesisVoice
type SpeechSynthesisVoice struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *SpeechSynthesisVoice) JSValue() js.Value {
	return _this.Value_JS
}

// SpeechSynthesisVoiceFromJS is casting a js.Value into SpeechSynthesisVoice.
func SpeechSynthesisVoiceFromJS(value js.Value) *SpeechSynthesisVoice {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &SpeechSynthesisVoice{}
	ret.Value_JS = value
	return ret
}

// SpeechSynthesisVoiceFromJS is casting from something that holds a js.Value into SpeechSynthesisVoice.
func SpeechSynthesisVoiceFromWrapper(input core.Wrapper) *SpeechSynthesisVoice {
	return SpeechSynthesisVoiceFromJS(input.JSValue())
}

// VoiceURI returning attribute 'voiceURI' with
// type string (idl: DOMString).
func (_this *SpeechSynthesisVoice) VoiceURI() string {
	var ret string
	value := _this.Value_JS.Get("voiceURI")
	ret = (value).String()
	return ret
}

// Name returning attribute 'name' with
// type string (idl: DOMString).
func (_this *SpeechSynthesisVoice) Name() string {
	var ret string
	value := _this.Value_JS.Get("name")
	ret = (value).String()
	return ret
}

// Lang returning attribute 'lang' with
// type string (idl: DOMString).
func (_this *SpeechSynthesisVoice) Lang() string {
	var ret string
	value := _this.Value_JS.Get("lang")
	ret = (value).String()
	return ret
}

// LocalService returning attribute 'localService' with
// type bool (idl: boolean).
func (_this *SpeechSynthesisVoice) LocalService() bool {
	var ret bool
	value := _this.Value_JS.Get("localService")
	ret = (value).Bool()
	return ret
}

// Default returning attribute 'default' with
// type bool (idl: boolean).
func (_this *SpeechSynthesisVoice) Default() bool {
	var ret bool
	value := _this.Value_JS.Get("default")
	ret = (value).Bool()
	return ret
}
