// Code generated by webidl-bind. DO NOT EDIT.

package audio

import "syscall/js"

import (
	"github.com/gowebapi/webapi/dom/domcore"
	"github.com/gowebapi/webapi/html/channel"
	"github.com/gowebapi/webapi/html/media"
	"github.com/gowebapi/webapi/javascript"
	"github.com/gowebapi/webapi/media/capture/local"
	"github.com/gowebapi/webapi/webidl"
	"github.com/gowebapi/webapi/worklets"
)

// using following types:
// channel.MessagePort
// domcore.DOMException
// domcore.Event
// domcore.EventHandler
// domcore.EventTarget
// javascript.ArrayBuffer
// javascript.Float32Array
// javascript.Object
// javascript.Promise
// javascript.Uint8Array
// local.MediaStream
// local.MediaStreamTrack
// media.HTMLMediaElement
// webidl.VoidFunction
// worklets.Worklet
// worklets.WorkletGlobalScope

// ReleasableApiResource is used to release underlaying
// allocated resources.
type ReleasableApiResource interface {
	Release()
}

type releasableApiResourceList []ReleasableApiResource

func (a releasableApiResourceList) Release() {
	for _, v := range a {
		v.Release()
	}
}

// workaround for compiler error
func unused(value interface{}) {
	// TODO remove this method
}

type Union struct {
	Value js.Value
}

func (u *Union) JSValue() js.Value {
	return u.Value
}

func UnionFromJS(value js.Value) *Union {
	return &Union{Value: value}
}

// enum: AudioContextLatencyCategory
type AudioContextLatencyCategory int

const (
	BalancedAudioContextLatencyCategory AudioContextLatencyCategory = iota
	InteractiveAudioContextLatencyCategory
	PlaybackAudioContextLatencyCategory
)

var audioContextLatencyCategoryToWasmTable = []string{
	"balanced", "interactive", "playback",
}

var audioContextLatencyCategoryFromWasmTable = map[string]AudioContextLatencyCategory{
	"balanced": BalancedAudioContextLatencyCategory, "interactive": InteractiveAudioContextLatencyCategory, "playback": PlaybackAudioContextLatencyCategory,
}

// JSValue is converting this enum into a java object
func (this *AudioContextLatencyCategory) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this AudioContextLatencyCategory) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(audioContextLatencyCategoryToWasmTable) {
		return audioContextLatencyCategoryToWasmTable[idx]
	}
	panic("unknown input value")
}

// AudioContextLatencyCategoryFromJS is converting a javascript value into
// a AudioContextLatencyCategory enum value.
func AudioContextLatencyCategoryFromJS(value js.Value) AudioContextLatencyCategory {
	key := value.String()
	conv, ok := audioContextLatencyCategoryFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: AudioContextState
type AudioContextState int

const (
	SuspendedAudioContextState AudioContextState = iota
	RunningAudioContextState
	ClosedAudioContextState
)

var audioContextStateToWasmTable = []string{
	"suspended", "running", "closed",
}

var audioContextStateFromWasmTable = map[string]AudioContextState{
	"suspended": SuspendedAudioContextState, "running": RunningAudioContextState, "closed": ClosedAudioContextState,
}

// JSValue is converting this enum into a java object
func (this *AudioContextState) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this AudioContextState) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(audioContextStateToWasmTable) {
		return audioContextStateToWasmTable[idx]
	}
	panic("unknown input value")
}

// AudioContextStateFromJS is converting a javascript value into
// a AudioContextState enum value.
func AudioContextStateFromJS(value js.Value) AudioContextState {
	key := value.String()
	conv, ok := audioContextStateFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: AutomationRate
type AutomationRate int

const (
	ARateAutomationRate AutomationRate = iota
	KRateAutomationRate
)

var automationRateToWasmTable = []string{
	"a-rate", "k-rate",
}

var automationRateFromWasmTable = map[string]AutomationRate{
	"a-rate": ARateAutomationRate, "k-rate": KRateAutomationRate,
}

// JSValue is converting this enum into a java object
func (this *AutomationRate) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this AutomationRate) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(automationRateToWasmTable) {
		return automationRateToWasmTable[idx]
	}
	panic("unknown input value")
}

// AutomationRateFromJS is converting a javascript value into
// a AutomationRate enum value.
func AutomationRateFromJS(value js.Value) AutomationRate {
	key := value.String()
	conv, ok := automationRateFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: BiquadFilterType
type BiquadFilterType int

const (
	LowpassBiquadFilterType BiquadFilterType = iota
	HighpassBiquadFilterType
	BandpassBiquadFilterType
	LowshelfBiquadFilterType
	HighshelfBiquadFilterType
	PeakingBiquadFilterType
	NotchBiquadFilterType
	AllpassBiquadFilterType
)

var biquadFilterTypeToWasmTable = []string{
	"lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "peaking", "notch", "allpass",
}

var biquadFilterTypeFromWasmTable = map[string]BiquadFilterType{
	"lowpass": LowpassBiquadFilterType, "highpass": HighpassBiquadFilterType, "bandpass": BandpassBiquadFilterType, "lowshelf": LowshelfBiquadFilterType, "highshelf": HighshelfBiquadFilterType, "peaking": PeakingBiquadFilterType, "notch": NotchBiquadFilterType, "allpass": AllpassBiquadFilterType,
}

// JSValue is converting this enum into a java object
func (this *BiquadFilterType) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this BiquadFilterType) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(biquadFilterTypeToWasmTable) {
		return biquadFilterTypeToWasmTable[idx]
	}
	panic("unknown input value")
}

// BiquadFilterTypeFromJS is converting a javascript value into
// a BiquadFilterType enum value.
func BiquadFilterTypeFromJS(value js.Value) BiquadFilterType {
	key := value.String()
	conv, ok := biquadFilterTypeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: ChannelCountMode
type ChannelCountMode int

const (
	MaxChannelCountMode ChannelCountMode = iota
	ClampedMaxChannelCountMode
	ExplicitChannelCountMode
)

var channelCountModeToWasmTable = []string{
	"max", "clamped-max", "explicit",
}

var channelCountModeFromWasmTable = map[string]ChannelCountMode{
	"max": MaxChannelCountMode, "clamped-max": ClampedMaxChannelCountMode, "explicit": ExplicitChannelCountMode,
}

// JSValue is converting this enum into a java object
func (this *ChannelCountMode) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this ChannelCountMode) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(channelCountModeToWasmTable) {
		return channelCountModeToWasmTable[idx]
	}
	panic("unknown input value")
}

// ChannelCountModeFromJS is converting a javascript value into
// a ChannelCountMode enum value.
func ChannelCountModeFromJS(value js.Value) ChannelCountMode {
	key := value.String()
	conv, ok := channelCountModeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: ChannelInterpretation
type ChannelInterpretation int

const (
	SpeakersChannelInterpretation ChannelInterpretation = iota
	DiscreteChannelInterpretation
)

var channelInterpretationToWasmTable = []string{
	"speakers", "discrete",
}

var channelInterpretationFromWasmTable = map[string]ChannelInterpretation{
	"speakers": SpeakersChannelInterpretation, "discrete": DiscreteChannelInterpretation,
}

// JSValue is converting this enum into a java object
func (this *ChannelInterpretation) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this ChannelInterpretation) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(channelInterpretationToWasmTable) {
		return channelInterpretationToWasmTable[idx]
	}
	panic("unknown input value")
}

// ChannelInterpretationFromJS is converting a javascript value into
// a ChannelInterpretation enum value.
func ChannelInterpretationFromJS(value js.Value) ChannelInterpretation {
	key := value.String()
	conv, ok := channelInterpretationFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: DistanceModelType
type DistanceModelType int

const (
	LinearDistanceModelType DistanceModelType = iota
	InverseDistanceModelType
	ExponentialDistanceModelType
)

var distanceModelTypeToWasmTable = []string{
	"linear", "inverse", "exponential",
}

var distanceModelTypeFromWasmTable = map[string]DistanceModelType{
	"linear": LinearDistanceModelType, "inverse": InverseDistanceModelType, "exponential": ExponentialDistanceModelType,
}

// JSValue is converting this enum into a java object
func (this *DistanceModelType) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this DistanceModelType) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(distanceModelTypeToWasmTable) {
		return distanceModelTypeToWasmTable[idx]
	}
	panic("unknown input value")
}

// DistanceModelTypeFromJS is converting a javascript value into
// a DistanceModelType enum value.
func DistanceModelTypeFromJS(value js.Value) DistanceModelType {
	key := value.String()
	conv, ok := distanceModelTypeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: OscillatorType
type OscillatorType int

const (
	SineOscillatorType OscillatorType = iota
	SquareOscillatorType
	SawtoothOscillatorType
	TriangleOscillatorType
	CustomOscillatorType
)

var oscillatorTypeToWasmTable = []string{
	"sine", "square", "sawtooth", "triangle", "custom",
}

var oscillatorTypeFromWasmTable = map[string]OscillatorType{
	"sine": SineOscillatorType, "square": SquareOscillatorType, "sawtooth": SawtoothOscillatorType, "triangle": TriangleOscillatorType, "custom": CustomOscillatorType,
}

// JSValue is converting this enum into a java object
func (this *OscillatorType) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this OscillatorType) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(oscillatorTypeToWasmTable) {
		return oscillatorTypeToWasmTable[idx]
	}
	panic("unknown input value")
}

// OscillatorTypeFromJS is converting a javascript value into
// a OscillatorType enum value.
func OscillatorTypeFromJS(value js.Value) OscillatorType {
	key := value.String()
	conv, ok := oscillatorTypeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: OverSampleType
type OverSampleType int

const (
	NoneOverSampleType OverSampleType = iota
	_2xOverSampleType
	_4xOverSampleType
)

var overSampleTypeToWasmTable = []string{
	"none", "2x", "4x",
}

var overSampleTypeFromWasmTable = map[string]OverSampleType{
	"none": NoneOverSampleType, "2x": _2xOverSampleType, "4x": _4xOverSampleType,
}

// JSValue is converting this enum into a java object
func (this *OverSampleType) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this OverSampleType) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(overSampleTypeToWasmTable) {
		return overSampleTypeToWasmTable[idx]
	}
	panic("unknown input value")
}

// OverSampleTypeFromJS is converting a javascript value into
// a OverSampleType enum value.
func OverSampleTypeFromJS(value js.Value) OverSampleType {
	key := value.String()
	conv, ok := overSampleTypeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: PanningModelType
type PanningModelType int

const (
	EqualpowerPanningModelType PanningModelType = iota
	HRTFPanningModelType
)

var panningModelTypeToWasmTable = []string{
	"equalpower", "HRTF",
}

var panningModelTypeFromWasmTable = map[string]PanningModelType{
	"equalpower": EqualpowerPanningModelType, "HRTF": HRTFPanningModelType,
}

// JSValue is converting this enum into a java object
func (this *PanningModelType) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this PanningModelType) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(panningModelTypeToWasmTable) {
		return panningModelTypeToWasmTable[idx]
	}
	panic("unknown input value")
}

// PanningModelTypeFromJS is converting a javascript value into
// a PanningModelType enum value.
func PanningModelTypeFromJS(value js.Value) PanningModelType {
	key := value.String()
	conv, ok := panningModelTypeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// callback: DecodeErrorCallback
type DecodeErrorCallbackFunc func(_error *domcore.DOMException)

// DecodeErrorCallback is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type DecodeErrorCallback js.Func

func DecodeErrorCallbackToJS(callback DecodeErrorCallbackFunc) *DecodeErrorCallback {
	if callback == nil {
		return nil
	}
	ret := DecodeErrorCallback(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *domcore.DOMException // javascript: DOMException _error
		)
		_p0 = domcore.DOMExceptionFromJS(args[0])
		callback(_p0)
		// returning no return value
		return nil
	}))
	return &ret
}

func DecodeErrorCallbackFromJS(_value js.Value) DecodeErrorCallbackFunc {
	return func(_error *domcore.DOMException) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := _error.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: DecodeSuccessCallback
type DecodeSuccessCallbackFunc func(decodedData *AudioBuffer)

// DecodeSuccessCallback is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type DecodeSuccessCallback js.Func

func DecodeSuccessCallbackToJS(callback DecodeSuccessCallbackFunc) *DecodeSuccessCallback {
	if callback == nil {
		return nil
	}
	ret := DecodeSuccessCallback(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *AudioBuffer // javascript: AudioBuffer decodedData
		)
		_p0 = AudioBufferFromJS(args[0])
		callback(_p0)
		// returning no return value
		return nil
	}))
	return &ret
}

func DecodeSuccessCallbackFromJS(_value js.Value) DecodeSuccessCallbackFunc {
	return func(decodedData *AudioBuffer) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := decodedData.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// dictionary: AnalyserOptions
type AnalyserOptions struct {
	ChannelCount          uint
	ChannelCountMode      ChannelCountMode
	ChannelInterpretation ChannelInterpretation
	FftSize               uint
	MaxDecibels           float64
	MinDecibels           float64
	SmoothingTimeConstant float64
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *AnalyserOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.ChannelCount
	out.Set("channelCount", value0)
	value1 := _this.ChannelCountMode.JSValue()
	out.Set("channelCountMode", value1)
	value2 := _this.ChannelInterpretation.JSValue()
	out.Set("channelInterpretation", value2)
	value3 := _this.FftSize
	out.Set("fftSize", value3)
	value4 := _this.MaxDecibels
	out.Set("maxDecibels", value4)
	value5 := _this.MinDecibels
	out.Set("minDecibels", value5)
	value6 := _this.SmoothingTimeConstant
	out.Set("smoothingTimeConstant", value6)
	return out
}

// AnalyserOptionsFromJS is allocating a new
// AnalyserOptions object and copy all values from
// input javascript object
func AnalyserOptionsFromJS(value js.Wrapper) *AnalyserOptions {
	input := value.JSValue()
	var out AnalyserOptions
	var (
		value0 uint                  // javascript: unsigned long {channelCount ChannelCount channelCount}
		value1 ChannelCountMode      // javascript: ChannelCountMode {channelCountMode ChannelCountMode channelCountMode}
		value2 ChannelInterpretation // javascript: ChannelInterpretation {channelInterpretation ChannelInterpretation channelInterpretation}
		value3 uint                  // javascript: unsigned long {fftSize FftSize fftSize}
		value4 float64               // javascript: double {maxDecibels MaxDecibels maxDecibels}
		value5 float64               // javascript: double {minDecibels MinDecibels minDecibels}
		value6 float64               // javascript: double {smoothingTimeConstant SmoothingTimeConstant smoothingTimeConstant}
	)
	value0 = (uint)((input.Get("channelCount")).Int())
	out.ChannelCount = value0
	value1 = ChannelCountModeFromJS(input.Get("channelCountMode"))
	out.ChannelCountMode = value1
	value2 = ChannelInterpretationFromJS(input.Get("channelInterpretation"))
	out.ChannelInterpretation = value2
	value3 = (uint)((input.Get("fftSize")).Int())
	out.FftSize = value3
	value4 = (input.Get("maxDecibels")).Float()
	out.MaxDecibels = value4
	value5 = (input.Get("minDecibels")).Float()
	out.MinDecibels = value5
	value6 = (input.Get("smoothingTimeConstant")).Float()
	out.SmoothingTimeConstant = value6
	return &out
}

// dictionary: AudioBufferOptions
type AudioBufferOptions struct {
	NumberOfChannels uint
	Length           uint
	SampleRate       float32
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *AudioBufferOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.NumberOfChannels
	out.Set("numberOfChannels", value0)
	value1 := _this.Length
	out.Set("length", value1)
	value2 := _this.SampleRate
	out.Set("sampleRate", value2)
	return out
}

// AudioBufferOptionsFromJS is allocating a new
// AudioBufferOptions object and copy all values from
// input javascript object
func AudioBufferOptionsFromJS(value js.Wrapper) *AudioBufferOptions {
	input := value.JSValue()
	var out AudioBufferOptions
	var (
		value0 uint    // javascript: unsigned long {numberOfChannels NumberOfChannels numberOfChannels}
		value1 uint    // javascript: unsigned long {length Length length}
		value2 float32 // javascript: float {sampleRate SampleRate sampleRate}
	)
	value0 = (uint)((input.Get("numberOfChannels")).Int())
	out.NumberOfChannels = value0
	value1 = (uint)((input.Get("length")).Int())
	out.Length = value1
	value2 = (float32)((input.Get("sampleRate")).Float())
	out.SampleRate = value2
	return &out
}

// dictionary: AudioBufferSourceOptions
type AudioBufferSourceOptions struct {
	Buffer       *AudioBuffer
	Detune       float32
	Loop         bool
	LoopEnd      float64
	LoopStart    float64
	PlaybackRate float32
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *AudioBufferSourceOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Buffer.JSValue()
	out.Set("buffer", value0)
	value1 := _this.Detune
	out.Set("detune", value1)
	value2 := _this.Loop
	out.Set("loop", value2)
	value3 := _this.LoopEnd
	out.Set("loopEnd", value3)
	value4 := _this.LoopStart
	out.Set("loopStart", value4)
	value5 := _this.PlaybackRate
	out.Set("playbackRate", value5)
	return out
}

// AudioBufferSourceOptionsFromJS is allocating a new
// AudioBufferSourceOptions object and copy all values from
// input javascript object
func AudioBufferSourceOptionsFromJS(value js.Wrapper) *AudioBufferSourceOptions {
	input := value.JSValue()
	var out AudioBufferSourceOptions
	var (
		value0 *AudioBuffer // javascript: AudioBuffer {buffer Buffer buffer}
		value1 float32      // javascript: float {detune Detune detune}
		value2 bool         // javascript: boolean {loop Loop loop}
		value3 float64      // javascript: double {loopEnd LoopEnd loopEnd}
		value4 float64      // javascript: double {loopStart LoopStart loopStart}
		value5 float32      // javascript: float {playbackRate PlaybackRate playbackRate}
	)
	if input.Get("buffer").Type() != js.TypeNull {
		value0 = AudioBufferFromJS(input.Get("buffer"))
	}
	out.Buffer = value0
	value1 = (float32)((input.Get("detune")).Float())
	out.Detune = value1
	value2 = (input.Get("loop")).Bool()
	out.Loop = value2
	value3 = (input.Get("loopEnd")).Float()
	out.LoopEnd = value3
	value4 = (input.Get("loopStart")).Float()
	out.LoopStart = value4
	value5 = (float32)((input.Get("playbackRate")).Float())
	out.PlaybackRate = value5
	return &out
}

// dictionary: AudioContextOptions
type AudioContextOptions struct {
	LatencyHint *Union
	SampleRate  float32
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *AudioContextOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.LatencyHint.JSValue()
	out.Set("latencyHint", value0)
	value1 := _this.SampleRate
	out.Set("sampleRate", value1)
	return out
}

// AudioContextOptionsFromJS is allocating a new
// AudioContextOptions object and copy all values from
// input javascript object
func AudioContextOptionsFromJS(value js.Wrapper) *AudioContextOptions {
	input := value.JSValue()
	var out AudioContextOptions
	var (
		value0 *Union  // javascript: Union {latencyHint LatencyHint latencyHint}
		value1 float32 // javascript: float {sampleRate SampleRate sampleRate}
	)
	value0 = UnionFromJS(input.Get("latencyHint"))
	out.LatencyHint = value0
	value1 = (float32)((input.Get("sampleRate")).Float())
	out.SampleRate = value1
	return &out
}

// dictionary: AudioNodeOptions
type AudioNodeOptions struct {
	ChannelCount          uint
	ChannelCountMode      ChannelCountMode
	ChannelInterpretation ChannelInterpretation
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *AudioNodeOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.ChannelCount
	out.Set("channelCount", value0)
	value1 := _this.ChannelCountMode.JSValue()
	out.Set("channelCountMode", value1)
	value2 := _this.ChannelInterpretation.JSValue()
	out.Set("channelInterpretation", value2)
	return out
}

// AudioNodeOptionsFromJS is allocating a new
// AudioNodeOptions object and copy all values from
// input javascript object
func AudioNodeOptionsFromJS(value js.Wrapper) *AudioNodeOptions {
	input := value.JSValue()
	var out AudioNodeOptions
	var (
		value0 uint                  // javascript: unsigned long {channelCount ChannelCount channelCount}
		value1 ChannelCountMode      // javascript: ChannelCountMode {channelCountMode ChannelCountMode channelCountMode}
		value2 ChannelInterpretation // javascript: ChannelInterpretation {channelInterpretation ChannelInterpretation channelInterpretation}
	)
	value0 = (uint)((input.Get("channelCount")).Int())
	out.ChannelCount = value0
	value1 = ChannelCountModeFromJS(input.Get("channelCountMode"))
	out.ChannelCountMode = value1
	value2 = ChannelInterpretationFromJS(input.Get("channelInterpretation"))
	out.ChannelInterpretation = value2
	return &out
}

// dictionary: AudioProcessingEventInit
type AudioProcessingEventInit struct {
	Bubbles      bool
	Cancelable   bool
	Composed     bool
	PlaybackTime float64
	InputBuffer  *AudioBuffer
	OutputBuffer *AudioBuffer
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *AudioProcessingEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.PlaybackTime
	out.Set("playbackTime", value3)
	value4 := _this.InputBuffer.JSValue()
	out.Set("inputBuffer", value4)
	value5 := _this.OutputBuffer.JSValue()
	out.Set("outputBuffer", value5)
	return out
}

// AudioProcessingEventInitFromJS is allocating a new
// AudioProcessingEventInit object and copy all values from
// input javascript object
func AudioProcessingEventInitFromJS(value js.Wrapper) *AudioProcessingEventInit {
	input := value.JSValue()
	var out AudioProcessingEventInit
	var (
		value0 bool         // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool         // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool         // javascript: boolean {composed Composed composed}
		value3 float64      // javascript: double {playbackTime PlaybackTime playbackTime}
		value4 *AudioBuffer // javascript: AudioBuffer {inputBuffer InputBuffer inputBuffer}
		value5 *AudioBuffer // javascript: AudioBuffer {outputBuffer OutputBuffer outputBuffer}
	)
	value0 = (input.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (input.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (input.Get("composed")).Bool()
	out.Composed = value2
	value3 = (input.Get("playbackTime")).Float()
	out.PlaybackTime = value3
	value4 = AudioBufferFromJS(input.Get("inputBuffer"))
	out.InputBuffer = value4
	value5 = AudioBufferFromJS(input.Get("outputBuffer"))
	out.OutputBuffer = value5
	return &out
}

// dictionary: AudioTimestamp
type AudioTimestamp struct {
	ContextTime     float64
	PerformanceTime float64
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *AudioTimestamp) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.ContextTime
	out.Set("contextTime", value0)
	value1 := _this.PerformanceTime
	out.Set("performanceTime", value1)
	return out
}

// AudioTimestampFromJS is allocating a new
// AudioTimestamp object and copy all values from
// input javascript object
func AudioTimestampFromJS(value js.Wrapper) *AudioTimestamp {
	input := value.JSValue()
	var out AudioTimestamp
	var (
		value0 float64 // javascript: double {contextTime ContextTime contextTime}
		value1 float64 // javascript: double {performanceTime PerformanceTime performanceTime}
	)
	value0 = (input.Get("contextTime")).Float()
	out.ContextTime = value0
	value1 = (input.Get("performanceTime")).Float()
	out.PerformanceTime = value1
	return &out
}

// dictionary: AudioWorkletNodeOptions
type AudioWorkletNodeOptions struct {
	ChannelCount          uint
	ChannelCountMode      ChannelCountMode
	ChannelInterpretation ChannelInterpretation
	NumberOfInputs        uint
	NumberOfOutputs       uint
	OutputChannelCount    []uint
	ProcessorOptions      *javascript.Object
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *AudioWorkletNodeOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.ChannelCount
	out.Set("channelCount", value0)
	value1 := _this.ChannelCountMode.JSValue()
	out.Set("channelCountMode", value1)
	value2 := _this.ChannelInterpretation.JSValue()
	out.Set("channelInterpretation", value2)
	value3 := _this.NumberOfInputs
	out.Set("numberOfInputs", value3)
	value4 := _this.NumberOfOutputs
	out.Set("numberOfOutputs", value4)
	value5 := js.Global().Get("Array").New(len(_this.OutputChannelCount))
	for __idx5, __seq_in5 := range _this.OutputChannelCount {
		__seq_out5 := __seq_in5
		value5.SetIndex(__idx5, __seq_out5)
	}
	out.Set("outputChannelCount", value5)
	value6 := _this.ProcessorOptions.JSValue()
	out.Set("processorOptions", value6)
	return out
}

// AudioWorkletNodeOptionsFromJS is allocating a new
// AudioWorkletNodeOptions object and copy all values from
// input javascript object
func AudioWorkletNodeOptionsFromJS(value js.Wrapper) *AudioWorkletNodeOptions {
	input := value.JSValue()
	var out AudioWorkletNodeOptions
	var (
		value0 uint                  // javascript: unsigned long {channelCount ChannelCount channelCount}
		value1 ChannelCountMode      // javascript: ChannelCountMode {channelCountMode ChannelCountMode channelCountMode}
		value2 ChannelInterpretation // javascript: ChannelInterpretation {channelInterpretation ChannelInterpretation channelInterpretation}
		value3 uint                  // javascript: unsigned long {numberOfInputs NumberOfInputs numberOfInputs}
		value4 uint                  // javascript: unsigned long {numberOfOutputs NumberOfOutputs numberOfOutputs}
		value5 []uint                // javascript: sequence<unsigned long> {outputChannelCount OutputChannelCount outputChannelCount}
		value6 *javascript.Object    // javascript: object {processorOptions ProcessorOptions processorOptions}
	)
	value0 = (uint)((input.Get("channelCount")).Int())
	out.ChannelCount = value0
	value1 = ChannelCountModeFromJS(input.Get("channelCountMode"))
	out.ChannelCountMode = value1
	value2 = ChannelInterpretationFromJS(input.Get("channelInterpretation"))
	out.ChannelInterpretation = value2
	value3 = (uint)((input.Get("numberOfInputs")).Int())
	out.NumberOfInputs = value3
	value4 = (uint)((input.Get("numberOfOutputs")).Int())
	out.NumberOfOutputs = value4
	__length5 := input.Get("outputChannelCount").Length()
	__array5 := make([]uint, __length5, __length5)
	for __idx5 := 0; __idx5 < __length5; __idx5++ {
		var __seq_out5 uint
		__seq_in5 := input.Get("outputChannelCount").Index(__idx5)
		__seq_out5 = (uint)((__seq_in5).Int())
		__array5[__idx5] = __seq_out5
	}
	value5 = __array5
	out.OutputChannelCount = value5
	if input.Get("processorOptions").Type() != js.TypeNull {
		value6 = javascript.ObjectFromJS(input.Get("processorOptions"))
	}
	out.ProcessorOptions = value6
	return &out
}

// dictionary: BiquadFilterOptions
type BiquadFilterOptions struct {
	ChannelCount          uint
	ChannelCountMode      ChannelCountMode
	ChannelInterpretation ChannelInterpretation
	Type                  BiquadFilterType
	Q                     float32
	Detune                float32
	Frequency             float32
	Gain                  float32
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *BiquadFilterOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.ChannelCount
	out.Set("channelCount", value0)
	value1 := _this.ChannelCountMode.JSValue()
	out.Set("channelCountMode", value1)
	value2 := _this.ChannelInterpretation.JSValue()
	out.Set("channelInterpretation", value2)
	value3 := _this.Type.JSValue()
	out.Set("type", value3)
	value4 := _this.Q
	out.Set("Q", value4)
	value5 := _this.Detune
	out.Set("detune", value5)
	value6 := _this.Frequency
	out.Set("frequency", value6)
	value7 := _this.Gain
	out.Set("gain", value7)
	return out
}

// BiquadFilterOptionsFromJS is allocating a new
// BiquadFilterOptions object and copy all values from
// input javascript object
func BiquadFilterOptionsFromJS(value js.Wrapper) *BiquadFilterOptions {
	input := value.JSValue()
	var out BiquadFilterOptions
	var (
		value0 uint                  // javascript: unsigned long {channelCount ChannelCount channelCount}
		value1 ChannelCountMode      // javascript: ChannelCountMode {channelCountMode ChannelCountMode channelCountMode}
		value2 ChannelInterpretation // javascript: ChannelInterpretation {channelInterpretation ChannelInterpretation channelInterpretation}
		value3 BiquadFilterType      // javascript: BiquadFilterType {type Type _type}
		value4 float32               // javascript: float {Q Q q}
		value5 float32               // javascript: float {detune Detune detune}
		value6 float32               // javascript: float {frequency Frequency frequency}
		value7 float32               // javascript: float {gain Gain gain}
	)
	value0 = (uint)((input.Get("channelCount")).Int())
	out.ChannelCount = value0
	value1 = ChannelCountModeFromJS(input.Get("channelCountMode"))
	out.ChannelCountMode = value1
	value2 = ChannelInterpretationFromJS(input.Get("channelInterpretation"))
	out.ChannelInterpretation = value2
	value3 = BiquadFilterTypeFromJS(input.Get("type"))
	out.Type = value3
	value4 = (float32)((input.Get("Q")).Float())
	out.Q = value4
	value5 = (float32)((input.Get("detune")).Float())
	out.Detune = value5
	value6 = (float32)((input.Get("frequency")).Float())
	out.Frequency = value6
	value7 = (float32)((input.Get("gain")).Float())
	out.Gain = value7
	return &out
}

// dictionary: ChannelMergerOptions
type ChannelMergerOptions struct {
	ChannelCount          uint
	ChannelCountMode      ChannelCountMode
	ChannelInterpretation ChannelInterpretation
	NumberOfInputs        uint
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *ChannelMergerOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.ChannelCount
	out.Set("channelCount", value0)
	value1 := _this.ChannelCountMode.JSValue()
	out.Set("channelCountMode", value1)
	value2 := _this.ChannelInterpretation.JSValue()
	out.Set("channelInterpretation", value2)
	value3 := _this.NumberOfInputs
	out.Set("numberOfInputs", value3)
	return out
}

// ChannelMergerOptionsFromJS is allocating a new
// ChannelMergerOptions object and copy all values from
// input javascript object
func ChannelMergerOptionsFromJS(value js.Wrapper) *ChannelMergerOptions {
	input := value.JSValue()
	var out ChannelMergerOptions
	var (
		value0 uint                  // javascript: unsigned long {channelCount ChannelCount channelCount}
		value1 ChannelCountMode      // javascript: ChannelCountMode {channelCountMode ChannelCountMode channelCountMode}
		value2 ChannelInterpretation // javascript: ChannelInterpretation {channelInterpretation ChannelInterpretation channelInterpretation}
		value3 uint                  // javascript: unsigned long {numberOfInputs NumberOfInputs numberOfInputs}
	)
	value0 = (uint)((input.Get("channelCount")).Int())
	out.ChannelCount = value0
	value1 = ChannelCountModeFromJS(input.Get("channelCountMode"))
	out.ChannelCountMode = value1
	value2 = ChannelInterpretationFromJS(input.Get("channelInterpretation"))
	out.ChannelInterpretation = value2
	value3 = (uint)((input.Get("numberOfInputs")).Int())
	out.NumberOfInputs = value3
	return &out
}

// dictionary: ChannelSplitterOptions
type ChannelSplitterOptions struct {
	ChannelCount          uint
	ChannelCountMode      ChannelCountMode
	ChannelInterpretation ChannelInterpretation
	NumberOfOutputs       uint
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *ChannelSplitterOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.ChannelCount
	out.Set("channelCount", value0)
	value1 := _this.ChannelCountMode.JSValue()
	out.Set("channelCountMode", value1)
	value2 := _this.ChannelInterpretation.JSValue()
	out.Set("channelInterpretation", value2)
	value3 := _this.NumberOfOutputs
	out.Set("numberOfOutputs", value3)
	return out
}

// ChannelSplitterOptionsFromJS is allocating a new
// ChannelSplitterOptions object and copy all values from
// input javascript object
func ChannelSplitterOptionsFromJS(value js.Wrapper) *ChannelSplitterOptions {
	input := value.JSValue()
	var out ChannelSplitterOptions
	var (
		value0 uint                  // javascript: unsigned long {channelCount ChannelCount channelCount}
		value1 ChannelCountMode      // javascript: ChannelCountMode {channelCountMode ChannelCountMode channelCountMode}
		value2 ChannelInterpretation // javascript: ChannelInterpretation {channelInterpretation ChannelInterpretation channelInterpretation}
		value3 uint                  // javascript: unsigned long {numberOfOutputs NumberOfOutputs numberOfOutputs}
	)
	value0 = (uint)((input.Get("channelCount")).Int())
	out.ChannelCount = value0
	value1 = ChannelCountModeFromJS(input.Get("channelCountMode"))
	out.ChannelCountMode = value1
	value2 = ChannelInterpretationFromJS(input.Get("channelInterpretation"))
	out.ChannelInterpretation = value2
	value3 = (uint)((input.Get("numberOfOutputs")).Int())
	out.NumberOfOutputs = value3
	return &out
}

// dictionary: ConstantSourceOptions
type ConstantSourceOptions struct {
	Offset float32
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *ConstantSourceOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Offset
	out.Set("offset", value0)
	return out
}

// ConstantSourceOptionsFromJS is allocating a new
// ConstantSourceOptions object and copy all values from
// input javascript object
func ConstantSourceOptionsFromJS(value js.Wrapper) *ConstantSourceOptions {
	input := value.JSValue()
	var out ConstantSourceOptions
	var (
		value0 float32 // javascript: float {offset Offset offset}
	)
	value0 = (float32)((input.Get("offset")).Float())
	out.Offset = value0
	return &out
}

// dictionary: ConvolverOptions
type ConvolverOptions struct {
	ChannelCount          uint
	ChannelCountMode      ChannelCountMode
	ChannelInterpretation ChannelInterpretation
	Buffer                *AudioBuffer
	DisableNormalization  bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *ConvolverOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.ChannelCount
	out.Set("channelCount", value0)
	value1 := _this.ChannelCountMode.JSValue()
	out.Set("channelCountMode", value1)
	value2 := _this.ChannelInterpretation.JSValue()
	out.Set("channelInterpretation", value2)
	value3 := _this.Buffer.JSValue()
	out.Set("buffer", value3)
	value4 := _this.DisableNormalization
	out.Set("disableNormalization", value4)
	return out
}

// ConvolverOptionsFromJS is allocating a new
// ConvolverOptions object and copy all values from
// input javascript object
func ConvolverOptionsFromJS(value js.Wrapper) *ConvolverOptions {
	input := value.JSValue()
	var out ConvolverOptions
	var (
		value0 uint                  // javascript: unsigned long {channelCount ChannelCount channelCount}
		value1 ChannelCountMode      // javascript: ChannelCountMode {channelCountMode ChannelCountMode channelCountMode}
		value2 ChannelInterpretation // javascript: ChannelInterpretation {channelInterpretation ChannelInterpretation channelInterpretation}
		value3 *AudioBuffer          // javascript: AudioBuffer {buffer Buffer buffer}
		value4 bool                  // javascript: boolean {disableNormalization DisableNormalization disableNormalization}
	)
	value0 = (uint)((input.Get("channelCount")).Int())
	out.ChannelCount = value0
	value1 = ChannelCountModeFromJS(input.Get("channelCountMode"))
	out.ChannelCountMode = value1
	value2 = ChannelInterpretationFromJS(input.Get("channelInterpretation"))
	out.ChannelInterpretation = value2
	if input.Get("buffer").Type() != js.TypeNull {
		value3 = AudioBufferFromJS(input.Get("buffer"))
	}
	out.Buffer = value3
	value4 = (input.Get("disableNormalization")).Bool()
	out.DisableNormalization = value4
	return &out
}

// dictionary: DelayOptions
type DelayOptions struct {
	ChannelCount          uint
	ChannelCountMode      ChannelCountMode
	ChannelInterpretation ChannelInterpretation
	MaxDelayTime          float64
	DelayTime             float64
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *DelayOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.ChannelCount
	out.Set("channelCount", value0)
	value1 := _this.ChannelCountMode.JSValue()
	out.Set("channelCountMode", value1)
	value2 := _this.ChannelInterpretation.JSValue()
	out.Set("channelInterpretation", value2)
	value3 := _this.MaxDelayTime
	out.Set("maxDelayTime", value3)
	value4 := _this.DelayTime
	out.Set("delayTime", value4)
	return out
}

// DelayOptionsFromJS is allocating a new
// DelayOptions object and copy all values from
// input javascript object
func DelayOptionsFromJS(value js.Wrapper) *DelayOptions {
	input := value.JSValue()
	var out DelayOptions
	var (
		value0 uint                  // javascript: unsigned long {channelCount ChannelCount channelCount}
		value1 ChannelCountMode      // javascript: ChannelCountMode {channelCountMode ChannelCountMode channelCountMode}
		value2 ChannelInterpretation // javascript: ChannelInterpretation {channelInterpretation ChannelInterpretation channelInterpretation}
		value3 float64               // javascript: double {maxDelayTime MaxDelayTime maxDelayTime}
		value4 float64               // javascript: double {delayTime DelayTime delayTime}
	)
	value0 = (uint)((input.Get("channelCount")).Int())
	out.ChannelCount = value0
	value1 = ChannelCountModeFromJS(input.Get("channelCountMode"))
	out.ChannelCountMode = value1
	value2 = ChannelInterpretationFromJS(input.Get("channelInterpretation"))
	out.ChannelInterpretation = value2
	value3 = (input.Get("maxDelayTime")).Float()
	out.MaxDelayTime = value3
	value4 = (input.Get("delayTime")).Float()
	out.DelayTime = value4
	return &out
}

// dictionary: DynamicsCompressorOptions
type DynamicsCompressorOptions struct {
	ChannelCount          uint
	ChannelCountMode      ChannelCountMode
	ChannelInterpretation ChannelInterpretation
	Attack                float32
	Knee                  float32
	Ratio                 float32
	Release               float32
	Threshold             float32
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *DynamicsCompressorOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.ChannelCount
	out.Set("channelCount", value0)
	value1 := _this.ChannelCountMode.JSValue()
	out.Set("channelCountMode", value1)
	value2 := _this.ChannelInterpretation.JSValue()
	out.Set("channelInterpretation", value2)
	value3 := _this.Attack
	out.Set("attack", value3)
	value4 := _this.Knee
	out.Set("knee", value4)
	value5 := _this.Ratio
	out.Set("ratio", value5)
	value6 := _this.Release
	out.Set("release", value6)
	value7 := _this.Threshold
	out.Set("threshold", value7)
	return out
}

// DynamicsCompressorOptionsFromJS is allocating a new
// DynamicsCompressorOptions object and copy all values from
// input javascript object
func DynamicsCompressorOptionsFromJS(value js.Wrapper) *DynamicsCompressorOptions {
	input := value.JSValue()
	var out DynamicsCompressorOptions
	var (
		value0 uint                  // javascript: unsigned long {channelCount ChannelCount channelCount}
		value1 ChannelCountMode      // javascript: ChannelCountMode {channelCountMode ChannelCountMode channelCountMode}
		value2 ChannelInterpretation // javascript: ChannelInterpretation {channelInterpretation ChannelInterpretation channelInterpretation}
		value3 float32               // javascript: float {attack Attack attack}
		value4 float32               // javascript: float {knee Knee knee}
		value5 float32               // javascript: float {ratio Ratio ratio}
		value6 float32               // javascript: float {release Release release}
		value7 float32               // javascript: float {threshold Threshold threshold}
	)
	value0 = (uint)((input.Get("channelCount")).Int())
	out.ChannelCount = value0
	value1 = ChannelCountModeFromJS(input.Get("channelCountMode"))
	out.ChannelCountMode = value1
	value2 = ChannelInterpretationFromJS(input.Get("channelInterpretation"))
	out.ChannelInterpretation = value2
	value3 = (float32)((input.Get("attack")).Float())
	out.Attack = value3
	value4 = (float32)((input.Get("knee")).Float())
	out.Knee = value4
	value5 = (float32)((input.Get("ratio")).Float())
	out.Ratio = value5
	value6 = (float32)((input.Get("release")).Float())
	out.Release = value6
	value7 = (float32)((input.Get("threshold")).Float())
	out.Threshold = value7
	return &out
}

// dictionary: GainOptions
type GainOptions struct {
	ChannelCount          uint
	ChannelCountMode      ChannelCountMode
	ChannelInterpretation ChannelInterpretation
	Gain                  float32
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *GainOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.ChannelCount
	out.Set("channelCount", value0)
	value1 := _this.ChannelCountMode.JSValue()
	out.Set("channelCountMode", value1)
	value2 := _this.ChannelInterpretation.JSValue()
	out.Set("channelInterpretation", value2)
	value3 := _this.Gain
	out.Set("gain", value3)
	return out
}

// GainOptionsFromJS is allocating a new
// GainOptions object and copy all values from
// input javascript object
func GainOptionsFromJS(value js.Wrapper) *GainOptions {
	input := value.JSValue()
	var out GainOptions
	var (
		value0 uint                  // javascript: unsigned long {channelCount ChannelCount channelCount}
		value1 ChannelCountMode      // javascript: ChannelCountMode {channelCountMode ChannelCountMode channelCountMode}
		value2 ChannelInterpretation // javascript: ChannelInterpretation {channelInterpretation ChannelInterpretation channelInterpretation}
		value3 float32               // javascript: float {gain Gain gain}
	)
	value0 = (uint)((input.Get("channelCount")).Int())
	out.ChannelCount = value0
	value1 = ChannelCountModeFromJS(input.Get("channelCountMode"))
	out.ChannelCountMode = value1
	value2 = ChannelInterpretationFromJS(input.Get("channelInterpretation"))
	out.ChannelInterpretation = value2
	value3 = (float32)((input.Get("gain")).Float())
	out.Gain = value3
	return &out
}

// dictionary: IIRFilterOptions
type IIRFilterOptions struct {
	ChannelCount          uint
	ChannelCountMode      ChannelCountMode
	ChannelInterpretation ChannelInterpretation
	Feedforward           js.Value
	Feedback              js.Value
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *IIRFilterOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.ChannelCount
	out.Set("channelCount", value0)
	value1 := _this.ChannelCountMode.JSValue()
	out.Set("channelCountMode", value1)
	value2 := _this.ChannelInterpretation.JSValue()
	out.Set("channelInterpretation", value2)
	value3 := _this.Feedforward
	out.Set("feedforward", value3)
	value4 := _this.Feedback
	out.Set("feedback", value4)
	return out
}

// IIRFilterOptionsFromJS is allocating a new
// IIRFilterOptions object and copy all values from
// input javascript object
func IIRFilterOptionsFromJS(value js.Wrapper) *IIRFilterOptions {
	input := value.JSValue()
	var out IIRFilterOptions
	var (
		value0 uint                  // javascript: unsigned long {channelCount ChannelCount channelCount}
		value1 ChannelCountMode      // javascript: ChannelCountMode {channelCountMode ChannelCountMode channelCountMode}
		value2 ChannelInterpretation // javascript: ChannelInterpretation {channelInterpretation ChannelInterpretation channelInterpretation}
		value3 js.Value              // javascript: typed-array {feedforward Feedforward feedforward}
		value4 js.Value              // javascript: typed-array {feedback Feedback feedback}
	)
	value0 = (uint)((input.Get("channelCount")).Int())
	out.ChannelCount = value0
	value1 = ChannelCountModeFromJS(input.Get("channelCountMode"))
	out.ChannelCountMode = value1
	value2 = ChannelInterpretationFromJS(input.Get("channelInterpretation"))
	out.ChannelInterpretation = value2
	value3 = input.Get("feedforward")
	out.Feedforward = value3
	value4 = input.Get("feedback")
	out.Feedback = value4
	return &out
}

// dictionary: MediaElementAudioSourceOptions
type MediaElementAudioSourceOptions struct {
	MediaElement *media.HTMLMediaElement
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *MediaElementAudioSourceOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.MediaElement.JSValue()
	out.Set("mediaElement", value0)
	return out
}

// MediaElementAudioSourceOptionsFromJS is allocating a new
// MediaElementAudioSourceOptions object and copy all values from
// input javascript object
func MediaElementAudioSourceOptionsFromJS(value js.Wrapper) *MediaElementAudioSourceOptions {
	input := value.JSValue()
	var out MediaElementAudioSourceOptions
	var (
		value0 *media.HTMLMediaElement // javascript: HTMLMediaElement {mediaElement MediaElement mediaElement}
	)
	value0 = media.HTMLMediaElementFromJS(input.Get("mediaElement"))
	out.MediaElement = value0
	return &out
}

// dictionary: MediaStreamAudioSourceOptions
type MediaStreamAudioSourceOptions struct {
	MediaStream *local.MediaStream
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *MediaStreamAudioSourceOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.MediaStream.JSValue()
	out.Set("mediaStream", value0)
	return out
}

// MediaStreamAudioSourceOptionsFromJS is allocating a new
// MediaStreamAudioSourceOptions object and copy all values from
// input javascript object
func MediaStreamAudioSourceOptionsFromJS(value js.Wrapper) *MediaStreamAudioSourceOptions {
	input := value.JSValue()
	var out MediaStreamAudioSourceOptions
	var (
		value0 *local.MediaStream // javascript: MediaStream {mediaStream MediaStream mediaStream}
	)
	value0 = local.MediaStreamFromJS(input.Get("mediaStream"))
	out.MediaStream = value0
	return &out
}

// dictionary: MediaStreamTrackAudioSourceOptions
type MediaStreamTrackAudioSourceOptions struct {
	MediaStreamTrack *local.MediaStreamTrack
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *MediaStreamTrackAudioSourceOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.MediaStreamTrack.JSValue()
	out.Set("mediaStreamTrack", value0)
	return out
}

// MediaStreamTrackAudioSourceOptionsFromJS is allocating a new
// MediaStreamTrackAudioSourceOptions object and copy all values from
// input javascript object
func MediaStreamTrackAudioSourceOptionsFromJS(value js.Wrapper) *MediaStreamTrackAudioSourceOptions {
	input := value.JSValue()
	var out MediaStreamTrackAudioSourceOptions
	var (
		value0 *local.MediaStreamTrack // javascript: MediaStreamTrack {mediaStreamTrack MediaStreamTrack mediaStreamTrack}
	)
	value0 = local.MediaStreamTrackFromJS(input.Get("mediaStreamTrack"))
	out.MediaStreamTrack = value0
	return &out
}

// dictionary: OfflineAudioCompletionEventInit
type OfflineAudioCompletionEventInit struct {
	Bubbles        bool
	Cancelable     bool
	Composed       bool
	RenderedBuffer *AudioBuffer
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *OfflineAudioCompletionEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.RenderedBuffer.JSValue()
	out.Set("renderedBuffer", value3)
	return out
}

// OfflineAudioCompletionEventInitFromJS is allocating a new
// OfflineAudioCompletionEventInit object and copy all values from
// input javascript object
func OfflineAudioCompletionEventInitFromJS(value js.Wrapper) *OfflineAudioCompletionEventInit {
	input := value.JSValue()
	var out OfflineAudioCompletionEventInit
	var (
		value0 bool         // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool         // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool         // javascript: boolean {composed Composed composed}
		value3 *AudioBuffer // javascript: AudioBuffer {renderedBuffer RenderedBuffer renderedBuffer}
	)
	value0 = (input.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (input.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (input.Get("composed")).Bool()
	out.Composed = value2
	value3 = AudioBufferFromJS(input.Get("renderedBuffer"))
	out.RenderedBuffer = value3
	return &out
}

// dictionary: OscillatorOptions
type OscillatorOptions struct {
	ChannelCount          uint
	ChannelCountMode      ChannelCountMode
	ChannelInterpretation ChannelInterpretation
	Type                  OscillatorType
	Frequency             float32
	Detune                float32
	PeriodicWave          *PeriodicWave
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *OscillatorOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.ChannelCount
	out.Set("channelCount", value0)
	value1 := _this.ChannelCountMode.JSValue()
	out.Set("channelCountMode", value1)
	value2 := _this.ChannelInterpretation.JSValue()
	out.Set("channelInterpretation", value2)
	value3 := _this.Type.JSValue()
	out.Set("type", value3)
	value4 := _this.Frequency
	out.Set("frequency", value4)
	value5 := _this.Detune
	out.Set("detune", value5)
	value6 := _this.PeriodicWave.JSValue()
	out.Set("periodicWave", value6)
	return out
}

// OscillatorOptionsFromJS is allocating a new
// OscillatorOptions object and copy all values from
// input javascript object
func OscillatorOptionsFromJS(value js.Wrapper) *OscillatorOptions {
	input := value.JSValue()
	var out OscillatorOptions
	var (
		value0 uint                  // javascript: unsigned long {channelCount ChannelCount channelCount}
		value1 ChannelCountMode      // javascript: ChannelCountMode {channelCountMode ChannelCountMode channelCountMode}
		value2 ChannelInterpretation // javascript: ChannelInterpretation {channelInterpretation ChannelInterpretation channelInterpretation}
		value3 OscillatorType        // javascript: OscillatorType {type Type _type}
		value4 float32               // javascript: float {frequency Frequency frequency}
		value5 float32               // javascript: float {detune Detune detune}
		value6 *PeriodicWave         // javascript: PeriodicWave {periodicWave PeriodicWave periodicWave}
	)
	value0 = (uint)((input.Get("channelCount")).Int())
	out.ChannelCount = value0
	value1 = ChannelCountModeFromJS(input.Get("channelCountMode"))
	out.ChannelCountMode = value1
	value2 = ChannelInterpretationFromJS(input.Get("channelInterpretation"))
	out.ChannelInterpretation = value2
	value3 = OscillatorTypeFromJS(input.Get("type"))
	out.Type = value3
	value4 = (float32)((input.Get("frequency")).Float())
	out.Frequency = value4
	value5 = (float32)((input.Get("detune")).Float())
	out.Detune = value5
	value6 = PeriodicWaveFromJS(input.Get("periodicWave"))
	out.PeriodicWave = value6
	return &out
}

// dictionary: PannerOptions
type PannerOptions struct {
	ChannelCount          uint
	ChannelCountMode      ChannelCountMode
	ChannelInterpretation ChannelInterpretation
	PanningModel          PanningModelType
	DistanceModel         DistanceModelType
	PositionX             float32
	PositionY             float32
	PositionZ             float32
	OrientationX          float32
	OrientationY          float32
	OrientationZ          float32
	RefDistance           float64
	MaxDistance           float64
	RolloffFactor         float64
	ConeInnerAngle        float64
	ConeOuterAngle        float64
	ConeOuterGain         float64
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *PannerOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.ChannelCount
	out.Set("channelCount", value0)
	value1 := _this.ChannelCountMode.JSValue()
	out.Set("channelCountMode", value1)
	value2 := _this.ChannelInterpretation.JSValue()
	out.Set("channelInterpretation", value2)
	value3 := _this.PanningModel.JSValue()
	out.Set("panningModel", value3)
	value4 := _this.DistanceModel.JSValue()
	out.Set("distanceModel", value4)
	value5 := _this.PositionX
	out.Set("positionX", value5)
	value6 := _this.PositionY
	out.Set("positionY", value6)
	value7 := _this.PositionZ
	out.Set("positionZ", value7)
	value8 := _this.OrientationX
	out.Set("orientationX", value8)
	value9 := _this.OrientationY
	out.Set("orientationY", value9)
	value10 := _this.OrientationZ
	out.Set("orientationZ", value10)
	value11 := _this.RefDistance
	out.Set("refDistance", value11)
	value12 := _this.MaxDistance
	out.Set("maxDistance", value12)
	value13 := _this.RolloffFactor
	out.Set("rolloffFactor", value13)
	value14 := _this.ConeInnerAngle
	out.Set("coneInnerAngle", value14)
	value15 := _this.ConeOuterAngle
	out.Set("coneOuterAngle", value15)
	value16 := _this.ConeOuterGain
	out.Set("coneOuterGain", value16)
	return out
}

// PannerOptionsFromJS is allocating a new
// PannerOptions object and copy all values from
// input javascript object
func PannerOptionsFromJS(value js.Wrapper) *PannerOptions {
	input := value.JSValue()
	var out PannerOptions
	var (
		value0  uint                  // javascript: unsigned long {channelCount ChannelCount channelCount}
		value1  ChannelCountMode      // javascript: ChannelCountMode {channelCountMode ChannelCountMode channelCountMode}
		value2  ChannelInterpretation // javascript: ChannelInterpretation {channelInterpretation ChannelInterpretation channelInterpretation}
		value3  PanningModelType      // javascript: PanningModelType {panningModel PanningModel panningModel}
		value4  DistanceModelType     // javascript: DistanceModelType {distanceModel DistanceModel distanceModel}
		value5  float32               // javascript: float {positionX PositionX positionX}
		value6  float32               // javascript: float {positionY PositionY positionY}
		value7  float32               // javascript: float {positionZ PositionZ positionZ}
		value8  float32               // javascript: float {orientationX OrientationX orientationX}
		value9  float32               // javascript: float {orientationY OrientationY orientationY}
		value10 float32               // javascript: float {orientationZ OrientationZ orientationZ}
		value11 float64               // javascript: double {refDistance RefDistance refDistance}
		value12 float64               // javascript: double {maxDistance MaxDistance maxDistance}
		value13 float64               // javascript: double {rolloffFactor RolloffFactor rolloffFactor}
		value14 float64               // javascript: double {coneInnerAngle ConeInnerAngle coneInnerAngle}
		value15 float64               // javascript: double {coneOuterAngle ConeOuterAngle coneOuterAngle}
		value16 float64               // javascript: double {coneOuterGain ConeOuterGain coneOuterGain}
	)
	value0 = (uint)((input.Get("channelCount")).Int())
	out.ChannelCount = value0
	value1 = ChannelCountModeFromJS(input.Get("channelCountMode"))
	out.ChannelCountMode = value1
	value2 = ChannelInterpretationFromJS(input.Get("channelInterpretation"))
	out.ChannelInterpretation = value2
	value3 = PanningModelTypeFromJS(input.Get("panningModel"))
	out.PanningModel = value3
	value4 = DistanceModelTypeFromJS(input.Get("distanceModel"))
	out.DistanceModel = value4
	value5 = (float32)((input.Get("positionX")).Float())
	out.PositionX = value5
	value6 = (float32)((input.Get("positionY")).Float())
	out.PositionY = value6
	value7 = (float32)((input.Get("positionZ")).Float())
	out.PositionZ = value7
	value8 = (float32)((input.Get("orientationX")).Float())
	out.OrientationX = value8
	value9 = (float32)((input.Get("orientationY")).Float())
	out.OrientationY = value9
	value10 = (float32)((input.Get("orientationZ")).Float())
	out.OrientationZ = value10
	value11 = (input.Get("refDistance")).Float()
	out.RefDistance = value11
	value12 = (input.Get("maxDistance")).Float()
	out.MaxDistance = value12
	value13 = (input.Get("rolloffFactor")).Float()
	out.RolloffFactor = value13
	value14 = (input.Get("coneInnerAngle")).Float()
	out.ConeInnerAngle = value14
	value15 = (input.Get("coneOuterAngle")).Float()
	out.ConeOuterAngle = value15
	value16 = (input.Get("coneOuterGain")).Float()
	out.ConeOuterGain = value16
	return &out
}

// dictionary: PeriodicWaveConstraints
type PeriodicWaveConstraints struct {
	DisableNormalization bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *PeriodicWaveConstraints) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.DisableNormalization
	out.Set("disableNormalization", value0)
	return out
}

// PeriodicWaveConstraintsFromJS is allocating a new
// PeriodicWaveConstraints object and copy all values from
// input javascript object
func PeriodicWaveConstraintsFromJS(value js.Wrapper) *PeriodicWaveConstraints {
	input := value.JSValue()
	var out PeriodicWaveConstraints
	var (
		value0 bool // javascript: boolean {disableNormalization DisableNormalization disableNormalization}
	)
	value0 = (input.Get("disableNormalization")).Bool()
	out.DisableNormalization = value0
	return &out
}

// dictionary: PeriodicWaveOptions
type PeriodicWaveOptions struct {
	DisableNormalization bool
	Real                 js.Value
	Imag                 js.Value
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *PeriodicWaveOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.DisableNormalization
	out.Set("disableNormalization", value0)
	value1 := _this.Real
	out.Set("real", value1)
	value2 := _this.Imag
	out.Set("imag", value2)
	return out
}

// PeriodicWaveOptionsFromJS is allocating a new
// PeriodicWaveOptions object and copy all values from
// input javascript object
func PeriodicWaveOptionsFromJS(value js.Wrapper) *PeriodicWaveOptions {
	input := value.JSValue()
	var out PeriodicWaveOptions
	var (
		value0 bool     // javascript: boolean {disableNormalization DisableNormalization disableNormalization}
		value1 js.Value // javascript: typed-array {real Real real}
		value2 js.Value // javascript: typed-array {imag Imag imag}
	)
	value0 = (input.Get("disableNormalization")).Bool()
	out.DisableNormalization = value0
	value1 = input.Get("real")
	out.Real = value1
	value2 = input.Get("imag")
	out.Imag = value2
	return &out
}

// dictionary: StereoPannerOptions
type StereoPannerOptions struct {
	ChannelCount          uint
	ChannelCountMode      ChannelCountMode
	ChannelInterpretation ChannelInterpretation
	Pan                   float32
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *StereoPannerOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.ChannelCount
	out.Set("channelCount", value0)
	value1 := _this.ChannelCountMode.JSValue()
	out.Set("channelCountMode", value1)
	value2 := _this.ChannelInterpretation.JSValue()
	out.Set("channelInterpretation", value2)
	value3 := _this.Pan
	out.Set("pan", value3)
	return out
}

// StereoPannerOptionsFromJS is allocating a new
// StereoPannerOptions object and copy all values from
// input javascript object
func StereoPannerOptionsFromJS(value js.Wrapper) *StereoPannerOptions {
	input := value.JSValue()
	var out StereoPannerOptions
	var (
		value0 uint                  // javascript: unsigned long {channelCount ChannelCount channelCount}
		value1 ChannelCountMode      // javascript: ChannelCountMode {channelCountMode ChannelCountMode channelCountMode}
		value2 ChannelInterpretation // javascript: ChannelInterpretation {channelInterpretation ChannelInterpretation channelInterpretation}
		value3 float32               // javascript: float {pan Pan pan}
	)
	value0 = (uint)((input.Get("channelCount")).Int())
	out.ChannelCount = value0
	value1 = ChannelCountModeFromJS(input.Get("channelCountMode"))
	out.ChannelCountMode = value1
	value2 = ChannelInterpretationFromJS(input.Get("channelInterpretation"))
	out.ChannelInterpretation = value2
	value3 = (float32)((input.Get("pan")).Float())
	out.Pan = value3
	return &out
}

// dictionary: WaveShaperOptions
type WaveShaperOptions struct {
	ChannelCount          uint
	ChannelCountMode      ChannelCountMode
	ChannelInterpretation ChannelInterpretation
	Curve                 js.Value
	Oversample            OverSampleType
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *WaveShaperOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.ChannelCount
	out.Set("channelCount", value0)
	value1 := _this.ChannelCountMode.JSValue()
	out.Set("channelCountMode", value1)
	value2 := _this.ChannelInterpretation.JSValue()
	out.Set("channelInterpretation", value2)
	value3 := _this.Curve
	out.Set("curve", value3)
	value4 := _this.Oversample.JSValue()
	out.Set("oversample", value4)
	return out
}

// WaveShaperOptionsFromJS is allocating a new
// WaveShaperOptions object and copy all values from
// input javascript object
func WaveShaperOptionsFromJS(value js.Wrapper) *WaveShaperOptions {
	input := value.JSValue()
	var out WaveShaperOptions
	var (
		value0 uint                  // javascript: unsigned long {channelCount ChannelCount channelCount}
		value1 ChannelCountMode      // javascript: ChannelCountMode {channelCountMode ChannelCountMode channelCountMode}
		value2 ChannelInterpretation // javascript: ChannelInterpretation {channelInterpretation ChannelInterpretation channelInterpretation}
		value3 js.Value              // javascript: typed-array {curve Curve curve}
		value4 OverSampleType        // javascript: OverSampleType {oversample Oversample oversample}
	)
	value0 = (uint)((input.Get("channelCount")).Int())
	out.ChannelCount = value0
	value1 = ChannelCountModeFromJS(input.Get("channelCountMode"))
	out.ChannelCountMode = value1
	value2 = ChannelInterpretationFromJS(input.Get("channelInterpretation"))
	out.ChannelInterpretation = value2
	value3 = input.Get("curve")
	out.Curve = value3
	value4 = OverSampleTypeFromJS(input.Get("oversample"))
	out.Oversample = value4
	return &out
}

// interface: AnalyserNode
type AnalyserNode struct {
	AudioNode
}

// AnalyserNodeFromJS is casting a js.Wrapper into AnalyserNode.
func AnalyserNodeFromJS(value js.Wrapper) *AnalyserNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &AnalyserNode{}
	ret.Value_JS = input
	return ret
}

func NewAnalyserNode(context *BaseAudioContext, options *AnalyserOptions) (_result *AnalyserNode) {
	_klass := js.Global().Get("AnalyserNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *AnalyserNode // javascript: AnalyserNode _what_return_name
	)
	_converted = AnalyserNodeFromJS(_returned)
	_result = _converted
	return
}

// FftSize returning attribute 'fftSize' with
// type uint (idl: unsigned long).
func (_this *AnalyserNode) FftSize() uint {
	var ret uint
	value := _this.Value_JS.Get("fftSize")
	ret = (uint)((value).Int())
	return ret
}

// SetFftSize setting attribute 'fftSize' with
// type uint (idl: unsigned long).
func (_this *AnalyserNode) SetFftSize(value uint) {
	input := value
	_this.Value_JS.Set("fftSize", input)
}

// FrequencyBinCount returning attribute 'frequencyBinCount' with
// type uint (idl: unsigned long).
func (_this *AnalyserNode) FrequencyBinCount() uint {
	var ret uint
	value := _this.Value_JS.Get("frequencyBinCount")
	ret = (uint)((value).Int())
	return ret
}

// MinDecibels returning attribute 'minDecibels' with
// type float64 (idl: double).
func (_this *AnalyserNode) MinDecibels() float64 {
	var ret float64
	value := _this.Value_JS.Get("minDecibels")
	ret = (value).Float()
	return ret
}

// SetMinDecibels setting attribute 'minDecibels' with
// type float64 (idl: double).
func (_this *AnalyserNode) SetMinDecibels(value float64) {
	input := value
	_this.Value_JS.Set("minDecibels", input)
}

// MaxDecibels returning attribute 'maxDecibels' with
// type float64 (idl: double).
func (_this *AnalyserNode) MaxDecibels() float64 {
	var ret float64
	value := _this.Value_JS.Get("maxDecibels")
	ret = (value).Float()
	return ret
}

// SetMaxDecibels setting attribute 'maxDecibels' with
// type float64 (idl: double).
func (_this *AnalyserNode) SetMaxDecibels(value float64) {
	input := value
	_this.Value_JS.Set("maxDecibels", input)
}

// SmoothingTimeConstant returning attribute 'smoothingTimeConstant' with
// type float64 (idl: double).
func (_this *AnalyserNode) SmoothingTimeConstant() float64 {
	var ret float64
	value := _this.Value_JS.Get("smoothingTimeConstant")
	ret = (value).Float()
	return ret
}

// SetSmoothingTimeConstant setting attribute 'smoothingTimeConstant' with
// type float64 (idl: double).
func (_this *AnalyserNode) SetSmoothingTimeConstant(value float64) {
	input := value
	_this.Value_JS.Set("smoothingTimeConstant", input)
}

func (_this *AnalyserNode) GetFloatFrequencyData(array *javascript.Float32Array) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := array.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("getFloatFrequencyData", _args[0:_end]...)
	return
}

func (_this *AnalyserNode) GetByteFrequencyData(array *javascript.Uint8Array) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := array.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("getByteFrequencyData", _args[0:_end]...)
	return
}

func (_this *AnalyserNode) GetFloatTimeDomainData(array *javascript.Float32Array) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := array.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("getFloatTimeDomainData", _args[0:_end]...)
	return
}

func (_this *AnalyserNode) GetByteTimeDomainData(array *javascript.Uint8Array) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := array.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("getByteTimeDomainData", _args[0:_end]...)
	return
}

// interface: AudioBuffer
type AudioBuffer struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *AudioBuffer) JSValue() js.Value {
	return _this.Value_JS
}

// AudioBufferFromJS is casting a js.Wrapper into AudioBuffer.
func AudioBufferFromJS(value js.Wrapper) *AudioBuffer {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &AudioBuffer{}
	ret.Value_JS = input
	return ret
}

func NewAudioBuffer(options *AudioBufferOptions) (_result *AudioBuffer) {
	_klass := js.Global().Get("AudioBuffer")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := options.JSValue()
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *AudioBuffer // javascript: AudioBuffer _what_return_name
	)
	_converted = AudioBufferFromJS(_returned)
	_result = _converted
	return
}

// SampleRate returning attribute 'sampleRate' with
// type float32 (idl: float).
func (_this *AudioBuffer) SampleRate() float32 {
	var ret float32
	value := _this.Value_JS.Get("sampleRate")
	ret = (float32)((value).Float())
	return ret
}

// Length returning attribute 'length' with
// type uint (idl: unsigned long).
func (_this *AudioBuffer) Length() uint {
	var ret uint
	value := _this.Value_JS.Get("length")
	ret = (uint)((value).Int())
	return ret
}

// Duration returning attribute 'duration' with
// type float64 (idl: double).
func (_this *AudioBuffer) Duration() float64 {
	var ret float64
	value := _this.Value_JS.Get("duration")
	ret = (value).Float()
	return ret
}

// NumberOfChannels returning attribute 'numberOfChannels' with
// type uint (idl: unsigned long).
func (_this *AudioBuffer) NumberOfChannels() uint {
	var ret uint
	value := _this.Value_JS.Get("numberOfChannels")
	ret = (uint)((value).Int())
	return ret
}

func (_this *AudioBuffer) GetChannelData(channel uint) (_result *javascript.Float32Array) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := channel
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("getChannelData", _args[0:_end]...)
	var (
		_converted *javascript.Float32Array // javascript: Float32Array _what_return_name
	)
	_converted = javascript.Float32ArrayFromJS(_returned)
	_result = _converted
	return
}

func (_this *AudioBuffer) CopyFromChannel(destination *javascript.Float32Array, channelNumber uint, startInChannel *uint) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := destination.JSValue()
	_args[0] = _p0
	_end++
	_p1 := channelNumber
	_args[1] = _p1
	_end++
	if startInChannel != nil {
		_p2 := startInChannel
		_args[2] = _p2
		_end++
	}
	_this.Value_JS.Call("copyFromChannel", _args[0:_end]...)
	return
}

func (_this *AudioBuffer) CopyToChannel(source *javascript.Float32Array, channelNumber uint, startInChannel *uint) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := source.JSValue()
	_args[0] = _p0
	_end++
	_p1 := channelNumber
	_args[1] = _p1
	_end++
	if startInChannel != nil {
		_p2 := startInChannel
		_args[2] = _p2
		_end++
	}
	_this.Value_JS.Call("copyToChannel", _args[0:_end]...)
	return
}

// interface: AudioBufferSourceNode
type AudioBufferSourceNode struct {
	AudioScheduledSourceNode
}

// AudioBufferSourceNodeFromJS is casting a js.Wrapper into AudioBufferSourceNode.
func AudioBufferSourceNodeFromJS(value js.Wrapper) *AudioBufferSourceNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &AudioBufferSourceNode{}
	ret.Value_JS = input
	return ret
}

func NewAudioBufferSourceNode(context *BaseAudioContext, options *AudioBufferSourceOptions) (_result *AudioBufferSourceNode) {
	_klass := js.Global().Get("AudioBufferSourceNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *AudioBufferSourceNode // javascript: AudioBufferSourceNode _what_return_name
	)
	_converted = AudioBufferSourceNodeFromJS(_returned)
	_result = _converted
	return
}

// Buffer returning attribute 'buffer' with
// type AudioBuffer (idl: AudioBuffer).
func (_this *AudioBufferSourceNode) Buffer() *AudioBuffer {
	var ret *AudioBuffer
	value := _this.Value_JS.Get("buffer")
	if value.Type() != js.TypeNull {
		ret = AudioBufferFromJS(value)
	}
	return ret
}

// SetBuffer setting attribute 'buffer' with
// type AudioBuffer (idl: AudioBuffer).
func (_this *AudioBufferSourceNode) SetBuffer(value *AudioBuffer) {
	input := value.JSValue()
	_this.Value_JS.Set("buffer", input)
}

// PlaybackRate returning attribute 'playbackRate' with
// type AudioParam (idl: AudioParam).
func (_this *AudioBufferSourceNode) PlaybackRate() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("playbackRate")
	ret = AudioParamFromJS(value)
	return ret
}

// Detune returning attribute 'detune' with
// type AudioParam (idl: AudioParam).
func (_this *AudioBufferSourceNode) Detune() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("detune")
	ret = AudioParamFromJS(value)
	return ret
}

// Loop returning attribute 'loop' with
// type bool (idl: boolean).
func (_this *AudioBufferSourceNode) Loop() bool {
	var ret bool
	value := _this.Value_JS.Get("loop")
	ret = (value).Bool()
	return ret
}

// SetLoop setting attribute 'loop' with
// type bool (idl: boolean).
func (_this *AudioBufferSourceNode) SetLoop(value bool) {
	input := value
	_this.Value_JS.Set("loop", input)
}

// LoopStart returning attribute 'loopStart' with
// type float64 (idl: double).
func (_this *AudioBufferSourceNode) LoopStart() float64 {
	var ret float64
	value := _this.Value_JS.Get("loopStart")
	ret = (value).Float()
	return ret
}

// SetLoopStart setting attribute 'loopStart' with
// type float64 (idl: double).
func (_this *AudioBufferSourceNode) SetLoopStart(value float64) {
	input := value
	_this.Value_JS.Set("loopStart", input)
}

// LoopEnd returning attribute 'loopEnd' with
// type float64 (idl: double).
func (_this *AudioBufferSourceNode) LoopEnd() float64 {
	var ret float64
	value := _this.Value_JS.Get("loopEnd")
	ret = (value).Float()
	return ret
}

// SetLoopEnd setting attribute 'loopEnd' with
// type float64 (idl: double).
func (_this *AudioBufferSourceNode) SetLoopEnd(value float64) {
	input := value
	_this.Value_JS.Set("loopEnd", input)
}

func (_this *AudioBufferSourceNode) Start2(when *float64, offset *float64, duration *float64) {
	var (
		_args [3]interface{}
		_end  int
	)
	if when != nil {
		_p0 := when
		_args[0] = _p0
		_end++
	}
	if offset != nil {
		_p1 := offset
		_args[1] = _p1
		_end++
	}
	if duration != nil {
		_p2 := duration
		_args[2] = _p2
		_end++
	}
	_this.Value_JS.Call("start", _args[0:_end]...)
	return
}

// interface: AudioContext
type AudioContext struct {
	BaseAudioContext
}

// AudioContextFromJS is casting a js.Wrapper into AudioContext.
func AudioContextFromJS(value js.Wrapper) *AudioContext {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &AudioContext{}
	ret.Value_JS = input
	return ret
}

func NewAudioContext(contextOptions *AudioContextOptions) (_result *AudioContext) {
	_klass := js.Global().Get("AudioContext")
	var (
		_args [1]interface{}
		_end  int
	)
	if contextOptions != nil {
		_p0 := contextOptions.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *AudioContext // javascript: AudioContext _what_return_name
	)
	_converted = AudioContextFromJS(_returned)
	_result = _converted
	return
}

// BaseLatency returning attribute 'baseLatency' with
// type float64 (idl: double).
func (_this *AudioContext) BaseLatency() float64 {
	var ret float64
	value := _this.Value_JS.Get("baseLatency")
	ret = (value).Float()
	return ret
}

// OutputLatency returning attribute 'outputLatency' with
// type float64 (idl: double).
func (_this *AudioContext) OutputLatency() float64 {
	var ret float64
	value := _this.Value_JS.Get("outputLatency")
	ret = (value).Float()
	return ret
}

func (_this *AudioContext) GetOutputTimestamp() (_result *AudioTimestamp) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getOutputTimestamp", _args[0:_end]...)
	var (
		_converted *AudioTimestamp // javascript: AudioTimestamp _what_return_name
	)
	_converted = AudioTimestampFromJS(_returned)
	_result = _converted
	return
}

func (_this *AudioContext) Resume() (_result *javascript.Promise) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("resume", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *AudioContext) Suspend() (_result *javascript.Promise) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("suspend", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *AudioContext) Close() (_result *javascript.Promise) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("close", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *AudioContext) CreateMediaElementSource(mediaElement *media.HTMLMediaElement) (_result *MediaElementAudioSourceNode) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := mediaElement.JSValue()
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("createMediaElementSource", _args[0:_end]...)
	var (
		_converted *MediaElementAudioSourceNode // javascript: MediaElementAudioSourceNode _what_return_name
	)
	_converted = MediaElementAudioSourceNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *AudioContext) CreateMediaStreamSource(mediaStream *local.MediaStream) (_result *MediaStreamAudioSourceNode) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := mediaStream.JSValue()
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("createMediaStreamSource", _args[0:_end]...)
	var (
		_converted *MediaStreamAudioSourceNode // javascript: MediaStreamAudioSourceNode _what_return_name
	)
	_converted = MediaStreamAudioSourceNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *AudioContext) CreateMediaStreamTrackSource(mediaStreamTrack *local.MediaStreamTrack) (_result *MediaStreamTrackAudioSourceNode) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := mediaStreamTrack.JSValue()
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("createMediaStreamTrackSource", _args[0:_end]...)
	var (
		_converted *MediaStreamTrackAudioSourceNode // javascript: MediaStreamTrackAudioSourceNode _what_return_name
	)
	_converted = MediaStreamTrackAudioSourceNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *AudioContext) CreateMediaStreamDestination() (_result *MediaStreamAudioDestinationNode) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("createMediaStreamDestination", _args[0:_end]...)
	var (
		_converted *MediaStreamAudioDestinationNode // javascript: MediaStreamAudioDestinationNode _what_return_name
	)
	_converted = MediaStreamAudioDestinationNodeFromJS(_returned)
	_result = _converted
	return
}

// interface: AudioDestinationNode
type AudioDestinationNode struct {
	AudioNode
}

// AudioDestinationNodeFromJS is casting a js.Wrapper into AudioDestinationNode.
func AudioDestinationNodeFromJS(value js.Wrapper) *AudioDestinationNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &AudioDestinationNode{}
	ret.Value_JS = input
	return ret
}

// MaxChannelCount returning attribute 'maxChannelCount' with
// type uint (idl: unsigned long).
func (_this *AudioDestinationNode) MaxChannelCount() uint {
	var ret uint
	value := _this.Value_JS.Get("maxChannelCount")
	ret = (uint)((value).Int())
	return ret
}

// interface: AudioListener
type AudioListener struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *AudioListener) JSValue() js.Value {
	return _this.Value_JS
}

// AudioListenerFromJS is casting a js.Wrapper into AudioListener.
func AudioListenerFromJS(value js.Wrapper) *AudioListener {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &AudioListener{}
	ret.Value_JS = input
	return ret
}

// PositionX returning attribute 'positionX' with
// type AudioParam (idl: AudioParam).
func (_this *AudioListener) PositionX() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("positionX")
	ret = AudioParamFromJS(value)
	return ret
}

// PositionY returning attribute 'positionY' with
// type AudioParam (idl: AudioParam).
func (_this *AudioListener) PositionY() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("positionY")
	ret = AudioParamFromJS(value)
	return ret
}

// PositionZ returning attribute 'positionZ' with
// type AudioParam (idl: AudioParam).
func (_this *AudioListener) PositionZ() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("positionZ")
	ret = AudioParamFromJS(value)
	return ret
}

// ForwardX returning attribute 'forwardX' with
// type AudioParam (idl: AudioParam).
func (_this *AudioListener) ForwardX() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("forwardX")
	ret = AudioParamFromJS(value)
	return ret
}

// ForwardY returning attribute 'forwardY' with
// type AudioParam (idl: AudioParam).
func (_this *AudioListener) ForwardY() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("forwardY")
	ret = AudioParamFromJS(value)
	return ret
}

// ForwardZ returning attribute 'forwardZ' with
// type AudioParam (idl: AudioParam).
func (_this *AudioListener) ForwardZ() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("forwardZ")
	ret = AudioParamFromJS(value)
	return ret
}

// UpX returning attribute 'upX' with
// type AudioParam (idl: AudioParam).
func (_this *AudioListener) UpX() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("upX")
	ret = AudioParamFromJS(value)
	return ret
}

// UpY returning attribute 'upY' with
// type AudioParam (idl: AudioParam).
func (_this *AudioListener) UpY() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("upY")
	ret = AudioParamFromJS(value)
	return ret
}

// UpZ returning attribute 'upZ' with
// type AudioParam (idl: AudioParam).
func (_this *AudioListener) UpZ() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("upZ")
	ret = AudioParamFromJS(value)
	return ret
}

func (_this *AudioListener) SetPosition(x float32, y float32, z float32) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := x
	_args[0] = _p0
	_end++
	_p1 := y
	_args[1] = _p1
	_end++
	_p2 := z
	_args[2] = _p2
	_end++
	_this.Value_JS.Call("setPosition", _args[0:_end]...)
	return
}

func (_this *AudioListener) SetOrientation(x float32, y float32, z float32, xUp float32, yUp float32, zUp float32) {
	var (
		_args [6]interface{}
		_end  int
	)
	_p0 := x
	_args[0] = _p0
	_end++
	_p1 := y
	_args[1] = _p1
	_end++
	_p2 := z
	_args[2] = _p2
	_end++
	_p3 := xUp
	_args[3] = _p3
	_end++
	_p4 := yUp
	_args[4] = _p4
	_end++
	_p5 := zUp
	_args[5] = _p5
	_end++
	_this.Value_JS.Call("setOrientation", _args[0:_end]...)
	return
}

// interface: AudioNode
type AudioNode struct {
	domcore.EventTarget
}

// AudioNodeFromJS is casting a js.Wrapper into AudioNode.
func AudioNodeFromJS(value js.Wrapper) *AudioNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &AudioNode{}
	ret.Value_JS = input
	return ret
}

// Context returning attribute 'context' with
// type BaseAudioContext (idl: BaseAudioContext).
func (_this *AudioNode) Context() *BaseAudioContext {
	var ret *BaseAudioContext
	value := _this.Value_JS.Get("context")
	ret = BaseAudioContextFromJS(value)
	return ret
}

// NumberOfInputs returning attribute 'numberOfInputs' with
// type uint (idl: unsigned long).
func (_this *AudioNode) NumberOfInputs() uint {
	var ret uint
	value := _this.Value_JS.Get("numberOfInputs")
	ret = (uint)((value).Int())
	return ret
}

// NumberOfOutputs returning attribute 'numberOfOutputs' with
// type uint (idl: unsigned long).
func (_this *AudioNode) NumberOfOutputs() uint {
	var ret uint
	value := _this.Value_JS.Get("numberOfOutputs")
	ret = (uint)((value).Int())
	return ret
}

// ChannelCount returning attribute 'channelCount' with
// type uint (idl: unsigned long).
func (_this *AudioNode) ChannelCount() uint {
	var ret uint
	value := _this.Value_JS.Get("channelCount")
	ret = (uint)((value).Int())
	return ret
}

// SetChannelCount setting attribute 'channelCount' with
// type uint (idl: unsigned long).
func (_this *AudioNode) SetChannelCount(value uint) {
	input := value
	_this.Value_JS.Set("channelCount", input)
}

// ChannelCountMode returning attribute 'channelCountMode' with
// type ChannelCountMode (idl: ChannelCountMode).
func (_this *AudioNode) ChannelCountMode() ChannelCountMode {
	var ret ChannelCountMode
	value := _this.Value_JS.Get("channelCountMode")
	ret = ChannelCountModeFromJS(value)
	return ret
}

// SetChannelCountMode setting attribute 'channelCountMode' with
// type ChannelCountMode (idl: ChannelCountMode).
func (_this *AudioNode) SetChannelCountMode(value ChannelCountMode) {
	input := value.JSValue()
	_this.Value_JS.Set("channelCountMode", input)
}

// ChannelInterpretation returning attribute 'channelInterpretation' with
// type ChannelInterpretation (idl: ChannelInterpretation).
func (_this *AudioNode) ChannelInterpretation() ChannelInterpretation {
	var ret ChannelInterpretation
	value := _this.Value_JS.Get("channelInterpretation")
	ret = ChannelInterpretationFromJS(value)
	return ret
}

// SetChannelInterpretation setting attribute 'channelInterpretation' with
// type ChannelInterpretation (idl: ChannelInterpretation).
func (_this *AudioNode) SetChannelInterpretation(value ChannelInterpretation) {
	input := value.JSValue()
	_this.Value_JS.Set("channelInterpretation", input)
}

func (_this *AudioNode) Connect(destinationNode *AudioNode, output *uint, input *uint) (_result *AudioNode) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := destinationNode.JSValue()
	_args[0] = _p0
	_end++
	if output != nil {
		_p1 := output
		_args[1] = _p1
		_end++
	}
	if input != nil {
		_p2 := input
		_args[2] = _p2
		_end++
	}
	_returned := _this.Value_JS.Call("connect", _args[0:_end]...)
	var (
		_converted *AudioNode // javascript: AudioNode _what_return_name
	)
	_converted = AudioNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *AudioNode) Connect2(destinationParam *AudioParam, output *uint) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := destinationParam.JSValue()
	_args[0] = _p0
	_end++
	if output != nil {
		_p1 := output
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("connect", _args[0:_end]...)
	return
}

func (_this *AudioNode) Disconnect() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("disconnect", _args[0:_end]...)
	return
}

func (_this *AudioNode) Disconnect2(output uint) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := output
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("disconnect", _args[0:_end]...)
	return
}

func (_this *AudioNode) Disconnect3(destinationNode *AudioNode) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := destinationNode.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("disconnect", _args[0:_end]...)
	return
}

func (_this *AudioNode) Disconnect4(destinationNode *AudioNode, output uint) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := destinationNode.JSValue()
	_args[0] = _p0
	_end++
	_p1 := output
	_args[1] = _p1
	_end++
	_this.Value_JS.Call("disconnect", _args[0:_end]...)
	return
}

func (_this *AudioNode) Disconnect5(destinationNode *AudioNode, output uint, input uint) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := destinationNode.JSValue()
	_args[0] = _p0
	_end++
	_p1 := output
	_args[1] = _p1
	_end++
	_p2 := input
	_args[2] = _p2
	_end++
	_this.Value_JS.Call("disconnect", _args[0:_end]...)
	return
}

func (_this *AudioNode) Disconnect6(destinationParam *AudioParam) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := destinationParam.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("disconnect", _args[0:_end]...)
	return
}

func (_this *AudioNode) Disconnect7(destinationParam *AudioParam, output uint) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := destinationParam.JSValue()
	_args[0] = _p0
	_end++
	_p1 := output
	_args[1] = _p1
	_end++
	_this.Value_JS.Call("disconnect", _args[0:_end]...)
	return
}

// interface: AudioParam
type AudioParam struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *AudioParam) JSValue() js.Value {
	return _this.Value_JS
}

// AudioParamFromJS is casting a js.Wrapper into AudioParam.
func AudioParamFromJS(value js.Wrapper) *AudioParam {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &AudioParam{}
	ret.Value_JS = input
	return ret
}

// Value returning attribute 'value' with
// type float32 (idl: float).
func (_this *AudioParam) Value() float32 {
	var ret float32
	value := _this.Value_JS.Get("value")
	ret = (float32)((value).Float())
	return ret
}

// SetValue setting attribute 'value' with
// type float32 (idl: float).
func (_this *AudioParam) SetValue(value float32) {
	input := value
	_this.Value_JS.Set("value", input)
}

// AutomationRate returning attribute 'automationRate' with
// type AutomationRate (idl: AutomationRate).
func (_this *AudioParam) AutomationRate() AutomationRate {
	var ret AutomationRate
	value := _this.Value_JS.Get("automationRate")
	ret = AutomationRateFromJS(value)
	return ret
}

// SetAutomationRate setting attribute 'automationRate' with
// type AutomationRate (idl: AutomationRate).
func (_this *AudioParam) SetAutomationRate(value AutomationRate) {
	input := value.JSValue()
	_this.Value_JS.Set("automationRate", input)
}

// DefaultValue returning attribute 'defaultValue' with
// type float32 (idl: float).
func (_this *AudioParam) DefaultValue() float32 {
	var ret float32
	value := _this.Value_JS.Get("defaultValue")
	ret = (float32)((value).Float())
	return ret
}

// MinValue returning attribute 'minValue' with
// type float32 (idl: float).
func (_this *AudioParam) MinValue() float32 {
	var ret float32
	value := _this.Value_JS.Get("minValue")
	ret = (float32)((value).Float())
	return ret
}

// MaxValue returning attribute 'maxValue' with
// type float32 (idl: float).
func (_this *AudioParam) MaxValue() float32 {
	var ret float32
	value := _this.Value_JS.Get("maxValue")
	ret = (float32)((value).Float())
	return ret
}

func (_this *AudioParam) SetValueAtTime(value float32, startTime float64) (_result *AudioParam) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := value
	_args[0] = _p0
	_end++
	_p1 := startTime
	_args[1] = _p1
	_end++
	_returned := _this.Value_JS.Call("setValueAtTime", _args[0:_end]...)
	var (
		_converted *AudioParam // javascript: AudioParam _what_return_name
	)
	_converted = AudioParamFromJS(_returned)
	_result = _converted
	return
}

func (_this *AudioParam) LinearRampToValueAtTime(value float32, endTime float64) (_result *AudioParam) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := value
	_args[0] = _p0
	_end++
	_p1 := endTime
	_args[1] = _p1
	_end++
	_returned := _this.Value_JS.Call("linearRampToValueAtTime", _args[0:_end]...)
	var (
		_converted *AudioParam // javascript: AudioParam _what_return_name
	)
	_converted = AudioParamFromJS(_returned)
	_result = _converted
	return
}

func (_this *AudioParam) ExponentialRampToValueAtTime(value float32, endTime float64) (_result *AudioParam) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := value
	_args[0] = _p0
	_end++
	_p1 := endTime
	_args[1] = _p1
	_end++
	_returned := _this.Value_JS.Call("exponentialRampToValueAtTime", _args[0:_end]...)
	var (
		_converted *AudioParam // javascript: AudioParam _what_return_name
	)
	_converted = AudioParamFromJS(_returned)
	_result = _converted
	return
}

func (_this *AudioParam) SetTargetAtTime(target float32, startTime float64, timeConstant float32) (_result *AudioParam) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := target
	_args[0] = _p0
	_end++
	_p1 := startTime
	_args[1] = _p1
	_end++
	_p2 := timeConstant
	_args[2] = _p2
	_end++
	_returned := _this.Value_JS.Call("setTargetAtTime", _args[0:_end]...)
	var (
		_converted *AudioParam // javascript: AudioParam _what_return_name
	)
	_converted = AudioParamFromJS(_returned)
	_result = _converted
	return
}

func (_this *AudioParam) SetValueCurveAtTime(values js.Value, startTime float64, duration float64) (_result *AudioParam) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := values
	_args[0] = _p0
	_end++
	_p1 := startTime
	_args[1] = _p1
	_end++
	_p2 := duration
	_args[2] = _p2
	_end++
	_returned := _this.Value_JS.Call("setValueCurveAtTime", _args[0:_end]...)
	var (
		_converted *AudioParam // javascript: AudioParam _what_return_name
	)
	_converted = AudioParamFromJS(_returned)
	_result = _converted
	return
}

func (_this *AudioParam) CancelScheduledValues(cancelTime float64) (_result *AudioParam) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := cancelTime
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("cancelScheduledValues", _args[0:_end]...)
	var (
		_converted *AudioParam // javascript: AudioParam _what_return_name
	)
	_converted = AudioParamFromJS(_returned)
	_result = _converted
	return
}

func (_this *AudioParam) CancelAndHoldAtTime(cancelTime float64) (_result *AudioParam) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := cancelTime
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("cancelAndHoldAtTime", _args[0:_end]...)
	var (
		_converted *AudioParam // javascript: AudioParam _what_return_name
	)
	_converted = AudioParamFromJS(_returned)
	_result = _converted
	return
}

// interface: AudioParamMap
type AudioParamMap struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *AudioParamMap) JSValue() js.Value {
	return _this.Value_JS
}

// AudioParamMapFromJS is casting a js.Wrapper into AudioParamMap.
func AudioParamMapFromJS(value js.Wrapper) *AudioParamMap {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &AudioParamMap{}
	ret.Value_JS = input
	return ret
}

// interface: AudioProcessingEvent
type AudioProcessingEvent struct {
	domcore.Event
}

// AudioProcessingEventFromJS is casting a js.Wrapper into AudioProcessingEvent.
func AudioProcessingEventFromJS(value js.Wrapper) *AudioProcessingEvent {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &AudioProcessingEvent{}
	ret.Value_JS = input
	return ret
}

func NewAudioProcessingEvent(_type string, eventInitDict *AudioProcessingEventInit) (_result *AudioProcessingEvent) {
	_klass := js.Global().Get("AudioProcessingEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := eventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *AudioProcessingEvent // javascript: AudioProcessingEvent _what_return_name
	)
	_converted = AudioProcessingEventFromJS(_returned)
	_result = _converted
	return
}

// PlaybackTime returning attribute 'playbackTime' with
// type float64 (idl: double).
func (_this *AudioProcessingEvent) PlaybackTime() float64 {
	var ret float64
	value := _this.Value_JS.Get("playbackTime")
	ret = (value).Float()
	return ret
}

// InputBuffer returning attribute 'inputBuffer' with
// type AudioBuffer (idl: AudioBuffer).
func (_this *AudioProcessingEvent) InputBuffer() *AudioBuffer {
	var ret *AudioBuffer
	value := _this.Value_JS.Get("inputBuffer")
	ret = AudioBufferFromJS(value)
	return ret
}

// OutputBuffer returning attribute 'outputBuffer' with
// type AudioBuffer (idl: AudioBuffer).
func (_this *AudioProcessingEvent) OutputBuffer() *AudioBuffer {
	var ret *AudioBuffer
	value := _this.Value_JS.Get("outputBuffer")
	ret = AudioBufferFromJS(value)
	return ret
}

// interface: AudioScheduledSourceNode
type AudioScheduledSourceNode struct {
	AudioNode
}

// AudioScheduledSourceNodeFromJS is casting a js.Wrapper into AudioScheduledSourceNode.
func AudioScheduledSourceNodeFromJS(value js.Wrapper) *AudioScheduledSourceNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &AudioScheduledSourceNode{}
	ret.Value_JS = input
	return ret
}

// Onended returning attribute 'onended' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *AudioScheduledSourceNode) Onended() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onended")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnended setting attribute 'onended' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *AudioScheduledSourceNode) SetOnended(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onended", input)
}

func (_this *AudioScheduledSourceNode) Start(when *float64) {
	var (
		_args [1]interface{}
		_end  int
	)
	if when != nil {
		_p0 := when
		_args[0] = _p0
		_end++
	}
	_this.Value_JS.Call("start", _args[0:_end]...)
	return
}

func (_this *AudioScheduledSourceNode) Stop(when *float64) {
	var (
		_args [1]interface{}
		_end  int
	)
	if when != nil {
		_p0 := when
		_args[0] = _p0
		_end++
	}
	_this.Value_JS.Call("stop", _args[0:_end]...)
	return
}

// interface: AudioWorklet
type AudioWorklet struct {
	worklets.Worklet
}

// AudioWorkletFromJS is casting a js.Wrapper into AudioWorklet.
func AudioWorkletFromJS(value js.Wrapper) *AudioWorklet {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &AudioWorklet{}
	ret.Value_JS = input
	return ret
}

// interface: AudioWorkletGlobalScope
type AudioWorkletGlobalScope struct {
	worklets.WorkletGlobalScope
}

// AudioWorkletGlobalScopeFromJS is casting a js.Wrapper into AudioWorkletGlobalScope.
func AudioWorkletGlobalScopeFromJS(value js.Wrapper) *AudioWorkletGlobalScope {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &AudioWorkletGlobalScope{}
	ret.Value_JS = input
	return ret
}

// CurrentFrame returning attribute 'currentFrame' with
// type int (idl: unsigned long long).
func (_this *AudioWorkletGlobalScope) CurrentFrame() int {
	var ret int
	value := _this.Value_JS.Get("currentFrame")
	ret = (value).Int()
	return ret
}

// CurrentTime returning attribute 'currentTime' with
// type float64 (idl: double).
func (_this *AudioWorkletGlobalScope) CurrentTime() float64 {
	var ret float64
	value := _this.Value_JS.Get("currentTime")
	ret = (value).Float()
	return ret
}

// SampleRate returning attribute 'sampleRate' with
// type float32 (idl: float).
func (_this *AudioWorkletGlobalScope) SampleRate() float32 {
	var ret float32
	value := _this.Value_JS.Get("sampleRate")
	ret = (float32)((value).Float())
	return ret
}

func (_this *AudioWorkletGlobalScope) RegisterProcessor(name string, processorCtor *webidl.VoidFunction) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := name
	_args[0] = _p0
	_end++

	var __callback1 js.Value
	if processorCtor != nil {
		__callback1 = (*processorCtor).Value
	} else {
		__callback1 = js.Null()
	}
	_p1 := __callback1
	_args[1] = _p1
	_end++
	_this.Value_JS.Call("registerProcessor", _args[0:_end]...)
	return
}

// interface: AudioWorkletNode
type AudioWorkletNode struct {
	AudioNode
}

// AudioWorkletNodeFromJS is casting a js.Wrapper into AudioWorkletNode.
func AudioWorkletNodeFromJS(value js.Wrapper) *AudioWorkletNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &AudioWorkletNode{}
	ret.Value_JS = input
	return ret
}

func NewAudioWorkletNode(context *BaseAudioContext, name string, options *AudioWorkletNodeOptions) (_result *AudioWorkletNode) {
	_klass := js.Global().Get("AudioWorkletNode")
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	_p1 := name
	_args[1] = _p1
	_end++
	if options != nil {
		_p2 := options.JSValue()
		_args[2] = _p2
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *AudioWorkletNode // javascript: AudioWorkletNode _what_return_name
	)
	_converted = AudioWorkletNodeFromJS(_returned)
	_result = _converted
	return
}

// Parameters returning attribute 'parameters' with
// type AudioParamMap (idl: AudioParamMap).
func (_this *AudioWorkletNode) Parameters() *AudioParamMap {
	var ret *AudioParamMap
	value := _this.Value_JS.Get("parameters")
	ret = AudioParamMapFromJS(value)
	return ret
}

// Port returning attribute 'port' with
// type channel.MessagePort (idl: MessagePort).
func (_this *AudioWorkletNode) Port() *channel.MessagePort {
	var ret *channel.MessagePort
	value := _this.Value_JS.Get("port")
	ret = channel.MessagePortFromJS(value)
	return ret
}

// Onprocessorerror returning attribute 'onprocessorerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *AudioWorkletNode) Onprocessorerror() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onprocessorerror")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnprocessorerror setting attribute 'onprocessorerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *AudioWorkletNode) SetOnprocessorerror(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onprocessorerror", input)
}

// interface: AudioWorkletProcessor
type AudioWorkletProcessor struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *AudioWorkletProcessor) JSValue() js.Value {
	return _this.Value_JS
}

// AudioWorkletProcessorFromJS is casting a js.Wrapper into AudioWorkletProcessor.
func AudioWorkletProcessorFromJS(value js.Wrapper) *AudioWorkletProcessor {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &AudioWorkletProcessor{}
	ret.Value_JS = input
	return ret
}

func NewAudioWorkletProcessor(options *AudioWorkletNodeOptions) (_result *AudioWorkletProcessor) {
	_klass := js.Global().Get("AudioWorkletProcessor")
	var (
		_args [1]interface{}
		_end  int
	)
	if options != nil {
		_p0 := options.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *AudioWorkletProcessor // javascript: AudioWorkletProcessor _what_return_name
	)
	_converted = AudioWorkletProcessorFromJS(_returned)
	_result = _converted
	return
}

// Port returning attribute 'port' with
// type channel.MessagePort (idl: MessagePort).
func (_this *AudioWorkletProcessor) Port() *channel.MessagePort {
	var ret *channel.MessagePort
	value := _this.Value_JS.Get("port")
	ret = channel.MessagePortFromJS(value)
	return ret
}

// interface: BaseAudioContext
type BaseAudioContext struct {
	domcore.EventTarget
}

// BaseAudioContextFromJS is casting a js.Wrapper into BaseAudioContext.
func BaseAudioContextFromJS(value js.Wrapper) *BaseAudioContext {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &BaseAudioContext{}
	ret.Value_JS = input
	return ret
}

// Destination returning attribute 'destination' with
// type AudioDestinationNode (idl: AudioDestinationNode).
func (_this *BaseAudioContext) Destination() *AudioDestinationNode {
	var ret *AudioDestinationNode
	value := _this.Value_JS.Get("destination")
	ret = AudioDestinationNodeFromJS(value)
	return ret
}

// SampleRate returning attribute 'sampleRate' with
// type float32 (idl: float).
func (_this *BaseAudioContext) SampleRate() float32 {
	var ret float32
	value := _this.Value_JS.Get("sampleRate")
	ret = (float32)((value).Float())
	return ret
}

// CurrentTime returning attribute 'currentTime' with
// type float64 (idl: double).
func (_this *BaseAudioContext) CurrentTime() float64 {
	var ret float64
	value := _this.Value_JS.Get("currentTime")
	ret = (value).Float()
	return ret
}

// Listener returning attribute 'listener' with
// type AudioListener (idl: AudioListener).
func (_this *BaseAudioContext) Listener() *AudioListener {
	var ret *AudioListener
	value := _this.Value_JS.Get("listener")
	ret = AudioListenerFromJS(value)
	return ret
}

// State returning attribute 'state' with
// type AudioContextState (idl: AudioContextState).
func (_this *BaseAudioContext) State() AudioContextState {
	var ret AudioContextState
	value := _this.Value_JS.Get("state")
	ret = AudioContextStateFromJS(value)
	return ret
}

// AudioWorklet returning attribute 'audioWorklet' with
// type AudioWorklet (idl: AudioWorklet).
func (_this *BaseAudioContext) AudioWorklet() *AudioWorklet {
	var ret *AudioWorklet
	value := _this.Value_JS.Get("audioWorklet")
	ret = AudioWorkletFromJS(value)
	return ret
}

// Onstatechange returning attribute 'onstatechange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *BaseAudioContext) Onstatechange() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onstatechange")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnstatechange setting attribute 'onstatechange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *BaseAudioContext) SetOnstatechange(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onstatechange", input)
}

func (_this *BaseAudioContext) CreateAnalyser() (_result *AnalyserNode) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("createAnalyser", _args[0:_end]...)
	var (
		_converted *AnalyserNode // javascript: AnalyserNode _what_return_name
	)
	_converted = AnalyserNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *BaseAudioContext) CreateBiquadFilter() (_result *BiquadFilterNode) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("createBiquadFilter", _args[0:_end]...)
	var (
		_converted *BiquadFilterNode // javascript: BiquadFilterNode _what_return_name
	)
	_converted = BiquadFilterNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *BaseAudioContext) CreateBuffer(numberOfChannels uint, length uint, sampleRate float32) (_result *AudioBuffer) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := numberOfChannels
	_args[0] = _p0
	_end++
	_p1 := length
	_args[1] = _p1
	_end++
	_p2 := sampleRate
	_args[2] = _p2
	_end++
	_returned := _this.Value_JS.Call("createBuffer", _args[0:_end]...)
	var (
		_converted *AudioBuffer // javascript: AudioBuffer _what_return_name
	)
	_converted = AudioBufferFromJS(_returned)
	_result = _converted
	return
}

func (_this *BaseAudioContext) CreateBufferSource() (_result *AudioBufferSourceNode) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("createBufferSource", _args[0:_end]...)
	var (
		_converted *AudioBufferSourceNode // javascript: AudioBufferSourceNode _what_return_name
	)
	_converted = AudioBufferSourceNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *BaseAudioContext) CreateChannelMerger(numberOfInputs *uint) (_result *ChannelMergerNode) {
	var (
		_args [1]interface{}
		_end  int
	)
	if numberOfInputs != nil {
		_p0 := numberOfInputs
		_args[0] = _p0
		_end++
	}
	_returned := _this.Value_JS.Call("createChannelMerger", _args[0:_end]...)
	var (
		_converted *ChannelMergerNode // javascript: ChannelMergerNode _what_return_name
	)
	_converted = ChannelMergerNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *BaseAudioContext) CreateChannelSplitter(numberOfOutputs *uint) (_result *ChannelSplitterNode) {
	var (
		_args [1]interface{}
		_end  int
	)
	if numberOfOutputs != nil {
		_p0 := numberOfOutputs
		_args[0] = _p0
		_end++
	}
	_returned := _this.Value_JS.Call("createChannelSplitter", _args[0:_end]...)
	var (
		_converted *ChannelSplitterNode // javascript: ChannelSplitterNode _what_return_name
	)
	_converted = ChannelSplitterNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *BaseAudioContext) CreateConstantSource() (_result *ConstantSourceNode) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("createConstantSource", _args[0:_end]...)
	var (
		_converted *ConstantSourceNode // javascript: ConstantSourceNode _what_return_name
	)
	_converted = ConstantSourceNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *BaseAudioContext) CreateConvolver() (_result *ConvolverNode) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("createConvolver", _args[0:_end]...)
	var (
		_converted *ConvolverNode // javascript: ConvolverNode _what_return_name
	)
	_converted = ConvolverNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *BaseAudioContext) CreateDelay(maxDelayTime *float64) (_result *DelayNode) {
	var (
		_args [1]interface{}
		_end  int
	)
	if maxDelayTime != nil {
		_p0 := maxDelayTime
		_args[0] = _p0
		_end++
	}
	_returned := _this.Value_JS.Call("createDelay", _args[0:_end]...)
	var (
		_converted *DelayNode // javascript: DelayNode _what_return_name
	)
	_converted = DelayNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *BaseAudioContext) CreateDynamicsCompressor() (_result *DynamicsCompressorNode) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("createDynamicsCompressor", _args[0:_end]...)
	var (
		_converted *DynamicsCompressorNode // javascript: DynamicsCompressorNode _what_return_name
	)
	_converted = DynamicsCompressorNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *BaseAudioContext) CreateGain() (_result *GainNode) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("createGain", _args[0:_end]...)
	var (
		_converted *GainNode // javascript: GainNode _what_return_name
	)
	_converted = GainNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *BaseAudioContext) CreateIIRFilter(feedforward js.Value, feedback js.Value) (_result *IIRFilterNode) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := feedforward
	_args[0] = _p0
	_end++
	_p1 := feedback
	_args[1] = _p1
	_end++
	_returned := _this.Value_JS.Call("createIIRFilter", _args[0:_end]...)
	var (
		_converted *IIRFilterNode // javascript: IIRFilterNode _what_return_name
	)
	_converted = IIRFilterNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *BaseAudioContext) CreateOscillator() (_result *OscillatorNode) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("createOscillator", _args[0:_end]...)
	var (
		_converted *OscillatorNode // javascript: OscillatorNode _what_return_name
	)
	_converted = OscillatorNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *BaseAudioContext) CreatePanner() (_result *PannerNode) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("createPanner", _args[0:_end]...)
	var (
		_converted *PannerNode // javascript: PannerNode _what_return_name
	)
	_converted = PannerNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *BaseAudioContext) CreatePeriodicWave(real js.Value, imag js.Value, constraints *PeriodicWaveConstraints) (_result *PeriodicWave) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := real
	_args[0] = _p0
	_end++
	_p1 := imag
	_args[1] = _p1
	_end++
	if constraints != nil {
		_p2 := constraints.JSValue()
		_args[2] = _p2
		_end++
	}
	_returned := _this.Value_JS.Call("createPeriodicWave", _args[0:_end]...)
	var (
		_converted *PeriodicWave // javascript: PeriodicWave _what_return_name
	)
	_converted = PeriodicWaveFromJS(_returned)
	_result = _converted
	return
}

func (_this *BaseAudioContext) CreateScriptProcessor(bufferSize *uint, numberOfInputChannels *uint, numberOfOutputChannels *uint) (_result *ScriptProcessorNode) {
	var (
		_args [3]interface{}
		_end  int
	)
	if bufferSize != nil {
		_p0 := bufferSize
		_args[0] = _p0
		_end++
	}
	if numberOfInputChannels != nil {
		_p1 := numberOfInputChannels
		_args[1] = _p1
		_end++
	}
	if numberOfOutputChannels != nil {
		_p2 := numberOfOutputChannels
		_args[2] = _p2
		_end++
	}
	_returned := _this.Value_JS.Call("createScriptProcessor", _args[0:_end]...)
	var (
		_converted *ScriptProcessorNode // javascript: ScriptProcessorNode _what_return_name
	)
	_converted = ScriptProcessorNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *BaseAudioContext) CreateStereoPanner() (_result *StereoPannerNode) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("createStereoPanner", _args[0:_end]...)
	var (
		_converted *StereoPannerNode // javascript: StereoPannerNode _what_return_name
	)
	_converted = StereoPannerNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *BaseAudioContext) CreateWaveShaper() (_result *WaveShaperNode) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("createWaveShaper", _args[0:_end]...)
	var (
		_converted *WaveShaperNode // javascript: WaveShaperNode _what_return_name
	)
	_converted = WaveShaperNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *BaseAudioContext) DecodeAudioData(audioData *javascript.ArrayBuffer, successCallback *DecodeSuccessCallback, errorCallback *DecodeErrorCallback) (_result *javascript.Promise) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := audioData.JSValue()
	_args[0] = _p0
	_end++
	if successCallback != nil {

		var __callback1 js.Value
		if successCallback != nil {
			__callback1 = (*successCallback).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	if errorCallback != nil {

		var __callback2 js.Value
		if errorCallback != nil {
			__callback2 = (*errorCallback).Value
		} else {
			__callback2 = js.Null()
		}
		_p2 := __callback2
		_args[2] = _p2
		_end++
	}
	_returned := _this.Value_JS.Call("decodeAudioData", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

// interface: BiquadFilterNode
type BiquadFilterNode struct {
	AudioNode
}

// BiquadFilterNodeFromJS is casting a js.Wrapper into BiquadFilterNode.
func BiquadFilterNodeFromJS(value js.Wrapper) *BiquadFilterNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &BiquadFilterNode{}
	ret.Value_JS = input
	return ret
}

func NewBiquadFilterNode(context *BaseAudioContext, options *BiquadFilterOptions) (_result *BiquadFilterNode) {
	_klass := js.Global().Get("BiquadFilterNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *BiquadFilterNode // javascript: BiquadFilterNode _what_return_name
	)
	_converted = BiquadFilterNodeFromJS(_returned)
	_result = _converted
	return
}

// Type returning attribute 'type' with
// type BiquadFilterType (idl: BiquadFilterType).
func (_this *BiquadFilterNode) Type() BiquadFilterType {
	var ret BiquadFilterType
	value := _this.Value_JS.Get("type")
	ret = BiquadFilterTypeFromJS(value)
	return ret
}

// SetType setting attribute 'type' with
// type BiquadFilterType (idl: BiquadFilterType).
func (_this *BiquadFilterNode) SetType(value BiquadFilterType) {
	input := value.JSValue()
	_this.Value_JS.Set("type", input)
}

// Frequency returning attribute 'frequency' with
// type AudioParam (idl: AudioParam).
func (_this *BiquadFilterNode) Frequency() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("frequency")
	ret = AudioParamFromJS(value)
	return ret
}

// Detune returning attribute 'detune' with
// type AudioParam (idl: AudioParam).
func (_this *BiquadFilterNode) Detune() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("detune")
	ret = AudioParamFromJS(value)
	return ret
}

// Q returning attribute 'Q' with
// type AudioParam (idl: AudioParam).
func (_this *BiquadFilterNode) Q() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("Q")
	ret = AudioParamFromJS(value)
	return ret
}

// Gain returning attribute 'gain' with
// type AudioParam (idl: AudioParam).
func (_this *BiquadFilterNode) Gain() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("gain")
	ret = AudioParamFromJS(value)
	return ret
}

func (_this *BiquadFilterNode) GetFrequencyResponse(frequencyHz *javascript.Float32Array, magResponse *javascript.Float32Array, phaseResponse *javascript.Float32Array) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := frequencyHz.JSValue()
	_args[0] = _p0
	_end++
	_p1 := magResponse.JSValue()
	_args[1] = _p1
	_end++
	_p2 := phaseResponse.JSValue()
	_args[2] = _p2
	_end++
	_this.Value_JS.Call("getFrequencyResponse", _args[0:_end]...)
	return
}

// interface: ChannelMergerNode
type ChannelMergerNode struct {
	AudioNode
}

// ChannelMergerNodeFromJS is casting a js.Wrapper into ChannelMergerNode.
func ChannelMergerNodeFromJS(value js.Wrapper) *ChannelMergerNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &ChannelMergerNode{}
	ret.Value_JS = input
	return ret
}

func NewChannelMergerNode(context *BaseAudioContext, options *ChannelMergerOptions) (_result *ChannelMergerNode) {
	_klass := js.Global().Get("ChannelMergerNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *ChannelMergerNode // javascript: ChannelMergerNode _what_return_name
	)
	_converted = ChannelMergerNodeFromJS(_returned)
	_result = _converted
	return
}

// interface: ChannelSplitterNode
type ChannelSplitterNode struct {
	AudioNode
}

// ChannelSplitterNodeFromJS is casting a js.Wrapper into ChannelSplitterNode.
func ChannelSplitterNodeFromJS(value js.Wrapper) *ChannelSplitterNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &ChannelSplitterNode{}
	ret.Value_JS = input
	return ret
}

func NewChannelSplitterNode(context *BaseAudioContext, options *ChannelSplitterOptions) (_result *ChannelSplitterNode) {
	_klass := js.Global().Get("ChannelSplitterNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *ChannelSplitterNode // javascript: ChannelSplitterNode _what_return_name
	)
	_converted = ChannelSplitterNodeFromJS(_returned)
	_result = _converted
	return
}

// interface: ConstantSourceNode
type ConstantSourceNode struct {
	AudioScheduledSourceNode
}

// ConstantSourceNodeFromJS is casting a js.Wrapper into ConstantSourceNode.
func ConstantSourceNodeFromJS(value js.Wrapper) *ConstantSourceNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &ConstantSourceNode{}
	ret.Value_JS = input
	return ret
}

func NewConstantSourceNode(context *BaseAudioContext, options *ConstantSourceOptions) (_result *ConstantSourceNode) {
	_klass := js.Global().Get("ConstantSourceNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *ConstantSourceNode // javascript: ConstantSourceNode _what_return_name
	)
	_converted = ConstantSourceNodeFromJS(_returned)
	_result = _converted
	return
}

// Offset returning attribute 'offset' with
// type AudioParam (idl: AudioParam).
func (_this *ConstantSourceNode) Offset() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("offset")
	ret = AudioParamFromJS(value)
	return ret
}

// interface: ConvolverNode
type ConvolverNode struct {
	AudioNode
}

// ConvolverNodeFromJS is casting a js.Wrapper into ConvolverNode.
func ConvolverNodeFromJS(value js.Wrapper) *ConvolverNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &ConvolverNode{}
	ret.Value_JS = input
	return ret
}

func NewConvolverNode(context *BaseAudioContext, options *ConvolverOptions) (_result *ConvolverNode) {
	_klass := js.Global().Get("ConvolverNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *ConvolverNode // javascript: ConvolverNode _what_return_name
	)
	_converted = ConvolverNodeFromJS(_returned)
	_result = _converted
	return
}

// Buffer returning attribute 'buffer' with
// type AudioBuffer (idl: AudioBuffer).
func (_this *ConvolverNode) Buffer() *AudioBuffer {
	var ret *AudioBuffer
	value := _this.Value_JS.Get("buffer")
	if value.Type() != js.TypeNull {
		ret = AudioBufferFromJS(value)
	}
	return ret
}

// SetBuffer setting attribute 'buffer' with
// type AudioBuffer (idl: AudioBuffer).
func (_this *ConvolverNode) SetBuffer(value *AudioBuffer) {
	input := value.JSValue()
	_this.Value_JS.Set("buffer", input)
}

// Normalize returning attribute 'normalize' with
// type bool (idl: boolean).
func (_this *ConvolverNode) Normalize() bool {
	var ret bool
	value := _this.Value_JS.Get("normalize")
	ret = (value).Bool()
	return ret
}

// SetNormalize setting attribute 'normalize' with
// type bool (idl: boolean).
func (_this *ConvolverNode) SetNormalize(value bool) {
	input := value
	_this.Value_JS.Set("normalize", input)
}

// interface: DelayNode
type DelayNode struct {
	AudioNode
}

// DelayNodeFromJS is casting a js.Wrapper into DelayNode.
func DelayNodeFromJS(value js.Wrapper) *DelayNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &DelayNode{}
	ret.Value_JS = input
	return ret
}

func NewDelayNode(context *BaseAudioContext, options *DelayOptions) (_result *DelayNode) {
	_klass := js.Global().Get("DelayNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *DelayNode // javascript: DelayNode _what_return_name
	)
	_converted = DelayNodeFromJS(_returned)
	_result = _converted
	return
}

// DelayTime returning attribute 'delayTime' with
// type AudioParam (idl: AudioParam).
func (_this *DelayNode) DelayTime() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("delayTime")
	ret = AudioParamFromJS(value)
	return ret
}

// interface: DynamicsCompressorNode
type DynamicsCompressorNode struct {
	AudioNode
}

// DynamicsCompressorNodeFromJS is casting a js.Wrapper into DynamicsCompressorNode.
func DynamicsCompressorNodeFromJS(value js.Wrapper) *DynamicsCompressorNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &DynamicsCompressorNode{}
	ret.Value_JS = input
	return ret
}

func NewDynamicsCompressorNode(context *BaseAudioContext, options *DynamicsCompressorOptions) (_result *DynamicsCompressorNode) {
	_klass := js.Global().Get("DynamicsCompressorNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *DynamicsCompressorNode // javascript: DynamicsCompressorNode _what_return_name
	)
	_converted = DynamicsCompressorNodeFromJS(_returned)
	_result = _converted
	return
}

// Threshold returning attribute 'threshold' with
// type AudioParam (idl: AudioParam).
func (_this *DynamicsCompressorNode) Threshold() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("threshold")
	ret = AudioParamFromJS(value)
	return ret
}

// Knee returning attribute 'knee' with
// type AudioParam (idl: AudioParam).
func (_this *DynamicsCompressorNode) Knee() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("knee")
	ret = AudioParamFromJS(value)
	return ret
}

// Ratio returning attribute 'ratio' with
// type AudioParam (idl: AudioParam).
func (_this *DynamicsCompressorNode) Ratio() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("ratio")
	ret = AudioParamFromJS(value)
	return ret
}

// Reduction returning attribute 'reduction' with
// type float32 (idl: float).
func (_this *DynamicsCompressorNode) Reduction() float32 {
	var ret float32
	value := _this.Value_JS.Get("reduction")
	ret = (float32)((value).Float())
	return ret
}

// Attack returning attribute 'attack' with
// type AudioParam (idl: AudioParam).
func (_this *DynamicsCompressorNode) Attack() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("attack")
	ret = AudioParamFromJS(value)
	return ret
}

// Release returning attribute 'release' with
// type AudioParam (idl: AudioParam).
func (_this *DynamicsCompressorNode) Release() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("release")
	ret = AudioParamFromJS(value)
	return ret
}

// interface: GainNode
type GainNode struct {
	AudioNode
}

// GainNodeFromJS is casting a js.Wrapper into GainNode.
func GainNodeFromJS(value js.Wrapper) *GainNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &GainNode{}
	ret.Value_JS = input
	return ret
}

func NewGainNode(context *BaseAudioContext, options *GainOptions) (_result *GainNode) {
	_klass := js.Global().Get("GainNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *GainNode // javascript: GainNode _what_return_name
	)
	_converted = GainNodeFromJS(_returned)
	_result = _converted
	return
}

// Gain returning attribute 'gain' with
// type AudioParam (idl: AudioParam).
func (_this *GainNode) Gain() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("gain")
	ret = AudioParamFromJS(value)
	return ret
}

// interface: IIRFilterNode
type IIRFilterNode struct {
	AudioNode
}

// IIRFilterNodeFromJS is casting a js.Wrapper into IIRFilterNode.
func IIRFilterNodeFromJS(value js.Wrapper) *IIRFilterNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &IIRFilterNode{}
	ret.Value_JS = input
	return ret
}

func NewIIRFilterNode(context *BaseAudioContext, options *IIRFilterOptions) (_result *IIRFilterNode) {
	_klass := js.Global().Get("IIRFilterNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	_p1 := options.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *IIRFilterNode // javascript: IIRFilterNode _what_return_name
	)
	_converted = IIRFilterNodeFromJS(_returned)
	_result = _converted
	return
}

func (_this *IIRFilterNode) GetFrequencyResponse(frequencyHz *javascript.Float32Array, magResponse *javascript.Float32Array, phaseResponse *javascript.Float32Array) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := frequencyHz.JSValue()
	_args[0] = _p0
	_end++
	_p1 := magResponse.JSValue()
	_args[1] = _p1
	_end++
	_p2 := phaseResponse.JSValue()
	_args[2] = _p2
	_end++
	_this.Value_JS.Call("getFrequencyResponse", _args[0:_end]...)
	return
}

// interface: MediaElementAudioSourceNode
type MediaElementAudioSourceNode struct {
	AudioNode
}

// MediaElementAudioSourceNodeFromJS is casting a js.Wrapper into MediaElementAudioSourceNode.
func MediaElementAudioSourceNodeFromJS(value js.Wrapper) *MediaElementAudioSourceNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &MediaElementAudioSourceNode{}
	ret.Value_JS = input
	return ret
}

func NewMediaElementAudioSourceNode(context *AudioContext, options *MediaElementAudioSourceOptions) (_result *MediaElementAudioSourceNode) {
	_klass := js.Global().Get("MediaElementAudioSourceNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	_p1 := options.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *MediaElementAudioSourceNode // javascript: MediaElementAudioSourceNode _what_return_name
	)
	_converted = MediaElementAudioSourceNodeFromJS(_returned)
	_result = _converted
	return
}

// MediaElement returning attribute 'mediaElement' with
// type media.HTMLMediaElement (idl: HTMLMediaElement).
func (_this *MediaElementAudioSourceNode) MediaElement() *media.HTMLMediaElement {
	var ret *media.HTMLMediaElement
	value := _this.Value_JS.Get("mediaElement")
	ret = media.HTMLMediaElementFromJS(value)
	return ret
}

// interface: MediaStreamAudioDestinationNode
type MediaStreamAudioDestinationNode struct {
	AudioNode
}

// MediaStreamAudioDestinationNodeFromJS is casting a js.Wrapper into MediaStreamAudioDestinationNode.
func MediaStreamAudioDestinationNodeFromJS(value js.Wrapper) *MediaStreamAudioDestinationNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &MediaStreamAudioDestinationNode{}
	ret.Value_JS = input
	return ret
}

func NewMediaStreamAudioDestinationNode(context *AudioContext, options *AudioNodeOptions) (_result *MediaStreamAudioDestinationNode) {
	_klass := js.Global().Get("MediaStreamAudioDestinationNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *MediaStreamAudioDestinationNode // javascript: MediaStreamAudioDestinationNode _what_return_name
	)
	_converted = MediaStreamAudioDestinationNodeFromJS(_returned)
	_result = _converted
	return
}

// Stream returning attribute 'stream' with
// type local.MediaStream (idl: MediaStream).
func (_this *MediaStreamAudioDestinationNode) Stream() *local.MediaStream {
	var ret *local.MediaStream
	value := _this.Value_JS.Get("stream")
	ret = local.MediaStreamFromJS(value)
	return ret
}

// interface: MediaStreamAudioSourceNode
type MediaStreamAudioSourceNode struct {
	AudioNode
}

// MediaStreamAudioSourceNodeFromJS is casting a js.Wrapper into MediaStreamAudioSourceNode.
func MediaStreamAudioSourceNodeFromJS(value js.Wrapper) *MediaStreamAudioSourceNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &MediaStreamAudioSourceNode{}
	ret.Value_JS = input
	return ret
}

func NewMediaStreamAudioSourceNode(context *AudioContext, options *MediaStreamAudioSourceOptions) (_result *MediaStreamAudioSourceNode) {
	_klass := js.Global().Get("MediaStreamAudioSourceNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	_p1 := options.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *MediaStreamAudioSourceNode // javascript: MediaStreamAudioSourceNode _what_return_name
	)
	_converted = MediaStreamAudioSourceNodeFromJS(_returned)
	_result = _converted
	return
}

// MediaStream returning attribute 'mediaStream' with
// type local.MediaStream (idl: MediaStream).
func (_this *MediaStreamAudioSourceNode) MediaStream() *local.MediaStream {
	var ret *local.MediaStream
	value := _this.Value_JS.Get("mediaStream")
	ret = local.MediaStreamFromJS(value)
	return ret
}

// interface: MediaStreamTrackAudioSourceNode
type MediaStreamTrackAudioSourceNode struct {
	AudioNode
}

// MediaStreamTrackAudioSourceNodeFromJS is casting a js.Wrapper into MediaStreamTrackAudioSourceNode.
func MediaStreamTrackAudioSourceNodeFromJS(value js.Wrapper) *MediaStreamTrackAudioSourceNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &MediaStreamTrackAudioSourceNode{}
	ret.Value_JS = input
	return ret
}

func NewMediaStreamTrackAudioSourceNode(context *AudioContext, options *MediaStreamTrackAudioSourceOptions) (_result *MediaStreamTrackAudioSourceNode) {
	_klass := js.Global().Get("MediaStreamTrackAudioSourceNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	_p1 := options.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *MediaStreamTrackAudioSourceNode // javascript: MediaStreamTrackAudioSourceNode _what_return_name
	)
	_converted = MediaStreamTrackAudioSourceNodeFromJS(_returned)
	_result = _converted
	return
}

// interface: OfflineAudioCompletionEvent
type OfflineAudioCompletionEvent struct {
	domcore.Event
}

// OfflineAudioCompletionEventFromJS is casting a js.Wrapper into OfflineAudioCompletionEvent.
func OfflineAudioCompletionEventFromJS(value js.Wrapper) *OfflineAudioCompletionEvent {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &OfflineAudioCompletionEvent{}
	ret.Value_JS = input
	return ret
}

func NewOfflineAudioCompletionEvent(_type string, eventInitDict *OfflineAudioCompletionEventInit) (_result *OfflineAudioCompletionEvent) {
	_klass := js.Global().Get("OfflineAudioCompletionEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := eventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *OfflineAudioCompletionEvent // javascript: OfflineAudioCompletionEvent _what_return_name
	)
	_converted = OfflineAudioCompletionEventFromJS(_returned)
	_result = _converted
	return
}

// RenderedBuffer returning attribute 'renderedBuffer' with
// type AudioBuffer (idl: AudioBuffer).
func (_this *OfflineAudioCompletionEvent) RenderedBuffer() *AudioBuffer {
	var ret *AudioBuffer
	value := _this.Value_JS.Get("renderedBuffer")
	ret = AudioBufferFromJS(value)
	return ret
}

// interface: OfflineAudioContext
type OfflineAudioContext struct {
	BaseAudioContext
}

// OfflineAudioContextFromJS is casting a js.Wrapper into OfflineAudioContext.
func OfflineAudioContextFromJS(value js.Wrapper) *OfflineAudioContext {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &OfflineAudioContext{}
	ret.Value_JS = input
	return ret
}

func NewOfflineAudioContext(numberOfChannels uint, length uint, sampleRate float32) (_result *OfflineAudioContext) {
	_klass := js.Global().Get("OfflineAudioContext")
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := numberOfChannels
	_args[0] = _p0
	_end++
	_p1 := length
	_args[1] = _p1
	_end++
	_p2 := sampleRate
	_args[2] = _p2
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *OfflineAudioContext // javascript: OfflineAudioContext _what_return_name
	)
	_converted = OfflineAudioContextFromJS(_returned)
	_result = _converted
	return
}

// Length returning attribute 'length' with
// type uint (idl: unsigned long).
func (_this *OfflineAudioContext) Length() uint {
	var ret uint
	value := _this.Value_JS.Get("length")
	ret = (uint)((value).Int())
	return ret
}

// Oncomplete returning attribute 'oncomplete' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *OfflineAudioContext) Oncomplete() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("oncomplete")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOncomplete setting attribute 'oncomplete' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *OfflineAudioContext) SetOncomplete(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("oncomplete", input)
}

func (_this *OfflineAudioContext) StartRendering() (_result *javascript.Promise) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("startRendering", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *OfflineAudioContext) Resume() (_result *javascript.Promise) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("resume", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *OfflineAudioContext) Suspend(suspendTime float64) (_result *javascript.Promise) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := suspendTime
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("suspend", _args[0:_end]...)
	var (
		_converted *javascript.Promise // javascript: Promise _what_return_name
	)
	_converted = javascript.PromiseFromJS(_returned)
	_result = _converted
	return
}

// interface: OscillatorNode
type OscillatorNode struct {
	AudioScheduledSourceNode
}

// OscillatorNodeFromJS is casting a js.Wrapper into OscillatorNode.
func OscillatorNodeFromJS(value js.Wrapper) *OscillatorNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &OscillatorNode{}
	ret.Value_JS = input
	return ret
}

func NewOscillatorNode(context *BaseAudioContext, options *OscillatorOptions) (_result *OscillatorNode) {
	_klass := js.Global().Get("OscillatorNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *OscillatorNode // javascript: OscillatorNode _what_return_name
	)
	_converted = OscillatorNodeFromJS(_returned)
	_result = _converted
	return
}

// Type returning attribute 'type' with
// type OscillatorType (idl: OscillatorType).
func (_this *OscillatorNode) Type() OscillatorType {
	var ret OscillatorType
	value := _this.Value_JS.Get("type")
	ret = OscillatorTypeFromJS(value)
	return ret
}

// SetType setting attribute 'type' with
// type OscillatorType (idl: OscillatorType).
func (_this *OscillatorNode) SetType(value OscillatorType) {
	input := value.JSValue()
	_this.Value_JS.Set("type", input)
}

// Frequency returning attribute 'frequency' with
// type AudioParam (idl: AudioParam).
func (_this *OscillatorNode) Frequency() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("frequency")
	ret = AudioParamFromJS(value)
	return ret
}

// Detune returning attribute 'detune' with
// type AudioParam (idl: AudioParam).
func (_this *OscillatorNode) Detune() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("detune")
	ret = AudioParamFromJS(value)
	return ret
}

func (_this *OscillatorNode) SetPeriodicWave(periodicWave *PeriodicWave) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := periodicWave.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("setPeriodicWave", _args[0:_end]...)
	return
}

// interface: PannerNode
type PannerNode struct {
	AudioNode
}

// PannerNodeFromJS is casting a js.Wrapper into PannerNode.
func PannerNodeFromJS(value js.Wrapper) *PannerNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &PannerNode{}
	ret.Value_JS = input
	return ret
}

func NewPannerNode(context *BaseAudioContext, options *PannerOptions) (_result *PannerNode) {
	_klass := js.Global().Get("PannerNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *PannerNode // javascript: PannerNode _what_return_name
	)
	_converted = PannerNodeFromJS(_returned)
	_result = _converted
	return
}

// PanningModel returning attribute 'panningModel' with
// type PanningModelType (idl: PanningModelType).
func (_this *PannerNode) PanningModel() PanningModelType {
	var ret PanningModelType
	value := _this.Value_JS.Get("panningModel")
	ret = PanningModelTypeFromJS(value)
	return ret
}

// SetPanningModel setting attribute 'panningModel' with
// type PanningModelType (idl: PanningModelType).
func (_this *PannerNode) SetPanningModel(value PanningModelType) {
	input := value.JSValue()
	_this.Value_JS.Set("panningModel", input)
}

// PositionX returning attribute 'positionX' with
// type AudioParam (idl: AudioParam).
func (_this *PannerNode) PositionX() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("positionX")
	ret = AudioParamFromJS(value)
	return ret
}

// PositionY returning attribute 'positionY' with
// type AudioParam (idl: AudioParam).
func (_this *PannerNode) PositionY() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("positionY")
	ret = AudioParamFromJS(value)
	return ret
}

// PositionZ returning attribute 'positionZ' with
// type AudioParam (idl: AudioParam).
func (_this *PannerNode) PositionZ() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("positionZ")
	ret = AudioParamFromJS(value)
	return ret
}

// OrientationX returning attribute 'orientationX' with
// type AudioParam (idl: AudioParam).
func (_this *PannerNode) OrientationX() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("orientationX")
	ret = AudioParamFromJS(value)
	return ret
}

// OrientationY returning attribute 'orientationY' with
// type AudioParam (idl: AudioParam).
func (_this *PannerNode) OrientationY() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("orientationY")
	ret = AudioParamFromJS(value)
	return ret
}

// OrientationZ returning attribute 'orientationZ' with
// type AudioParam (idl: AudioParam).
func (_this *PannerNode) OrientationZ() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("orientationZ")
	ret = AudioParamFromJS(value)
	return ret
}

// DistanceModel returning attribute 'distanceModel' with
// type DistanceModelType (idl: DistanceModelType).
func (_this *PannerNode) DistanceModel() DistanceModelType {
	var ret DistanceModelType
	value := _this.Value_JS.Get("distanceModel")
	ret = DistanceModelTypeFromJS(value)
	return ret
}

// SetDistanceModel setting attribute 'distanceModel' with
// type DistanceModelType (idl: DistanceModelType).
func (_this *PannerNode) SetDistanceModel(value DistanceModelType) {
	input := value.JSValue()
	_this.Value_JS.Set("distanceModel", input)
}

// RefDistance returning attribute 'refDistance' with
// type float64 (idl: double).
func (_this *PannerNode) RefDistance() float64 {
	var ret float64
	value := _this.Value_JS.Get("refDistance")
	ret = (value).Float()
	return ret
}

// SetRefDistance setting attribute 'refDistance' with
// type float64 (idl: double).
func (_this *PannerNode) SetRefDistance(value float64) {
	input := value
	_this.Value_JS.Set("refDistance", input)
}

// MaxDistance returning attribute 'maxDistance' with
// type float64 (idl: double).
func (_this *PannerNode) MaxDistance() float64 {
	var ret float64
	value := _this.Value_JS.Get("maxDistance")
	ret = (value).Float()
	return ret
}

// SetMaxDistance setting attribute 'maxDistance' with
// type float64 (idl: double).
func (_this *PannerNode) SetMaxDistance(value float64) {
	input := value
	_this.Value_JS.Set("maxDistance", input)
}

// RolloffFactor returning attribute 'rolloffFactor' with
// type float64 (idl: double).
func (_this *PannerNode) RolloffFactor() float64 {
	var ret float64
	value := _this.Value_JS.Get("rolloffFactor")
	ret = (value).Float()
	return ret
}

// SetRolloffFactor setting attribute 'rolloffFactor' with
// type float64 (idl: double).
func (_this *PannerNode) SetRolloffFactor(value float64) {
	input := value
	_this.Value_JS.Set("rolloffFactor", input)
}

// ConeInnerAngle returning attribute 'coneInnerAngle' with
// type float64 (idl: double).
func (_this *PannerNode) ConeInnerAngle() float64 {
	var ret float64
	value := _this.Value_JS.Get("coneInnerAngle")
	ret = (value).Float()
	return ret
}

// SetConeInnerAngle setting attribute 'coneInnerAngle' with
// type float64 (idl: double).
func (_this *PannerNode) SetConeInnerAngle(value float64) {
	input := value
	_this.Value_JS.Set("coneInnerAngle", input)
}

// ConeOuterAngle returning attribute 'coneOuterAngle' with
// type float64 (idl: double).
func (_this *PannerNode) ConeOuterAngle() float64 {
	var ret float64
	value := _this.Value_JS.Get("coneOuterAngle")
	ret = (value).Float()
	return ret
}

// SetConeOuterAngle setting attribute 'coneOuterAngle' with
// type float64 (idl: double).
func (_this *PannerNode) SetConeOuterAngle(value float64) {
	input := value
	_this.Value_JS.Set("coneOuterAngle", input)
}

// ConeOuterGain returning attribute 'coneOuterGain' with
// type float64 (idl: double).
func (_this *PannerNode) ConeOuterGain() float64 {
	var ret float64
	value := _this.Value_JS.Get("coneOuterGain")
	ret = (value).Float()
	return ret
}

// SetConeOuterGain setting attribute 'coneOuterGain' with
// type float64 (idl: double).
func (_this *PannerNode) SetConeOuterGain(value float64) {
	input := value
	_this.Value_JS.Set("coneOuterGain", input)
}

func (_this *PannerNode) SetPosition(x float32, y float32, z float32) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := x
	_args[0] = _p0
	_end++
	_p1 := y
	_args[1] = _p1
	_end++
	_p2 := z
	_args[2] = _p2
	_end++
	_this.Value_JS.Call("setPosition", _args[0:_end]...)
	return
}

func (_this *PannerNode) SetOrientation(x float32, y float32, z float32) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := x
	_args[0] = _p0
	_end++
	_p1 := y
	_args[1] = _p1
	_end++
	_p2 := z
	_args[2] = _p2
	_end++
	_this.Value_JS.Call("setOrientation", _args[0:_end]...)
	return
}

// interface: PeriodicWave
type PeriodicWave struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PeriodicWave) JSValue() js.Value {
	return _this.Value_JS
}

// PeriodicWaveFromJS is casting a js.Wrapper into PeriodicWave.
func PeriodicWaveFromJS(value js.Wrapper) *PeriodicWave {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &PeriodicWave{}
	ret.Value_JS = input
	return ret
}

func NewPeriodicWave(context *BaseAudioContext, options *PeriodicWaveOptions) (_result *PeriodicWave) {
	_klass := js.Global().Get("PeriodicWave")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *PeriodicWave // javascript: PeriodicWave _what_return_name
	)
	_converted = PeriodicWaveFromJS(_returned)
	_result = _converted
	return
}

// interface: ScriptProcessorNode
type ScriptProcessorNode struct {
	AudioNode
}

// ScriptProcessorNodeFromJS is casting a js.Wrapper into ScriptProcessorNode.
func ScriptProcessorNodeFromJS(value js.Wrapper) *ScriptProcessorNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &ScriptProcessorNode{}
	ret.Value_JS = input
	return ret
}

// Onaudioprocess returning attribute 'onaudioprocess' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ScriptProcessorNode) Onaudioprocess() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onaudioprocess")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnaudioprocess setting attribute 'onaudioprocess' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *ScriptProcessorNode) SetOnaudioprocess(value *domcore.EventHandler) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onaudioprocess", input)
}

// BufferSize returning attribute 'bufferSize' with
// type int (idl: long).
func (_this *ScriptProcessorNode) BufferSize() int {
	var ret int
	value := _this.Value_JS.Get("bufferSize")
	ret = (value).Int()
	return ret
}

// interface: StereoPannerNode
type StereoPannerNode struct {
	AudioNode
}

// StereoPannerNodeFromJS is casting a js.Wrapper into StereoPannerNode.
func StereoPannerNodeFromJS(value js.Wrapper) *StereoPannerNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &StereoPannerNode{}
	ret.Value_JS = input
	return ret
}

func NewStereoPannerNode(context *BaseAudioContext, options *StereoPannerOptions) (_result *StereoPannerNode) {
	_klass := js.Global().Get("StereoPannerNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *StereoPannerNode // javascript: StereoPannerNode _what_return_name
	)
	_converted = StereoPannerNodeFromJS(_returned)
	_result = _converted
	return
}

// Pan returning attribute 'pan' with
// type AudioParam (idl: AudioParam).
func (_this *StereoPannerNode) Pan() *AudioParam {
	var ret *AudioParam
	value := _this.Value_JS.Get("pan")
	ret = AudioParamFromJS(value)
	return ret
}

// interface: WaveShaperNode
type WaveShaperNode struct {
	AudioNode
}

// WaveShaperNodeFromJS is casting a js.Wrapper into WaveShaperNode.
func WaveShaperNodeFromJS(value js.Wrapper) *WaveShaperNode {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &WaveShaperNode{}
	ret.Value_JS = input
	return ret
}

func NewWaveShaperNode(context *BaseAudioContext, options *WaveShaperOptions) (_result *WaveShaperNode) {
	_klass := js.Global().Get("WaveShaperNode")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := context.JSValue()
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *WaveShaperNode // javascript: WaveShaperNode _what_return_name
	)
	_converted = WaveShaperNodeFromJS(_returned)
	_result = _converted
	return
}

// Curve returning attribute 'curve' with
// type javascript.Float32Array (idl: Float32Array).
func (_this *WaveShaperNode) Curve() *javascript.Float32Array {
	var ret *javascript.Float32Array
	value := _this.Value_JS.Get("curve")
	if value.Type() != js.TypeNull {
		ret = javascript.Float32ArrayFromJS(value)
	}
	return ret
}

// SetCurve setting attribute 'curve' with
// type javascript.Float32Array (idl: Float32Array).
func (_this *WaveShaperNode) SetCurve(value *javascript.Float32Array) {
	input := value.JSValue()
	_this.Value_JS.Set("curve", input)
}

// Oversample returning attribute 'oversample' with
// type OverSampleType (idl: OverSampleType).
func (_this *WaveShaperNode) Oversample() OverSampleType {
	var ret OverSampleType
	value := _this.Value_JS.Get("oversample")
	ret = OverSampleTypeFromJS(value)
	return ret
}

// SetOversample setting attribute 'oversample' with
// type OverSampleType (idl: OverSampleType).
func (_this *WaveShaperNode) SetOversample(value OverSampleType) {
	input := value.JSValue()
	_this.Value_JS.Set("oversample", input)
}
