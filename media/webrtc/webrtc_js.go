// Code generated by webidl-bind. DO NOT EDIT.

package webrtc

import "syscall/js"

import (
	"github.com/gowebapi/webapi/dom/domcore"
	"github.com/gowebapi/webapi/file"
	"github.com/gowebapi/webapi/html/channel"
	"github.com/gowebapi/webapi/javascript"
	"github.com/gowebapi/webapi/media/capture/local"
	"github.com/gowebapi/webapi/webidl"
)

// using following types:
// channel.MessageEvent
// domcore.DOMException
// domcore.Event
// domcore.EventHandler
// domcore.EventTarget
// file.Blob
// javascript.ArrayBuffer
// javascript.FrozenArray
// javascript.Object
// javascript.PromiseFinally
// javascript.PromiseVoid
// local.MediaStream
// local.MediaStreamTrack
// webidl.VoidFunction

// source idl files:
// missingtypes.idl
// promises.idl
// webrtc-stats.idl
// webrtc.idl

// transform files:
// missingtypes.go.md
// promises.go.md
// webrtc-stats.go.md
// webrtc.go.md

// workaround for compiler error
func unused(value interface{}) {
	// TODO remove this method
}

type Union struct {
	Value js.Value
}

func (u *Union) JSValue() js.Value {
	return u.Value
}

func UnionFromJS(value js.Value) *Union {
	return &Union{Value: value}
}

// enum: RTCBundlePolicy
type BundlePolicy int

const (
	BalancedRTCBundlePolicy BundlePolicy = iota
	MaxCompatRTCBundlePolicy
	MaxBundleRTCBundlePolicy
)

var rTCBundlePolicyToWasmTable = []string{
	"balanced", "max-compat", "max-bundle",
}

var rTCBundlePolicyFromWasmTable = map[string]BundlePolicy{
	"balanced": BalancedRTCBundlePolicy, "max-compat": MaxCompatRTCBundlePolicy, "max-bundle": MaxBundleRTCBundlePolicy,
}

// JSValue is converting this enum into a javascript object
func (this *BundlePolicy) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this BundlePolicy) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCBundlePolicyToWasmTable) {
		return rTCBundlePolicyToWasmTable[idx]
	}
	panic("unknown input value")
}

// BundlePolicyFromJS is converting a javascript value into
// a BundlePolicy enum value.
func BundlePolicyFromJS(value js.Value) BundlePolicy {
	key := value.String()
	conv, ok := rTCBundlePolicyFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCDataChannelState
type DataChannelState int

const (
	ConnectingRTCDataChannelState DataChannelState = iota
	OpenRTCDataChannelState
	ClosingRTCDataChannelState
	ClosedRTCDataChannelState
)

var rTCDataChannelStateToWasmTable = []string{
	"connecting", "open", "closing", "closed",
}

var rTCDataChannelStateFromWasmTable = map[string]DataChannelState{
	"connecting": ConnectingRTCDataChannelState, "open": OpenRTCDataChannelState, "closing": ClosingRTCDataChannelState, "closed": ClosedRTCDataChannelState,
}

// JSValue is converting this enum into a javascript object
func (this *DataChannelState) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this DataChannelState) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCDataChannelStateToWasmTable) {
		return rTCDataChannelStateToWasmTable[idx]
	}
	panic("unknown input value")
}

// DataChannelStateFromJS is converting a javascript value into
// a DataChannelState enum value.
func DataChannelStateFromJS(value js.Value) DataChannelState {
	key := value.String()
	conv, ok := rTCDataChannelStateFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCDegradationPreference
type DegradationPreference int

const (
	MaintainFramerateRTCDegradationPreference DegradationPreference = iota
	MaintainResolutionRTCDegradationPreference
	BalancedRTCDegradationPreference
)

var rTCDegradationPreferenceToWasmTable = []string{
	"maintain-framerate", "maintain-resolution", "balanced",
}

var rTCDegradationPreferenceFromWasmTable = map[string]DegradationPreference{
	"maintain-framerate": MaintainFramerateRTCDegradationPreference, "maintain-resolution": MaintainResolutionRTCDegradationPreference, "balanced": BalancedRTCDegradationPreference,
}

// JSValue is converting this enum into a javascript object
func (this *DegradationPreference) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this DegradationPreference) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCDegradationPreferenceToWasmTable) {
		return rTCDegradationPreferenceToWasmTable[idx]
	}
	panic("unknown input value")
}

// DegradationPreferenceFromJS is converting a javascript value into
// a DegradationPreference enum value.
func DegradationPreferenceFromJS(value js.Value) DegradationPreference {
	key := value.String()
	conv, ok := rTCDegradationPreferenceFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCDtlsTransportState
type DtlsTransportState int

const (
	NewRTCDtlsTransportState DtlsTransportState = iota
	ConnectingRTCDtlsTransportState
	ConnectedRTCDtlsTransportState
	ClosedRTCDtlsTransportState
	FailedRTCDtlsTransportState
)

var rTCDtlsTransportStateToWasmTable = []string{
	"new", "connecting", "connected", "closed", "failed",
}

var rTCDtlsTransportStateFromWasmTable = map[string]DtlsTransportState{
	"new": NewRTCDtlsTransportState, "connecting": ConnectingRTCDtlsTransportState, "connected": ConnectedRTCDtlsTransportState, "closed": ClosedRTCDtlsTransportState, "failed": FailedRTCDtlsTransportState,
}

// JSValue is converting this enum into a javascript object
func (this *DtlsTransportState) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this DtlsTransportState) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCDtlsTransportStateToWasmTable) {
		return rTCDtlsTransportStateToWasmTable[idx]
	}
	panic("unknown input value")
}

// DtlsTransportStateFromJS is converting a javascript value into
// a DtlsTransportState enum value.
func DtlsTransportStateFromJS(value js.Value) DtlsTransportState {
	key := value.String()
	conv, ok := rTCDtlsTransportStateFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCDtxStatus
type DtxStatus int

const (
	DisabledRTCDtxStatus DtxStatus = iota
	EnabledRTCDtxStatus
)

var rTCDtxStatusToWasmTable = []string{
	"disabled", "enabled",
}

var rTCDtxStatusFromWasmTable = map[string]DtxStatus{
	"disabled": DisabledRTCDtxStatus, "enabled": EnabledRTCDtxStatus,
}

// JSValue is converting this enum into a javascript object
func (this *DtxStatus) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this DtxStatus) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCDtxStatusToWasmTable) {
		return rTCDtxStatusToWasmTable[idx]
	}
	panic("unknown input value")
}

// DtxStatusFromJS is converting a javascript value into
// a DtxStatus enum value.
func DtxStatusFromJS(value js.Value) DtxStatus {
	key := value.String()
	conv, ok := rTCDtxStatusFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCIceCandidateType
type IceCandidateType int

const (
	HostRTCIceCandidateType IceCandidateType = iota
	SrflxRTCIceCandidateType
	PrflxRTCIceCandidateType
	RelayRTCIceCandidateType
)

var rTCIceCandidateTypeToWasmTable = []string{
	"host", "srflx", "prflx", "relay",
}

var rTCIceCandidateTypeFromWasmTable = map[string]IceCandidateType{
	"host": HostRTCIceCandidateType, "srflx": SrflxRTCIceCandidateType, "prflx": PrflxRTCIceCandidateType, "relay": RelayRTCIceCandidateType,
}

// JSValue is converting this enum into a javascript object
func (this *IceCandidateType) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this IceCandidateType) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCIceCandidateTypeToWasmTable) {
		return rTCIceCandidateTypeToWasmTable[idx]
	}
	panic("unknown input value")
}

// IceCandidateTypeFromJS is converting a javascript value into
// a IceCandidateType enum value.
func IceCandidateTypeFromJS(value js.Value) IceCandidateType {
	key := value.String()
	conv, ok := rTCIceCandidateTypeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCIceComponent
type IceComponent int

const (
	RtpRTCIceComponent IceComponent = iota
	RtcpRTCIceComponent
)

var rTCIceComponentToWasmTable = []string{
	"rtp", "rtcp",
}

var rTCIceComponentFromWasmTable = map[string]IceComponent{
	"rtp": RtpRTCIceComponent, "rtcp": RtcpRTCIceComponent,
}

// JSValue is converting this enum into a javascript object
func (this *IceComponent) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this IceComponent) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCIceComponentToWasmTable) {
		return rTCIceComponentToWasmTable[idx]
	}
	panic("unknown input value")
}

// IceComponentFromJS is converting a javascript value into
// a IceComponent enum value.
func IceComponentFromJS(value js.Value) IceComponent {
	key := value.String()
	conv, ok := rTCIceComponentFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCIceConnectionState
type IceConnectionState int

const (
	ClosedRTCIceConnectionState IceConnectionState = iota
	FailedRTCIceConnectionState
	DisconnectedRTCIceConnectionState
	NewRTCIceConnectionState
	CheckingRTCIceConnectionState
	CompletedRTCIceConnectionState
	ConnectedRTCIceConnectionState
)

var rTCIceConnectionStateToWasmTable = []string{
	"closed", "failed", "disconnected", "new", "checking", "completed", "connected",
}

var rTCIceConnectionStateFromWasmTable = map[string]IceConnectionState{
	"closed": ClosedRTCIceConnectionState, "failed": FailedRTCIceConnectionState, "disconnected": DisconnectedRTCIceConnectionState, "new": NewRTCIceConnectionState, "checking": CheckingRTCIceConnectionState, "completed": CompletedRTCIceConnectionState, "connected": ConnectedRTCIceConnectionState,
}

// JSValue is converting this enum into a javascript object
func (this *IceConnectionState) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this IceConnectionState) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCIceConnectionStateToWasmTable) {
		return rTCIceConnectionStateToWasmTable[idx]
	}
	panic("unknown input value")
}

// IceConnectionStateFromJS is converting a javascript value into
// a IceConnectionState enum value.
func IceConnectionStateFromJS(value js.Value) IceConnectionState {
	key := value.String()
	conv, ok := rTCIceConnectionStateFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCIceCredentialType
type IceCredentialType int

const (
	PasswordRTCIceCredentialType IceCredentialType = iota
	OauthRTCIceCredentialType
)

var rTCIceCredentialTypeToWasmTable = []string{
	"password", "oauth",
}

var rTCIceCredentialTypeFromWasmTable = map[string]IceCredentialType{
	"password": PasswordRTCIceCredentialType, "oauth": OauthRTCIceCredentialType,
}

// JSValue is converting this enum into a javascript object
func (this *IceCredentialType) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this IceCredentialType) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCIceCredentialTypeToWasmTable) {
		return rTCIceCredentialTypeToWasmTable[idx]
	}
	panic("unknown input value")
}

// IceCredentialTypeFromJS is converting a javascript value into
// a IceCredentialType enum value.
func IceCredentialTypeFromJS(value js.Value) IceCredentialType {
	key := value.String()
	conv, ok := rTCIceCredentialTypeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCIceGathererState
type IceGathererState int

const (
	NewRTCIceGathererState IceGathererState = iota
	GatheringRTCIceGathererState
	CompleteRTCIceGathererState
)

var rTCIceGathererStateToWasmTable = []string{
	"new", "gathering", "complete",
}

var rTCIceGathererStateFromWasmTable = map[string]IceGathererState{
	"new": NewRTCIceGathererState, "gathering": GatheringRTCIceGathererState, "complete": CompleteRTCIceGathererState,
}

// JSValue is converting this enum into a javascript object
func (this *IceGathererState) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this IceGathererState) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCIceGathererStateToWasmTable) {
		return rTCIceGathererStateToWasmTable[idx]
	}
	panic("unknown input value")
}

// IceGathererStateFromJS is converting a javascript value into
// a IceGathererState enum value.
func IceGathererStateFromJS(value js.Value) IceGathererState {
	key := value.String()
	conv, ok := rTCIceGathererStateFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCIceGatheringState
type IceGatheringState int

const (
	NewRTCIceGatheringState IceGatheringState = iota
	GatheringRTCIceGatheringState
	CompleteRTCIceGatheringState
)

var rTCIceGatheringStateToWasmTable = []string{
	"new", "gathering", "complete",
}

var rTCIceGatheringStateFromWasmTable = map[string]IceGatheringState{
	"new": NewRTCIceGatheringState, "gathering": GatheringRTCIceGatheringState, "complete": CompleteRTCIceGatheringState,
}

// JSValue is converting this enum into a javascript object
func (this *IceGatheringState) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this IceGatheringState) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCIceGatheringStateToWasmTable) {
		return rTCIceGatheringStateToWasmTable[idx]
	}
	panic("unknown input value")
}

// IceGatheringStateFromJS is converting a javascript value into
// a IceGatheringState enum value.
func IceGatheringStateFromJS(value js.Value) IceGatheringState {
	key := value.String()
	conv, ok := rTCIceGatheringStateFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCIceProtocol
type IceProtocol int

const (
	UdpRTCIceProtocol IceProtocol = iota
	TcpRTCIceProtocol
)

var rTCIceProtocolToWasmTable = []string{
	"udp", "tcp",
}

var rTCIceProtocolFromWasmTable = map[string]IceProtocol{
	"udp": UdpRTCIceProtocol, "tcp": TcpRTCIceProtocol,
}

// JSValue is converting this enum into a javascript object
func (this *IceProtocol) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this IceProtocol) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCIceProtocolToWasmTable) {
		return rTCIceProtocolToWasmTable[idx]
	}
	panic("unknown input value")
}

// IceProtocolFromJS is converting a javascript value into
// a IceProtocol enum value.
func IceProtocolFromJS(value js.Value) IceProtocol {
	key := value.String()
	conv, ok := rTCIceProtocolFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCIceRole
type IceRole int

const (
	ControllingRTCIceRole IceRole = iota
	ControlledRTCIceRole
)

var rTCIceRoleToWasmTable = []string{
	"controlling", "controlled",
}

var rTCIceRoleFromWasmTable = map[string]IceRole{
	"controlling": ControllingRTCIceRole, "controlled": ControlledRTCIceRole,
}

// JSValue is converting this enum into a javascript object
func (this *IceRole) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this IceRole) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCIceRoleToWasmTable) {
		return rTCIceRoleToWasmTable[idx]
	}
	panic("unknown input value")
}

// IceRoleFromJS is converting a javascript value into
// a IceRole enum value.
func IceRoleFromJS(value js.Value) IceRole {
	key := value.String()
	conv, ok := rTCIceRoleFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCIceTcpCandidateType
type IceTcpCandidateType int

const (
	ActiveRTCIceTcpCandidateType IceTcpCandidateType = iota
	PassiveRTCIceTcpCandidateType
	SoRTCIceTcpCandidateType
)

var rTCIceTcpCandidateTypeToWasmTable = []string{
	"active", "passive", "so",
}

var rTCIceTcpCandidateTypeFromWasmTable = map[string]IceTcpCandidateType{
	"active": ActiveRTCIceTcpCandidateType, "passive": PassiveRTCIceTcpCandidateType, "so": SoRTCIceTcpCandidateType,
}

// JSValue is converting this enum into a javascript object
func (this *IceTcpCandidateType) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this IceTcpCandidateType) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCIceTcpCandidateTypeToWasmTable) {
		return rTCIceTcpCandidateTypeToWasmTable[idx]
	}
	panic("unknown input value")
}

// IceTcpCandidateTypeFromJS is converting a javascript value into
// a IceTcpCandidateType enum value.
func IceTcpCandidateTypeFromJS(value js.Value) IceTcpCandidateType {
	key := value.String()
	conv, ok := rTCIceTcpCandidateTypeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCIceTransportPolicy
type IceTransportPolicy int

const (
	RelayRTCIceTransportPolicy IceTransportPolicy = iota
	AllRTCIceTransportPolicy
)

var rTCIceTransportPolicyToWasmTable = []string{
	"relay", "all",
}

var rTCIceTransportPolicyFromWasmTable = map[string]IceTransportPolicy{
	"relay": RelayRTCIceTransportPolicy, "all": AllRTCIceTransportPolicy,
}

// JSValue is converting this enum into a javascript object
func (this *IceTransportPolicy) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this IceTransportPolicy) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCIceTransportPolicyToWasmTable) {
		return rTCIceTransportPolicyToWasmTable[idx]
	}
	panic("unknown input value")
}

// IceTransportPolicyFromJS is converting a javascript value into
// a IceTransportPolicy enum value.
func IceTransportPolicyFromJS(value js.Value) IceTransportPolicy {
	key := value.String()
	conv, ok := rTCIceTransportPolicyFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCIceTransportState
type IceTransportState int

const (
	NewRTCIceTransportState IceTransportState = iota
	CheckingRTCIceTransportState
	ConnectedRTCIceTransportState
	CompletedRTCIceTransportState
	DisconnectedRTCIceTransportState
	FailedRTCIceTransportState
	ClosedRTCIceTransportState
)

var rTCIceTransportStateToWasmTable = []string{
	"new", "checking", "connected", "completed", "disconnected", "failed", "closed",
}

var rTCIceTransportStateFromWasmTable = map[string]IceTransportState{
	"new": NewRTCIceTransportState, "checking": CheckingRTCIceTransportState, "connected": ConnectedRTCIceTransportState, "completed": CompletedRTCIceTransportState, "disconnected": DisconnectedRTCIceTransportState, "failed": FailedRTCIceTransportState, "closed": ClosedRTCIceTransportState,
}

// JSValue is converting this enum into a javascript object
func (this *IceTransportState) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this IceTransportState) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCIceTransportStateToWasmTable) {
		return rTCIceTransportStateToWasmTable[idx]
	}
	panic("unknown input value")
}

// IceTransportStateFromJS is converting a javascript value into
// a IceTransportState enum value.
func IceTransportStateFromJS(value js.Value) IceTransportState {
	key := value.String()
	conv, ok := rTCIceTransportStateFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCPeerConnectionState
type PeerConnectionState int

const (
	ClosedRTCPeerConnectionState PeerConnectionState = iota
	FailedRTCPeerConnectionState
	DisconnectedRTCPeerConnectionState
	NewRTCPeerConnectionState
	ConnectingRTCPeerConnectionState
	ConnectedRTCPeerConnectionState
)

var rTCPeerConnectionStateToWasmTable = []string{
	"closed", "failed", "disconnected", "new", "connecting", "connected",
}

var rTCPeerConnectionStateFromWasmTable = map[string]PeerConnectionState{
	"closed": ClosedRTCPeerConnectionState, "failed": FailedRTCPeerConnectionState, "disconnected": DisconnectedRTCPeerConnectionState, "new": NewRTCPeerConnectionState, "connecting": ConnectingRTCPeerConnectionState, "connected": ConnectedRTCPeerConnectionState,
}

// JSValue is converting this enum into a javascript object
func (this *PeerConnectionState) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this PeerConnectionState) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCPeerConnectionStateToWasmTable) {
		return rTCPeerConnectionStateToWasmTable[idx]
	}
	panic("unknown input value")
}

// PeerConnectionStateFromJS is converting a javascript value into
// a PeerConnectionState enum value.
func PeerConnectionStateFromJS(value js.Value) PeerConnectionState {
	key := value.String()
	conv, ok := rTCPeerConnectionStateFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCPriorityType
type PriorityType int

const (
	VeryLowRTCPriorityType PriorityType = iota
	LowRTCPriorityType
	MediumRTCPriorityType
	HighRTCPriorityType
)

var rTCPriorityTypeToWasmTable = []string{
	"very-low", "low", "medium", "high",
}

var rTCPriorityTypeFromWasmTable = map[string]PriorityType{
	"very-low": VeryLowRTCPriorityType, "low": LowRTCPriorityType, "medium": MediumRTCPriorityType, "high": HighRTCPriorityType,
}

// JSValue is converting this enum into a javascript object
func (this *PriorityType) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this PriorityType) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCPriorityTypeToWasmTable) {
		return rTCPriorityTypeToWasmTable[idx]
	}
	panic("unknown input value")
}

// PriorityTypeFromJS is converting a javascript value into
// a PriorityType enum value.
func PriorityTypeFromJS(value js.Value) PriorityType {
	key := value.String()
	conv, ok := rTCPriorityTypeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCRtcpMuxPolicy
type RtcpMuxPolicy int

const (
	NegotiateRTCRtcpMuxPolicy RtcpMuxPolicy = iota
	RequireRTCRtcpMuxPolicy
)

var rTCRtcpMuxPolicyToWasmTable = []string{
	"negotiate", "require",
}

var rTCRtcpMuxPolicyFromWasmTable = map[string]RtcpMuxPolicy{
	"negotiate": NegotiateRTCRtcpMuxPolicy, "require": RequireRTCRtcpMuxPolicy,
}

// JSValue is converting this enum into a javascript object
func (this *RtcpMuxPolicy) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this RtcpMuxPolicy) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCRtcpMuxPolicyToWasmTable) {
		return rTCRtcpMuxPolicyToWasmTable[idx]
	}
	panic("unknown input value")
}

// RtcpMuxPolicyFromJS is converting a javascript value into
// a RtcpMuxPolicy enum value.
func RtcpMuxPolicyFromJS(value js.Value) RtcpMuxPolicy {
	key := value.String()
	conv, ok := rTCRtcpMuxPolicyFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCRtpTransceiverDirection
type RtpTransceiverDirection int

const (
	SendrecvRTCRtpTransceiverDirection RtpTransceiverDirection = iota
	SendonlyRTCRtpTransceiverDirection
	RecvonlyRTCRtpTransceiverDirection
	InactiveRTCRtpTransceiverDirection
)

var rTCRtpTransceiverDirectionToWasmTable = []string{
	"sendrecv", "sendonly", "recvonly", "inactive",
}

var rTCRtpTransceiverDirectionFromWasmTable = map[string]RtpTransceiverDirection{
	"sendrecv": SendrecvRTCRtpTransceiverDirection, "sendonly": SendonlyRTCRtpTransceiverDirection, "recvonly": RecvonlyRTCRtpTransceiverDirection, "inactive": InactiveRTCRtpTransceiverDirection,
}

// JSValue is converting this enum into a javascript object
func (this *RtpTransceiverDirection) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this RtpTransceiverDirection) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCRtpTransceiverDirectionToWasmTable) {
		return rTCRtpTransceiverDirectionToWasmTable[idx]
	}
	panic("unknown input value")
}

// RtpTransceiverDirectionFromJS is converting a javascript value into
// a RtpTransceiverDirection enum value.
func RtpTransceiverDirectionFromJS(value js.Value) RtpTransceiverDirection {
	key := value.String()
	conv, ok := rTCRtpTransceiverDirectionFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCSctpTransportState
type SctpTransportState int

const (
	ConnectingRTCSctpTransportState SctpTransportState = iota
	ConnectedRTCSctpTransportState
	ClosedRTCSctpTransportState
)

var rTCSctpTransportStateToWasmTable = []string{
	"connecting", "connected", "closed",
}

var rTCSctpTransportStateFromWasmTable = map[string]SctpTransportState{
	"connecting": ConnectingRTCSctpTransportState, "connected": ConnectedRTCSctpTransportState, "closed": ClosedRTCSctpTransportState,
}

// JSValue is converting this enum into a javascript object
func (this *SctpTransportState) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this SctpTransportState) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCSctpTransportStateToWasmTable) {
		return rTCSctpTransportStateToWasmTable[idx]
	}
	panic("unknown input value")
}

// SctpTransportStateFromJS is converting a javascript value into
// a SctpTransportState enum value.
func SctpTransportStateFromJS(value js.Value) SctpTransportState {
	key := value.String()
	conv, ok := rTCSctpTransportStateFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCSdpType
type SdpType int

const (
	OfferRTCSdpType SdpType = iota
	PranswerRTCSdpType
	AnswerRTCSdpType
	RollbackRTCSdpType
)

var rTCSdpTypeToWasmTable = []string{
	"offer", "pranswer", "answer", "rollback",
}

var rTCSdpTypeFromWasmTable = map[string]SdpType{
	"offer": OfferRTCSdpType, "pranswer": PranswerRTCSdpType, "answer": AnswerRTCSdpType, "rollback": RollbackRTCSdpType,
}

// JSValue is converting this enum into a javascript object
func (this *SdpType) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this SdpType) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCSdpTypeToWasmTable) {
		return rTCSdpTypeToWasmTable[idx]
	}
	panic("unknown input value")
}

// SdpTypeFromJS is converting a javascript value into
// a SdpType enum value.
func SdpTypeFromJS(value js.Value) SdpType {
	key := value.String()
	conv, ok := rTCSdpTypeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCSignalingState
type SignalingState int

const (
	StableRTCSignalingState SignalingState = iota
	HaveLocalOfferRTCSignalingState
	HaveRemoteOfferRTCSignalingState
	HaveLocalPranswerRTCSignalingState
	HaveRemotePranswerRTCSignalingState
	ClosedRTCSignalingState
)

var rTCSignalingStateToWasmTable = []string{
	"stable", "have-local-offer", "have-remote-offer", "have-local-pranswer", "have-remote-pranswer", "closed",
}

var rTCSignalingStateFromWasmTable = map[string]SignalingState{
	"stable": StableRTCSignalingState, "have-local-offer": HaveLocalOfferRTCSignalingState, "have-remote-offer": HaveRemoteOfferRTCSignalingState, "have-local-pranswer": HaveLocalPranswerRTCSignalingState, "have-remote-pranswer": HaveRemotePranswerRTCSignalingState, "closed": ClosedRTCSignalingState,
}

// JSValue is converting this enum into a javascript object
func (this *SignalingState) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this SignalingState) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCSignalingStateToWasmTable) {
		return rTCSignalingStateToWasmTable[idx]
	}
	panic("unknown input value")
}

// SignalingStateFromJS is converting a javascript value into
// a SignalingState enum value.
func SignalingStateFromJS(value js.Value) SignalingState {
	key := value.String()
	conv, ok := rTCSignalingStateFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: RTCStatsType
type StatsType int

const (
	CodecRTCStatsType StatsType = iota
	InboundRtpRTCStatsType
	OutboundRtpRTCStatsType
	RemoteInboundRtpRTCStatsType
	RemoteOutboundRtpRTCStatsType
	CsrcRTCStatsType
	PeerConnectionRTCStatsType
	DataChannelRTCStatsType
	StreamRTCStatsType
	TrackRTCStatsType
	SenderRTCStatsType
	ReceiverRTCStatsType
	TransportRTCStatsType
	CandidatePairRTCStatsType
	LocalCandidateRTCStatsType
	RemoteCandidateRTCStatsType
	CertificateRTCStatsType
)

var rTCStatsTypeToWasmTable = []string{
	"codec", "inbound-rtp", "outbound-rtp", "remote-inbound-rtp", "remote-outbound-rtp", "csrc", "peer-connection", "data-channel", "stream", "track", "sender", "receiver", "transport", "candidate-pair", "local-candidate", "remote-candidate", "certificate",
}

var rTCStatsTypeFromWasmTable = map[string]StatsType{
	"codec": CodecRTCStatsType, "inbound-rtp": InboundRtpRTCStatsType, "outbound-rtp": OutboundRtpRTCStatsType, "remote-inbound-rtp": RemoteInboundRtpRTCStatsType, "remote-outbound-rtp": RemoteOutboundRtpRTCStatsType, "csrc": CsrcRTCStatsType, "peer-connection": PeerConnectionRTCStatsType, "data-channel": DataChannelRTCStatsType, "stream": StreamRTCStatsType, "track": TrackRTCStatsType, "sender": SenderRTCStatsType, "receiver": ReceiverRTCStatsType, "transport": TransportRTCStatsType, "candidate-pair": CandidatePairRTCStatsType, "local-candidate": LocalCandidateRTCStatsType, "remote-candidate": RemoteCandidateRTCStatsType, "certificate": CertificateRTCStatsType,
}

// JSValue is converting this enum into a javascript object
func (this *StatsType) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this StatsType) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(rTCStatsTypeToWasmTable) {
		return rTCStatsTypeToWasmTable[idx]
	}
	panic("unknown input value")
}

// StatsTypeFromJS is converting a javascript value into
// a StatsType enum value.
func StatsTypeFromJS(value js.Value) StatsType {
	key := value.String()
	conv, ok := rTCStatsTypeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// callback: RTCPeerConnectionErrorCallback
type PeerConnectionErrorCallbackFunc func(_error *domcore.DOMException)

// PeerConnectionErrorCallback is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PeerConnectionErrorCallback js.Func

func PeerConnectionErrorCallbackToJS(callback PeerConnectionErrorCallbackFunc) *PeerConnectionErrorCallback {
	if callback == nil {
		return nil
	}
	ret := PeerConnectionErrorCallback(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *domcore.DOMException // javascript: DOMException _error
		)
		_p0 = domcore.DOMExceptionFromJS(args[0])
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PeerConnectionErrorCallbackFromJS(_value js.Value) PeerConnectionErrorCallbackFunc {
	return func(_error *domcore.DOMException) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := _error.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromiseCertificateOnFulfilledFunc func(value *Certificate)

// PromiseCertificateOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseCertificateOnFulfilled js.Func

func PromiseCertificateOnFulfilledToJS(callback PromiseCertificateOnFulfilledFunc) *PromiseCertificateOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseCertificateOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *Certificate // javascript: RTCCertificate value
		)
		_p0 = CertificateFromJS(args[0])
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseCertificateOnFulfilledFromJS(_value js.Value) PromiseCertificateOnFulfilledFunc {
	return func(value *Certificate) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseCertificateOnRejectedFunc func(reason js.Value)

// PromiseCertificateOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseCertificateOnRejected js.Func

func PromiseCertificateOnRejectedToJS(callback PromiseCertificateOnRejectedFunc) *PromiseCertificateOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseCertificateOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseCertificateOnRejectedFromJS(_value js.Value) PromiseCertificateOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromiseSessionDescriptionInitOnFulfilledFunc func(value *SessionDescriptionInit)

// PromiseSessionDescriptionInitOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseSessionDescriptionInitOnFulfilled js.Func

func PromiseSessionDescriptionInitOnFulfilledToJS(callback PromiseSessionDescriptionInitOnFulfilledFunc) *PromiseSessionDescriptionInitOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseSessionDescriptionInitOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *SessionDescriptionInit // javascript: RTCSessionDescriptionInit value
		)
		_p0 = SessionDescriptionInitFromJS(args[0])
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseSessionDescriptionInitOnFulfilledFromJS(_value js.Value) PromiseSessionDescriptionInitOnFulfilledFunc {
	return func(value *SessionDescriptionInit) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseSessionDescriptionInitOnRejectedFunc func(reason js.Value)

// PromiseSessionDescriptionInitOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseSessionDescriptionInitOnRejected js.Func

func PromiseSessionDescriptionInitOnRejectedToJS(callback PromiseSessionDescriptionInitOnRejectedFunc) *PromiseSessionDescriptionInitOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseSessionDescriptionInitOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseSessionDescriptionInitOnRejectedFromJS(_value js.Value) PromiseSessionDescriptionInitOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromiseStatsReportOnFulfilledFunc func(value *StatsReport)

// PromiseStatsReportOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseStatsReportOnFulfilled js.Func

func PromiseStatsReportOnFulfilledToJS(callback PromiseStatsReportOnFulfilledFunc) *PromiseStatsReportOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseStatsReportOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *StatsReport // javascript: RTCStatsReport value
		)
		_p0 = StatsReportFromJS(args[0])
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseStatsReportOnFulfilledFromJS(_value js.Value) PromiseStatsReportOnFulfilledFunc {
	return func(value *StatsReport) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseStatsReportOnRejectedFunc func(reason js.Value)

// PromiseStatsReportOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseStatsReportOnRejected js.Func

func PromiseStatsReportOnRejectedToJS(callback PromiseStatsReportOnRejectedFunc) *PromiseStatsReportOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseStatsReportOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseStatsReportOnRejectedFromJS(_value js.Value) PromiseStatsReportOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: RTCSessionDescriptionCallback
type SessionDescriptionCallbackFunc func(description *SessionDescriptionInit)

// SessionDescriptionCallback is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type SessionDescriptionCallback js.Func

func SessionDescriptionCallbackToJS(callback SessionDescriptionCallbackFunc) *SessionDescriptionCallback {
	if callback == nil {
		return nil
	}
	ret := SessionDescriptionCallback(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *SessionDescriptionInit // javascript: RTCSessionDescriptionInit description
		)
		_p0 = SessionDescriptionInitFromJS(args[0])
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func SessionDescriptionCallbackFromJS(_value js.Value) SessionDescriptionCallbackFunc {
	return func(description *SessionDescriptionInit) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := description.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: RTCStatsReportForEach
type StatsReportForEachFunc func(currentValue *javascript.Object, currentKey string, listObj *StatsReport)

// StatsReportForEach is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type StatsReportForEach js.Func

func StatsReportForEachToJS(callback StatsReportForEachFunc) *StatsReportForEach {
	if callback == nil {
		return nil
	}
	ret := StatsReportForEach(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *javascript.Object // javascript: object currentValue
			_p1 string             // javascript: DOMString currentKey
			_p2 *StatsReport       // javascript: RTCStatsReport listObj
		)
		_p0 = javascript.ObjectFromJS(args[0])
		_p1 = (args[1]).String()
		_p2 = StatsReportFromJS(args[2])
		callback(_p0, _p1, _p2)

		// returning no return value
		return nil
	}))
	return &ret
}

func StatsReportForEachFromJS(_value js.Value) StatsReportForEachFunc {
	return func(currentValue *javascript.Object, currentKey string, listObj *StatsReport) {
		var (
			_args [3]interface{}
			_end  int
		)
		_p0 := currentValue.JSValue()
		_args[0] = _p0
		_end++
		_p1 := currentKey
		_args[1] = _p1
		_end++
		_p2 := listObj.JSValue()
		_args[2] = _p2
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// dictionary: RTCAnswerOptions
type AnswerOptions struct {
	VoiceActivityDetection bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *AnswerOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.VoiceActivityDetection
	out.Set("voiceActivityDetection", value0)
	return out
}

// AnswerOptionsFromJS is allocating a new
// AnswerOptions object and copy all values from
// input javascript object
func AnswerOptionsFromJS(value js.Wrapper) *AnswerOptions {
	input := value.JSValue()
	var out AnswerOptions
	var (
		value0 bool // javascript: boolean {voiceActivityDetection VoiceActivityDetection voiceActivityDetection}
	)
	value0 = (input.Get("voiceActivityDetection")).Bool()
	out.VoiceActivityDetection = value0
	return &out
}

// dictionary: RTCCertificateExpiration
type CertificateExpiration struct {
	Expires int
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *CertificateExpiration) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Expires
	out.Set("expires", value0)
	return out
}

// CertificateExpirationFromJS is allocating a new
// CertificateExpiration object and copy all values from
// input javascript object
func CertificateExpirationFromJS(value js.Wrapper) *CertificateExpiration {
	input := value.JSValue()
	var out CertificateExpiration
	var (
		value0 int // javascript: unsigned long long {expires Expires expires}
	)
	value0 = (input.Get("expires")).Int()
	out.Expires = value0
	return &out
}

// dictionary: RTCConfiguration
type Configuration struct {
	IceServers           []*IceServer
	IceTransportPolicy   IceTransportPolicy
	BundlePolicy         BundlePolicy
	RtcpMuxPolicy        RtcpMuxPolicy
	PeerIdentity         string
	Certificates         []*Certificate
	IceCandidatePoolSize int
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *Configuration) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.IceServers))
	for __idx0, __seq_in0 := range _this.IceServers {
		__seq_out0 := __seq_in0.JSValue()
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("iceServers", value0)
	value1 := _this.IceTransportPolicy.JSValue()
	out.Set("iceTransportPolicy", value1)
	value2 := _this.BundlePolicy.JSValue()
	out.Set("bundlePolicy", value2)
	value3 := _this.RtcpMuxPolicy.JSValue()
	out.Set("rtcpMuxPolicy", value3)
	value4 := _this.PeerIdentity
	out.Set("peerIdentity", value4)
	value5 := js.Global().Get("Array").New(len(_this.Certificates))
	for __idx5, __seq_in5 := range _this.Certificates {
		__seq_out5 := __seq_in5.JSValue()
		value5.SetIndex(__idx5, __seq_out5)
	}
	out.Set("certificates", value5)
	value6 := _this.IceCandidatePoolSize
	out.Set("iceCandidatePoolSize", value6)
	return out
}

// ConfigurationFromJS is allocating a new
// Configuration object and copy all values from
// input javascript object
func ConfigurationFromJS(value js.Wrapper) *Configuration {
	input := value.JSValue()
	var out Configuration
	var (
		value0 []*IceServer       // javascript: sequence<RTCIceServer> {iceServers IceServers iceServers}
		value1 IceTransportPolicy // javascript: RTCIceTransportPolicy {iceTransportPolicy IceTransportPolicy iceTransportPolicy}
		value2 BundlePolicy       // javascript: RTCBundlePolicy {bundlePolicy BundlePolicy bundlePolicy}
		value3 RtcpMuxPolicy      // javascript: RTCRtcpMuxPolicy {rtcpMuxPolicy RtcpMuxPolicy rtcpMuxPolicy}
		value4 string             // javascript: DOMString {peerIdentity PeerIdentity peerIdentity}
		value5 []*Certificate     // javascript: sequence<RTCCertificate> {certificates Certificates certificates}
		value6 int                // javascript: octet {iceCandidatePoolSize IceCandidatePoolSize iceCandidatePoolSize}
	)
	__length0 := input.Get("iceServers").Length()
	__array0 := make([]*IceServer, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *IceServer
		__seq_in0 := input.Get("iceServers").Index(__idx0)
		__seq_out0 = IceServerFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.IceServers = value0
	value1 = IceTransportPolicyFromJS(input.Get("iceTransportPolicy"))
	out.IceTransportPolicy = value1
	value2 = BundlePolicyFromJS(input.Get("bundlePolicy"))
	out.BundlePolicy = value2
	value3 = RtcpMuxPolicyFromJS(input.Get("rtcpMuxPolicy"))
	out.RtcpMuxPolicy = value3
	value4 = (input.Get("peerIdentity")).String()
	out.PeerIdentity = value4
	__length5 := input.Get("certificates").Length()
	__array5 := make([]*Certificate, __length5, __length5)
	for __idx5 := 0; __idx5 < __length5; __idx5++ {
		var __seq_out5 *Certificate
		__seq_in5 := input.Get("certificates").Index(__idx5)
		__seq_out5 = CertificateFromJS(__seq_in5)
		__array5[__idx5] = __seq_out5
	}
	value5 = __array5
	out.Certificates = value5
	value6 = (input.Get("iceCandidatePoolSize")).Int()
	out.IceCandidatePoolSize = value6
	return &out
}

// dictionary: RTCDTMFToneChangeEventInit
type DTMFToneChangeEventInit struct {
	Bubbles    bool
	Cancelable bool
	Composed   bool
	Tone       string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *DTMFToneChangeEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Tone
	out.Set("tone", value3)
	return out
}

// DTMFToneChangeEventInitFromJS is allocating a new
// DTMFToneChangeEventInit object and copy all values from
// input javascript object
func DTMFToneChangeEventInitFromJS(value js.Wrapper) *DTMFToneChangeEventInit {
	input := value.JSValue()
	var out DTMFToneChangeEventInit
	var (
		value0 bool   // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool   // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool   // javascript: boolean {composed Composed composed}
		value3 string // javascript: DOMString {tone Tone tone}
	)
	value0 = (input.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (input.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (input.Get("composed")).Bool()
	out.Composed = value2
	value3 = (input.Get("tone")).String()
	out.Tone = value3
	return &out
}

// dictionary: RTCDataChannelEventInit
type DataChannelEventInit struct {
	Bubbles    bool
	Cancelable bool
	Composed   bool
	Channel    *DataChannel
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *DataChannelEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Channel.JSValue()
	out.Set("channel", value3)
	return out
}

// DataChannelEventInitFromJS is allocating a new
// DataChannelEventInit object and copy all values from
// input javascript object
func DataChannelEventInitFromJS(value js.Wrapper) *DataChannelEventInit {
	input := value.JSValue()
	var out DataChannelEventInit
	var (
		value0 bool         // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool         // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool         // javascript: boolean {composed Composed composed}
		value3 *DataChannel // javascript: RTCDataChannel {channel Channel channel}
	)
	value0 = (input.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (input.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (input.Get("composed")).Bool()
	out.Composed = value2
	value3 = DataChannelFromJS(input.Get("channel"))
	out.Channel = value3
	return &out
}

// dictionary: RTCDataChannelInit
type DataChannelInit struct {
	Ordered           bool
	MaxPacketLifeTime int
	MaxRetransmits    int
	Protocol          string
	Negotiated        bool
	Id                int
	Priority          PriorityType
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *DataChannelInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Ordered
	out.Set("ordered", value0)
	value1 := _this.MaxPacketLifeTime
	out.Set("maxPacketLifeTime", value1)
	value2 := _this.MaxRetransmits
	out.Set("maxRetransmits", value2)
	value3 := _this.Protocol
	out.Set("protocol", value3)
	value4 := _this.Negotiated
	out.Set("negotiated", value4)
	value5 := _this.Id
	out.Set("id", value5)
	value6 := _this.Priority.JSValue()
	out.Set("priority", value6)
	return out
}

// DataChannelInitFromJS is allocating a new
// DataChannelInit object and copy all values from
// input javascript object
func DataChannelInitFromJS(value js.Wrapper) *DataChannelInit {
	input := value.JSValue()
	var out DataChannelInit
	var (
		value0 bool         // javascript: boolean {ordered Ordered ordered}
		value1 int          // javascript: unsigned short {maxPacketLifeTime MaxPacketLifeTime maxPacketLifeTime}
		value2 int          // javascript: unsigned short {maxRetransmits MaxRetransmits maxRetransmits}
		value3 string       // javascript: USVString {protocol Protocol protocol}
		value4 bool         // javascript: boolean {negotiated Negotiated negotiated}
		value5 int          // javascript: unsigned short {id Id id}
		value6 PriorityType // javascript: RTCPriorityType {priority Priority priority}
	)
	value0 = (input.Get("ordered")).Bool()
	out.Ordered = value0
	value1 = (input.Get("maxPacketLifeTime")).Int()
	out.MaxPacketLifeTime = value1
	value2 = (input.Get("maxRetransmits")).Int()
	out.MaxRetransmits = value2
	value3 = (input.Get("protocol")).String()
	out.Protocol = value3
	value4 = (input.Get("negotiated")).Bool()
	out.Negotiated = value4
	value5 = (input.Get("id")).Int()
	out.Id = value5
	value6 = PriorityTypeFromJS(input.Get("priority"))
	out.Priority = value6
	return &out
}

// dictionary: RTCDtlsFingerprint
type DtlsFingerprint struct {
	Algorithm string
	Value     string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *DtlsFingerprint) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Algorithm
	out.Set("algorithm", value0)
	value1 := _this.Value
	out.Set("value", value1)
	return out
}

// DtlsFingerprintFromJS is allocating a new
// DtlsFingerprint object and copy all values from
// input javascript object
func DtlsFingerprintFromJS(value js.Wrapper) *DtlsFingerprint {
	input := value.JSValue()
	var out DtlsFingerprint
	var (
		value0 string // javascript: DOMString {algorithm Algorithm algorithm}
		value1 string // javascript: DOMString {value Value value}
	)
	value0 = (input.Get("algorithm")).String()
	out.Algorithm = value0
	value1 = (input.Get("value")).String()
	out.Value = value1
	return &out
}

// dictionary: RTCErrorEventInit
type ErrorEventInit struct {
	Bubbles    bool
	Cancelable bool
	Composed   bool
	Error      *Error
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *ErrorEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Error.JSValue()
	out.Set("error", value3)
	return out
}

// ErrorEventInitFromJS is allocating a new
// ErrorEventInit object and copy all values from
// input javascript object
func ErrorEventInitFromJS(value js.Wrapper) *ErrorEventInit {
	input := value.JSValue()
	var out ErrorEventInit
	var (
		value0 bool   // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool   // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool   // javascript: boolean {composed Composed composed}
		value3 *Error // javascript: RTCError {error Error _error}
	)
	value0 = (input.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (input.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (input.Get("composed")).Bool()
	out.Composed = value2
	if input.Get("error").Type() != js.TypeNull && input.Get("error").Type() != js.TypeUndefined {
		value3 = ErrorFromJS(input.Get("error"))
	}
	out.Error = value3
	return &out
}

// dictionary: RTCIceCandidateInit
type IceCandidateInit struct {
	Candidate        string
	SdpMid           *string
	SdpMLineIndex    *int
	UsernameFragment string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *IceCandidateInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Candidate
	out.Set("candidate", value0)

	var value1 interface{}
	if _this.SdpMid != nil {
		value1 = *(_this.SdpMid)
	} else {
		value1 = nil
	}
	out.Set("sdpMid", value1)

	var value2 interface{}
	if _this.SdpMLineIndex != nil {
		value2 = *(_this.SdpMLineIndex)
	} else {
		value2 = nil
	}
	out.Set("sdpMLineIndex", value2)
	value3 := _this.UsernameFragment
	out.Set("usernameFragment", value3)
	return out
}

// IceCandidateInitFromJS is allocating a new
// IceCandidateInit object and copy all values from
// input javascript object
func IceCandidateInitFromJS(value js.Wrapper) *IceCandidateInit {
	input := value.JSValue()
	var out IceCandidateInit
	var (
		value0 string  // javascript: DOMString {candidate Candidate candidate}
		value1 *string // javascript: DOMString {sdpMid SdpMid sdpMid}
		value2 *int    // javascript: unsigned short {sdpMLineIndex SdpMLineIndex sdpMLineIndex}
		value3 string  // javascript: DOMString {usernameFragment UsernameFragment usernameFragment}
	)
	value0 = (input.Get("candidate")).String()
	out.Candidate = value0
	if input.Get("sdpMid").Type() != js.TypeNull && input.Get("sdpMid").Type() != js.TypeUndefined {
		__tmp := (input.Get("sdpMid")).String()
		value1 = &__tmp
	}
	out.SdpMid = value1
	if input.Get("sdpMLineIndex").Type() != js.TypeNull && input.Get("sdpMLineIndex").Type() != js.TypeUndefined {
		__tmp := (input.Get("sdpMLineIndex")).Int()
		value2 = &__tmp
	}
	out.SdpMLineIndex = value2
	value3 = (input.Get("usernameFragment")).String()
	out.UsernameFragment = value3
	return &out
}

// dictionary: RTCIceCandidatePair
type IceCandidatePair struct {
	Local  *IceCandidate
	Remote *IceCandidate
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *IceCandidatePair) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Local.JSValue()
	out.Set("local", value0)
	value1 := _this.Remote.JSValue()
	out.Set("remote", value1)
	return out
}

// IceCandidatePairFromJS is allocating a new
// IceCandidatePair object and copy all values from
// input javascript object
func IceCandidatePairFromJS(value js.Wrapper) *IceCandidatePair {
	input := value.JSValue()
	var out IceCandidatePair
	var (
		value0 *IceCandidate // javascript: RTCIceCandidate {local Local local}
		value1 *IceCandidate // javascript: RTCIceCandidate {remote Remote remote}
	)
	value0 = IceCandidateFromJS(input.Get("local"))
	out.Local = value0
	value1 = IceCandidateFromJS(input.Get("remote"))
	out.Remote = value1
	return &out
}

// dictionary: RTCIceParameters
type IceParameters struct {
	UsernameFragment string
	Password         string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *IceParameters) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.UsernameFragment
	out.Set("usernameFragment", value0)
	value1 := _this.Password
	out.Set("password", value1)
	return out
}

// IceParametersFromJS is allocating a new
// IceParameters object and copy all values from
// input javascript object
func IceParametersFromJS(value js.Wrapper) *IceParameters {
	input := value.JSValue()
	var out IceParameters
	var (
		value0 string // javascript: DOMString {usernameFragment UsernameFragment usernameFragment}
		value1 string // javascript: DOMString {password Password password}
	)
	value0 = (input.Get("usernameFragment")).String()
	out.UsernameFragment = value0
	value1 = (input.Get("password")).String()
	out.Password = value1
	return &out
}

// dictionary: RTCIceServer
type IceServer struct {
	Urls           *Union
	Username       string
	Credential     *Union
	CredentialType IceCredentialType
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *IceServer) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Urls.JSValue()
	out.Set("urls", value0)
	value1 := _this.Username
	out.Set("username", value1)
	value2 := _this.Credential.JSValue()
	out.Set("credential", value2)
	value3 := _this.CredentialType.JSValue()
	out.Set("credentialType", value3)
	return out
}

// IceServerFromJS is allocating a new
// IceServer object and copy all values from
// input javascript object
func IceServerFromJS(value js.Wrapper) *IceServer {
	input := value.JSValue()
	var out IceServer
	var (
		value0 *Union            // javascript: Union {urls Urls urls}
		value1 string            // javascript: DOMString {username Username username}
		value2 *Union            // javascript: Union {credential Credential credential}
		value3 IceCredentialType // javascript: RTCIceCredentialType {credentialType CredentialType credentialType}
	)
	value0 = UnionFromJS(input.Get("urls"))
	out.Urls = value0
	value1 = (input.Get("username")).String()
	out.Username = value1
	value2 = UnionFromJS(input.Get("credential"))
	out.Credential = value2
	value3 = IceCredentialTypeFromJS(input.Get("credentialType"))
	out.CredentialType = value3
	return &out
}

// dictionary: RTCOAuthCredential
type OAuthCredential struct {
	MacKey      string
	AccessToken string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *OAuthCredential) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.MacKey
	out.Set("macKey", value0)
	value1 := _this.AccessToken
	out.Set("accessToken", value1)
	return out
}

// OAuthCredentialFromJS is allocating a new
// OAuthCredential object and copy all values from
// input javascript object
func OAuthCredentialFromJS(value js.Wrapper) *OAuthCredential {
	input := value.JSValue()
	var out OAuthCredential
	var (
		value0 string // javascript: DOMString {macKey MacKey macKey}
		value1 string // javascript: DOMString {accessToken AccessToken accessToken}
	)
	value0 = (input.Get("macKey")).String()
	out.MacKey = value0
	value1 = (input.Get("accessToken")).String()
	out.AccessToken = value1
	return &out
}

// dictionary: RTCOfferAnswerOptions
type OfferAnswerOptions struct {
	VoiceActivityDetection bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *OfferAnswerOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.VoiceActivityDetection
	out.Set("voiceActivityDetection", value0)
	return out
}

// OfferAnswerOptionsFromJS is allocating a new
// OfferAnswerOptions object and copy all values from
// input javascript object
func OfferAnswerOptionsFromJS(value js.Wrapper) *OfferAnswerOptions {
	input := value.JSValue()
	var out OfferAnswerOptions
	var (
		value0 bool // javascript: boolean {voiceActivityDetection VoiceActivityDetection voiceActivityDetection}
	)
	value0 = (input.Get("voiceActivityDetection")).Bool()
	out.VoiceActivityDetection = value0
	return &out
}

// dictionary: RTCOfferOptions
type OfferOptions struct {
	VoiceActivityDetection bool
	IceRestart             bool
	OfferToReceiveAudio    bool
	OfferToReceiveVideo    bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *OfferOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.VoiceActivityDetection
	out.Set("voiceActivityDetection", value0)
	value1 := _this.IceRestart
	out.Set("iceRestart", value1)
	value2 := _this.OfferToReceiveAudio
	out.Set("offerToReceiveAudio", value2)
	value3 := _this.OfferToReceiveVideo
	out.Set("offerToReceiveVideo", value3)
	return out
}

// OfferOptionsFromJS is allocating a new
// OfferOptions object and copy all values from
// input javascript object
func OfferOptionsFromJS(value js.Wrapper) *OfferOptions {
	input := value.JSValue()
	var out OfferOptions
	var (
		value0 bool // javascript: boolean {voiceActivityDetection VoiceActivityDetection voiceActivityDetection}
		value1 bool // javascript: boolean {iceRestart IceRestart iceRestart}
		value2 bool // javascript: boolean {offerToReceiveAudio OfferToReceiveAudio offerToReceiveAudio}
		value3 bool // javascript: boolean {offerToReceiveVideo OfferToReceiveVideo offerToReceiveVideo}
	)
	value0 = (input.Get("voiceActivityDetection")).Bool()
	out.VoiceActivityDetection = value0
	value1 = (input.Get("iceRestart")).Bool()
	out.IceRestart = value1
	value2 = (input.Get("offerToReceiveAudio")).Bool()
	out.OfferToReceiveAudio = value2
	value3 = (input.Get("offerToReceiveVideo")).Bool()
	out.OfferToReceiveVideo = value3
	return &out
}

// dictionary: RTCPeerConnectionIceErrorEventInit
type PeerConnectionIceErrorEventInit struct {
	Bubbles       bool
	Cancelable    bool
	Composed      bool
	HostCandidate string
	Url           string
	ErrorCode     int
	StatusText    string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *PeerConnectionIceErrorEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.HostCandidate
	out.Set("hostCandidate", value3)
	value4 := _this.Url
	out.Set("url", value4)
	value5 := _this.ErrorCode
	out.Set("errorCode", value5)
	value6 := _this.StatusText
	out.Set("statusText", value6)
	return out
}

// PeerConnectionIceErrorEventInitFromJS is allocating a new
// PeerConnectionIceErrorEventInit object and copy all values from
// input javascript object
func PeerConnectionIceErrorEventInitFromJS(value js.Wrapper) *PeerConnectionIceErrorEventInit {
	input := value.JSValue()
	var out PeerConnectionIceErrorEventInit
	var (
		value0 bool   // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool   // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool   // javascript: boolean {composed Composed composed}
		value3 string // javascript: DOMString {hostCandidate HostCandidate hostCandidate}
		value4 string // javascript: DOMString {url Url url}
		value5 int    // javascript: unsigned short {errorCode ErrorCode errorCode}
		value6 string // javascript: USVString {statusText StatusText statusText}
	)
	value0 = (input.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (input.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (input.Get("composed")).Bool()
	out.Composed = value2
	value3 = (input.Get("hostCandidate")).String()
	out.HostCandidate = value3
	value4 = (input.Get("url")).String()
	out.Url = value4
	value5 = (input.Get("errorCode")).Int()
	out.ErrorCode = value5
	value6 = (input.Get("statusText")).String()
	out.StatusText = value6
	return &out
}

// dictionary: RTCPeerConnectionIceEventInit
type PeerConnectionIceEventInit struct {
	Bubbles    bool
	Cancelable bool
	Composed   bool
	Candidate  *IceCandidate
	Url        *string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *PeerConnectionIceEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Candidate.JSValue()
	out.Set("candidate", value3)

	var value4 interface{}
	if _this.Url != nil {
		value4 = *(_this.Url)
	} else {
		value4 = nil
	}
	out.Set("url", value4)
	return out
}

// PeerConnectionIceEventInitFromJS is allocating a new
// PeerConnectionIceEventInit object and copy all values from
// input javascript object
func PeerConnectionIceEventInitFromJS(value js.Wrapper) *PeerConnectionIceEventInit {
	input := value.JSValue()
	var out PeerConnectionIceEventInit
	var (
		value0 bool          // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool          // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool          // javascript: boolean {composed Composed composed}
		value3 *IceCandidate // javascript: RTCIceCandidate {candidate Candidate candidate}
		value4 *string       // javascript: DOMString {url Url url}
	)
	value0 = (input.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (input.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (input.Get("composed")).Bool()
	out.Composed = value2
	if input.Get("candidate").Type() != js.TypeNull && input.Get("candidate").Type() != js.TypeUndefined {
		value3 = IceCandidateFromJS(input.Get("candidate"))
	}
	out.Candidate = value3
	if input.Get("url").Type() != js.TypeNull && input.Get("url").Type() != js.TypeUndefined {
		__tmp := (input.Get("url")).String()
		value4 = &__tmp
	}
	out.Url = value4
	return &out
}

// dictionary: RTCRtcpParameters
type RtcpParameters struct {
	Cname       string
	ReducedSize bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *RtcpParameters) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Cname
	out.Set("cname", value0)
	value1 := _this.ReducedSize
	out.Set("reducedSize", value1)
	return out
}

// RtcpParametersFromJS is allocating a new
// RtcpParameters object and copy all values from
// input javascript object
func RtcpParametersFromJS(value js.Wrapper) *RtcpParameters {
	input := value.JSValue()
	var out RtcpParameters
	var (
		value0 string // javascript: DOMString {cname Cname cname}
		value1 bool   // javascript: boolean {reducedSize ReducedSize reducedSize}
	)
	value0 = (input.Get("cname")).String()
	out.Cname = value0
	value1 = (input.Get("reducedSize")).Bool()
	out.ReducedSize = value1
	return &out
}

// dictionary: RTCRtpCapabilities
type RtpCapabilities struct {
	Codecs           []*RtpCodecCapability
	HeaderExtensions []*RtpHeaderExtensionCapability
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *RtpCapabilities) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.Codecs))
	for __idx0, __seq_in0 := range _this.Codecs {
		__seq_out0 := __seq_in0.JSValue()
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("codecs", value0)
	value1 := js.Global().Get("Array").New(len(_this.HeaderExtensions))
	for __idx1, __seq_in1 := range _this.HeaderExtensions {
		__seq_out1 := __seq_in1.JSValue()
		value1.SetIndex(__idx1, __seq_out1)
	}
	out.Set("headerExtensions", value1)
	return out
}

// RtpCapabilitiesFromJS is allocating a new
// RtpCapabilities object and copy all values from
// input javascript object
func RtpCapabilitiesFromJS(value js.Wrapper) *RtpCapabilities {
	input := value.JSValue()
	var out RtpCapabilities
	var (
		value0 []*RtpCodecCapability           // javascript: sequence<RTCRtpCodecCapability> {codecs Codecs codecs}
		value1 []*RtpHeaderExtensionCapability // javascript: sequence<RTCRtpHeaderExtensionCapability> {headerExtensions HeaderExtensions headerExtensions}
	)
	__length0 := input.Get("codecs").Length()
	__array0 := make([]*RtpCodecCapability, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *RtpCodecCapability
		__seq_in0 := input.Get("codecs").Index(__idx0)
		__seq_out0 = RtpCodecCapabilityFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.Codecs = value0
	__length1 := input.Get("headerExtensions").Length()
	__array1 := make([]*RtpHeaderExtensionCapability, __length1, __length1)
	for __idx1 := 0; __idx1 < __length1; __idx1++ {
		var __seq_out1 *RtpHeaderExtensionCapability
		__seq_in1 := input.Get("headerExtensions").Index(__idx1)
		__seq_out1 = RtpHeaderExtensionCapabilityFromJS(__seq_in1)
		__array1[__idx1] = __seq_out1
	}
	value1 = __array1
	out.HeaderExtensions = value1
	return &out
}

// dictionary: RTCRtpCodecCapability
type RtpCodecCapability struct {
	MimeType    string
	ClockRate   uint
	Channels    int
	SdpFmtpLine string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *RtpCodecCapability) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.MimeType
	out.Set("mimeType", value0)
	value1 := _this.ClockRate
	out.Set("clockRate", value1)
	value2 := _this.Channels
	out.Set("channels", value2)
	value3 := _this.SdpFmtpLine
	out.Set("sdpFmtpLine", value3)
	return out
}

// RtpCodecCapabilityFromJS is allocating a new
// RtpCodecCapability object and copy all values from
// input javascript object
func RtpCodecCapabilityFromJS(value js.Wrapper) *RtpCodecCapability {
	input := value.JSValue()
	var out RtpCodecCapability
	var (
		value0 string // javascript: DOMString {mimeType MimeType mimeType}
		value1 uint   // javascript: unsigned long {clockRate ClockRate clockRate}
		value2 int    // javascript: unsigned short {channels Channels channels}
		value3 string // javascript: DOMString {sdpFmtpLine SdpFmtpLine sdpFmtpLine}
	)
	value0 = (input.Get("mimeType")).String()
	out.MimeType = value0
	value1 = (uint)((input.Get("clockRate")).Int())
	out.ClockRate = value1
	value2 = (input.Get("channels")).Int()
	out.Channels = value2
	value3 = (input.Get("sdpFmtpLine")).String()
	out.SdpFmtpLine = value3
	return &out
}

// dictionary: RTCRtpCodecParameters
type RtpCodecParameters struct {
	PayloadType int
	MimeType    string
	ClockRate   uint
	Channels    int
	SdpFmtpLine string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *RtpCodecParameters) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.PayloadType
	out.Set("payloadType", value0)
	value1 := _this.MimeType
	out.Set("mimeType", value1)
	value2 := _this.ClockRate
	out.Set("clockRate", value2)
	value3 := _this.Channels
	out.Set("channels", value3)
	value4 := _this.SdpFmtpLine
	out.Set("sdpFmtpLine", value4)
	return out
}

// RtpCodecParametersFromJS is allocating a new
// RtpCodecParameters object and copy all values from
// input javascript object
func RtpCodecParametersFromJS(value js.Wrapper) *RtpCodecParameters {
	input := value.JSValue()
	var out RtpCodecParameters
	var (
		value0 int    // javascript: octet {payloadType PayloadType payloadType}
		value1 string // javascript: DOMString {mimeType MimeType mimeType}
		value2 uint   // javascript: unsigned long {clockRate ClockRate clockRate}
		value3 int    // javascript: unsigned short {channels Channels channels}
		value4 string // javascript: DOMString {sdpFmtpLine SdpFmtpLine sdpFmtpLine}
	)
	value0 = (input.Get("payloadType")).Int()
	out.PayloadType = value0
	value1 = (input.Get("mimeType")).String()
	out.MimeType = value1
	value2 = (uint)((input.Get("clockRate")).Int())
	out.ClockRate = value2
	value3 = (input.Get("channels")).Int()
	out.Channels = value3
	value4 = (input.Get("sdpFmtpLine")).String()
	out.SdpFmtpLine = value4
	return &out
}

// dictionary: RTCRtpCodingParameters
type RtpCodingParameters struct {
	Rid string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *RtpCodingParameters) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Rid
	out.Set("rid", value0)
	return out
}

// RtpCodingParametersFromJS is allocating a new
// RtpCodingParameters object and copy all values from
// input javascript object
func RtpCodingParametersFromJS(value js.Wrapper) *RtpCodingParameters {
	input := value.JSValue()
	var out RtpCodingParameters
	var (
		value0 string // javascript: DOMString {rid Rid rid}
	)
	value0 = (input.Get("rid")).String()
	out.Rid = value0
	return &out
}

// dictionary: RTCRtpContributingSource
type RtpContributingSource struct {
	Timestamp  float64
	Source     uint
	AudioLevel float64
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *RtpContributingSource) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Timestamp
	out.Set("timestamp", value0)
	value1 := _this.Source
	out.Set("source", value1)
	value2 := _this.AudioLevel
	out.Set("audioLevel", value2)
	return out
}

// RtpContributingSourceFromJS is allocating a new
// RtpContributingSource object and copy all values from
// input javascript object
func RtpContributingSourceFromJS(value js.Wrapper) *RtpContributingSource {
	input := value.JSValue()
	var out RtpContributingSource
	var (
		value0 float64 // javascript: double {timestamp Timestamp timestamp}
		value1 uint    // javascript: unsigned long {source Source source}
		value2 float64 // javascript: double {audioLevel AudioLevel audioLevel}
	)
	value0 = (input.Get("timestamp")).Float()
	out.Timestamp = value0
	value1 = (uint)((input.Get("source")).Int())
	out.Source = value1
	value2 = (input.Get("audioLevel")).Float()
	out.AudioLevel = value2
	return &out
}

// dictionary: RTCRtpDecodingParameters
type RtpDecodingParameters struct {
	Rid string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *RtpDecodingParameters) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Rid
	out.Set("rid", value0)
	return out
}

// RtpDecodingParametersFromJS is allocating a new
// RtpDecodingParameters object and copy all values from
// input javascript object
func RtpDecodingParametersFromJS(value js.Wrapper) *RtpDecodingParameters {
	input := value.JSValue()
	var out RtpDecodingParameters
	var (
		value0 string // javascript: DOMString {rid Rid rid}
	)
	value0 = (input.Get("rid")).String()
	out.Rid = value0
	return &out
}

// dictionary: RTCRtpEncodingParameters
type RtpEncodingParameters struct {
	Rid                   string
	CodecPayloadType      int
	Dtx                   DtxStatus
	Active                bool
	Ptime                 uint
	MaxBitrate            uint
	MaxFramerate          float64
	ScaleResolutionDownBy float64
	NetworkPriority       PriorityType
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *RtpEncodingParameters) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Rid
	out.Set("rid", value0)
	value1 := _this.CodecPayloadType
	out.Set("codecPayloadType", value1)
	value2 := _this.Dtx.JSValue()
	out.Set("dtx", value2)
	value3 := _this.Active
	out.Set("active", value3)
	value4 := _this.Ptime
	out.Set("ptime", value4)
	value5 := _this.MaxBitrate
	out.Set("maxBitrate", value5)
	value6 := _this.MaxFramerate
	out.Set("maxFramerate", value6)
	value7 := _this.ScaleResolutionDownBy
	out.Set("scaleResolutionDownBy", value7)
	value8 := _this.NetworkPriority.JSValue()
	out.Set("networkPriority", value8)
	return out
}

// RtpEncodingParametersFromJS is allocating a new
// RtpEncodingParameters object and copy all values from
// input javascript object
func RtpEncodingParametersFromJS(value js.Wrapper) *RtpEncodingParameters {
	input := value.JSValue()
	var out RtpEncodingParameters
	var (
		value0 string       // javascript: DOMString {rid Rid rid}
		value1 int          // javascript: octet {codecPayloadType CodecPayloadType codecPayloadType}
		value2 DtxStatus    // javascript: RTCDtxStatus {dtx Dtx dtx}
		value3 bool         // javascript: boolean {active Active active}
		value4 uint         // javascript: unsigned long {ptime Ptime ptime}
		value5 uint         // javascript: unsigned long {maxBitrate MaxBitrate maxBitrate}
		value6 float64      // javascript: double {maxFramerate MaxFramerate maxFramerate}
		value7 float64      // javascript: double {scaleResolutionDownBy ScaleResolutionDownBy scaleResolutionDownBy}
		value8 PriorityType // javascript: RTCPriorityType {networkPriority NetworkPriority networkPriority}
	)
	value0 = (input.Get("rid")).String()
	out.Rid = value0
	value1 = (input.Get("codecPayloadType")).Int()
	out.CodecPayloadType = value1
	value2 = DtxStatusFromJS(input.Get("dtx"))
	out.Dtx = value2
	value3 = (input.Get("active")).Bool()
	out.Active = value3
	value4 = (uint)((input.Get("ptime")).Int())
	out.Ptime = value4
	value5 = (uint)((input.Get("maxBitrate")).Int())
	out.MaxBitrate = value5
	value6 = (input.Get("maxFramerate")).Float()
	out.MaxFramerate = value6
	value7 = (input.Get("scaleResolutionDownBy")).Float()
	out.ScaleResolutionDownBy = value7
	value8 = PriorityTypeFromJS(input.Get("networkPriority"))
	out.NetworkPriority = value8
	return &out
}

// dictionary: RTCRtpHeaderExtensionCapability
type RtpHeaderExtensionCapability struct {
	Uri string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *RtpHeaderExtensionCapability) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Uri
	out.Set("uri", value0)
	return out
}

// RtpHeaderExtensionCapabilityFromJS is allocating a new
// RtpHeaderExtensionCapability object and copy all values from
// input javascript object
func RtpHeaderExtensionCapabilityFromJS(value js.Wrapper) *RtpHeaderExtensionCapability {
	input := value.JSValue()
	var out RtpHeaderExtensionCapability
	var (
		value0 string // javascript: DOMString {uri Uri uri}
	)
	value0 = (input.Get("uri")).String()
	out.Uri = value0
	return &out
}

// dictionary: RTCRtpHeaderExtensionParameters
type RtpHeaderExtensionParameters struct {
	Uri       string
	Id        int
	Encrypted bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *RtpHeaderExtensionParameters) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Uri
	out.Set("uri", value0)
	value1 := _this.Id
	out.Set("id", value1)
	value2 := _this.Encrypted
	out.Set("encrypted", value2)
	return out
}

// RtpHeaderExtensionParametersFromJS is allocating a new
// RtpHeaderExtensionParameters object and copy all values from
// input javascript object
func RtpHeaderExtensionParametersFromJS(value js.Wrapper) *RtpHeaderExtensionParameters {
	input := value.JSValue()
	var out RtpHeaderExtensionParameters
	var (
		value0 string // javascript: DOMString {uri Uri uri}
		value1 int    // javascript: unsigned short {id Id id}
		value2 bool   // javascript: boolean {encrypted Encrypted encrypted}
	)
	value0 = (input.Get("uri")).String()
	out.Uri = value0
	value1 = (input.Get("id")).Int()
	out.Id = value1
	value2 = (input.Get("encrypted")).Bool()
	out.Encrypted = value2
	return &out
}

// dictionary: RTCRtpParameters
type RtpParameters struct {
	HeaderExtensions []*RtpHeaderExtensionParameters
	Rtcp             *RtcpParameters
	Codecs           []*RtpCodecParameters
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *RtpParameters) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.HeaderExtensions))
	for __idx0, __seq_in0 := range _this.HeaderExtensions {
		__seq_out0 := __seq_in0.JSValue()
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("headerExtensions", value0)
	value1 := _this.Rtcp.JSValue()
	out.Set("rtcp", value1)
	value2 := js.Global().Get("Array").New(len(_this.Codecs))
	for __idx2, __seq_in2 := range _this.Codecs {
		__seq_out2 := __seq_in2.JSValue()
		value2.SetIndex(__idx2, __seq_out2)
	}
	out.Set("codecs", value2)
	return out
}

// RtpParametersFromJS is allocating a new
// RtpParameters object and copy all values from
// input javascript object
func RtpParametersFromJS(value js.Wrapper) *RtpParameters {
	input := value.JSValue()
	var out RtpParameters
	var (
		value0 []*RtpHeaderExtensionParameters // javascript: sequence<RTCRtpHeaderExtensionParameters> {headerExtensions HeaderExtensions headerExtensions}
		value1 *RtcpParameters                 // javascript: RTCRtcpParameters {rtcp Rtcp rtcp}
		value2 []*RtpCodecParameters           // javascript: sequence<RTCRtpCodecParameters> {codecs Codecs codecs}
	)
	__length0 := input.Get("headerExtensions").Length()
	__array0 := make([]*RtpHeaderExtensionParameters, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *RtpHeaderExtensionParameters
		__seq_in0 := input.Get("headerExtensions").Index(__idx0)
		__seq_out0 = RtpHeaderExtensionParametersFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.HeaderExtensions = value0
	value1 = RtcpParametersFromJS(input.Get("rtcp"))
	out.Rtcp = value1
	__length2 := input.Get("codecs").Length()
	__array2 := make([]*RtpCodecParameters, __length2, __length2)
	for __idx2 := 0; __idx2 < __length2; __idx2++ {
		var __seq_out2 *RtpCodecParameters
		__seq_in2 := input.Get("codecs").Index(__idx2)
		__seq_out2 = RtpCodecParametersFromJS(__seq_in2)
		__array2[__idx2] = __seq_out2
	}
	value2 = __array2
	out.Codecs = value2
	return &out
}

// dictionary: RTCRtpReceiveParameters
type RtpReceiveParameters struct {
	HeaderExtensions []*RtpHeaderExtensionParameters
	Rtcp             *RtcpParameters
	Codecs           []*RtpCodecParameters
	Encodings        []*RtpDecodingParameters
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *RtpReceiveParameters) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.HeaderExtensions))
	for __idx0, __seq_in0 := range _this.HeaderExtensions {
		__seq_out0 := __seq_in0.JSValue()
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("headerExtensions", value0)
	value1 := _this.Rtcp.JSValue()
	out.Set("rtcp", value1)
	value2 := js.Global().Get("Array").New(len(_this.Codecs))
	for __idx2, __seq_in2 := range _this.Codecs {
		__seq_out2 := __seq_in2.JSValue()
		value2.SetIndex(__idx2, __seq_out2)
	}
	out.Set("codecs", value2)
	value3 := js.Global().Get("Array").New(len(_this.Encodings))
	for __idx3, __seq_in3 := range _this.Encodings {
		__seq_out3 := __seq_in3.JSValue()
		value3.SetIndex(__idx3, __seq_out3)
	}
	out.Set("encodings", value3)
	return out
}

// RtpReceiveParametersFromJS is allocating a new
// RtpReceiveParameters object and copy all values from
// input javascript object
func RtpReceiveParametersFromJS(value js.Wrapper) *RtpReceiveParameters {
	input := value.JSValue()
	var out RtpReceiveParameters
	var (
		value0 []*RtpHeaderExtensionParameters // javascript: sequence<RTCRtpHeaderExtensionParameters> {headerExtensions HeaderExtensions headerExtensions}
		value1 *RtcpParameters                 // javascript: RTCRtcpParameters {rtcp Rtcp rtcp}
		value2 []*RtpCodecParameters           // javascript: sequence<RTCRtpCodecParameters> {codecs Codecs codecs}
		value3 []*RtpDecodingParameters        // javascript: sequence<RTCRtpDecodingParameters> {encodings Encodings encodings}
	)
	__length0 := input.Get("headerExtensions").Length()
	__array0 := make([]*RtpHeaderExtensionParameters, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *RtpHeaderExtensionParameters
		__seq_in0 := input.Get("headerExtensions").Index(__idx0)
		__seq_out0 = RtpHeaderExtensionParametersFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.HeaderExtensions = value0
	value1 = RtcpParametersFromJS(input.Get("rtcp"))
	out.Rtcp = value1
	__length2 := input.Get("codecs").Length()
	__array2 := make([]*RtpCodecParameters, __length2, __length2)
	for __idx2 := 0; __idx2 < __length2; __idx2++ {
		var __seq_out2 *RtpCodecParameters
		__seq_in2 := input.Get("codecs").Index(__idx2)
		__seq_out2 = RtpCodecParametersFromJS(__seq_in2)
		__array2[__idx2] = __seq_out2
	}
	value2 = __array2
	out.Codecs = value2
	__length3 := input.Get("encodings").Length()
	__array3 := make([]*RtpDecodingParameters, __length3, __length3)
	for __idx3 := 0; __idx3 < __length3; __idx3++ {
		var __seq_out3 *RtpDecodingParameters
		__seq_in3 := input.Get("encodings").Index(__idx3)
		__seq_out3 = RtpDecodingParametersFromJS(__seq_in3)
		__array3[__idx3] = __seq_out3
	}
	value3 = __array3
	out.Encodings = value3
	return &out
}

// dictionary: RTCRtpSendParameters
type RtpSendParameters struct {
	HeaderExtensions      []*RtpHeaderExtensionParameters
	Rtcp                  *RtcpParameters
	Codecs                []*RtpCodecParameters
	TransactionId         string
	Encodings             []*RtpEncodingParameters
	DegradationPreference DegradationPreference
	Priority              PriorityType
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *RtpSendParameters) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.HeaderExtensions))
	for __idx0, __seq_in0 := range _this.HeaderExtensions {
		__seq_out0 := __seq_in0.JSValue()
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("headerExtensions", value0)
	value1 := _this.Rtcp.JSValue()
	out.Set("rtcp", value1)
	value2 := js.Global().Get("Array").New(len(_this.Codecs))
	for __idx2, __seq_in2 := range _this.Codecs {
		__seq_out2 := __seq_in2.JSValue()
		value2.SetIndex(__idx2, __seq_out2)
	}
	out.Set("codecs", value2)
	value3 := _this.TransactionId
	out.Set("transactionId", value3)
	value4 := js.Global().Get("Array").New(len(_this.Encodings))
	for __idx4, __seq_in4 := range _this.Encodings {
		__seq_out4 := __seq_in4.JSValue()
		value4.SetIndex(__idx4, __seq_out4)
	}
	out.Set("encodings", value4)
	value5 := _this.DegradationPreference.JSValue()
	out.Set("degradationPreference", value5)
	value6 := _this.Priority.JSValue()
	out.Set("priority", value6)
	return out
}

// RtpSendParametersFromJS is allocating a new
// RtpSendParameters object and copy all values from
// input javascript object
func RtpSendParametersFromJS(value js.Wrapper) *RtpSendParameters {
	input := value.JSValue()
	var out RtpSendParameters
	var (
		value0 []*RtpHeaderExtensionParameters // javascript: sequence<RTCRtpHeaderExtensionParameters> {headerExtensions HeaderExtensions headerExtensions}
		value1 *RtcpParameters                 // javascript: RTCRtcpParameters {rtcp Rtcp rtcp}
		value2 []*RtpCodecParameters           // javascript: sequence<RTCRtpCodecParameters> {codecs Codecs codecs}
		value3 string                          // javascript: DOMString {transactionId TransactionId transactionId}
		value4 []*RtpEncodingParameters        // javascript: sequence<RTCRtpEncodingParameters> {encodings Encodings encodings}
		value5 DegradationPreference           // javascript: RTCDegradationPreference {degradationPreference DegradationPreference degradationPreference}
		value6 PriorityType                    // javascript: RTCPriorityType {priority Priority priority}
	)
	__length0 := input.Get("headerExtensions").Length()
	__array0 := make([]*RtpHeaderExtensionParameters, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *RtpHeaderExtensionParameters
		__seq_in0 := input.Get("headerExtensions").Index(__idx0)
		__seq_out0 = RtpHeaderExtensionParametersFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.HeaderExtensions = value0
	value1 = RtcpParametersFromJS(input.Get("rtcp"))
	out.Rtcp = value1
	__length2 := input.Get("codecs").Length()
	__array2 := make([]*RtpCodecParameters, __length2, __length2)
	for __idx2 := 0; __idx2 < __length2; __idx2++ {
		var __seq_out2 *RtpCodecParameters
		__seq_in2 := input.Get("codecs").Index(__idx2)
		__seq_out2 = RtpCodecParametersFromJS(__seq_in2)
		__array2[__idx2] = __seq_out2
	}
	value2 = __array2
	out.Codecs = value2
	value3 = (input.Get("transactionId")).String()
	out.TransactionId = value3
	__length4 := input.Get("encodings").Length()
	__array4 := make([]*RtpEncodingParameters, __length4, __length4)
	for __idx4 := 0; __idx4 < __length4; __idx4++ {
		var __seq_out4 *RtpEncodingParameters
		__seq_in4 := input.Get("encodings").Index(__idx4)
		__seq_out4 = RtpEncodingParametersFromJS(__seq_in4)
		__array4[__idx4] = __seq_out4
	}
	value4 = __array4
	out.Encodings = value4
	value5 = DegradationPreferenceFromJS(input.Get("degradationPreference"))
	out.DegradationPreference = value5
	value6 = PriorityTypeFromJS(input.Get("priority"))
	out.Priority = value6
	return &out
}

// dictionary: RTCRtpSynchronizationSource
type RtpSynchronizationSource struct {
	Timestamp         float64
	Source            uint
	AudioLevel        float64
	VoiceActivityFlag bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *RtpSynchronizationSource) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Timestamp
	out.Set("timestamp", value0)
	value1 := _this.Source
	out.Set("source", value1)
	value2 := _this.AudioLevel
	out.Set("audioLevel", value2)
	value3 := _this.VoiceActivityFlag
	out.Set("voiceActivityFlag", value3)
	return out
}

// RtpSynchronizationSourceFromJS is allocating a new
// RtpSynchronizationSource object and copy all values from
// input javascript object
func RtpSynchronizationSourceFromJS(value js.Wrapper) *RtpSynchronizationSource {
	input := value.JSValue()
	var out RtpSynchronizationSource
	var (
		value0 float64 // javascript: double {timestamp Timestamp timestamp}
		value1 uint    // javascript: unsigned long {source Source source}
		value2 float64 // javascript: double {audioLevel AudioLevel audioLevel}
		value3 bool    // javascript: boolean {voiceActivityFlag VoiceActivityFlag voiceActivityFlag}
	)
	value0 = (input.Get("timestamp")).Float()
	out.Timestamp = value0
	value1 = (uint)((input.Get("source")).Int())
	out.Source = value1
	value2 = (input.Get("audioLevel")).Float()
	out.AudioLevel = value2
	value3 = (input.Get("voiceActivityFlag")).Bool()
	out.VoiceActivityFlag = value3
	return &out
}

// dictionary: RTCRtpTransceiverInit
type RtpTransceiverInit struct {
	Direction     RtpTransceiverDirection
	Streams       []*local.MediaStream
	SendEncodings []*RtpEncodingParameters
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *RtpTransceiverInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Direction.JSValue()
	out.Set("direction", value0)
	value1 := js.Global().Get("Array").New(len(_this.Streams))
	for __idx1, __seq_in1 := range _this.Streams {
		__seq_out1 := __seq_in1.JSValue()
		value1.SetIndex(__idx1, __seq_out1)
	}
	out.Set("streams", value1)
	value2 := js.Global().Get("Array").New(len(_this.SendEncodings))
	for __idx2, __seq_in2 := range _this.SendEncodings {
		__seq_out2 := __seq_in2.JSValue()
		value2.SetIndex(__idx2, __seq_out2)
	}
	out.Set("sendEncodings", value2)
	return out
}

// RtpTransceiverInitFromJS is allocating a new
// RtpTransceiverInit object and copy all values from
// input javascript object
func RtpTransceiverInitFromJS(value js.Wrapper) *RtpTransceiverInit {
	input := value.JSValue()
	var out RtpTransceiverInit
	var (
		value0 RtpTransceiverDirection  // javascript: RTCRtpTransceiverDirection {direction Direction direction}
		value1 []*local.MediaStream     // javascript: sequence<MediaStream> {streams Streams streams}
		value2 []*RtpEncodingParameters // javascript: sequence<RTCRtpEncodingParameters> {sendEncodings SendEncodings sendEncodings}
	)
	value0 = RtpTransceiverDirectionFromJS(input.Get("direction"))
	out.Direction = value0
	__length1 := input.Get("streams").Length()
	__array1 := make([]*local.MediaStream, __length1, __length1)
	for __idx1 := 0; __idx1 < __length1; __idx1++ {
		var __seq_out1 *local.MediaStream
		__seq_in1 := input.Get("streams").Index(__idx1)
		__seq_out1 = local.MediaStreamFromJS(__seq_in1)
		__array1[__idx1] = __seq_out1
	}
	value1 = __array1
	out.Streams = value1
	__length2 := input.Get("sendEncodings").Length()
	__array2 := make([]*RtpEncodingParameters, __length2, __length2)
	for __idx2 := 0; __idx2 < __length2; __idx2++ {
		var __seq_out2 *RtpEncodingParameters
		__seq_in2 := input.Get("sendEncodings").Index(__idx2)
		__seq_out2 = RtpEncodingParametersFromJS(__seq_in2)
		__array2[__idx2] = __seq_out2
	}
	value2 = __array2
	out.SendEncodings = value2
	return &out
}

// dictionary: RTCSessionDescriptionInit
type SessionDescriptionInit struct {
	Type SdpType
	Sdp  string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *SessionDescriptionInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Type.JSValue()
	out.Set("type", value0)
	value1 := _this.Sdp
	out.Set("sdp", value1)
	return out
}

// SessionDescriptionInitFromJS is allocating a new
// SessionDescriptionInit object and copy all values from
// input javascript object
func SessionDescriptionInitFromJS(value js.Wrapper) *SessionDescriptionInit {
	input := value.JSValue()
	var out SessionDescriptionInit
	var (
		value0 SdpType // javascript: RTCSdpType {type Type _type}
		value1 string  // javascript: DOMString {sdp Sdp sdp}
	)
	value0 = SdpTypeFromJS(input.Get("type"))
	out.Type = value0
	value1 = (input.Get("sdp")).String()
	out.Sdp = value1
	return &out
}

// dictionary: RTCStats
type Stats struct {
	Timestamp float64
	Type      StatsType
	Id        string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *Stats) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Timestamp
	out.Set("timestamp", value0)
	value1 := _this.Type.JSValue()
	out.Set("type", value1)
	value2 := _this.Id
	out.Set("id", value2)
	return out
}

// StatsFromJS is allocating a new
// Stats object and copy all values from
// input javascript object
func StatsFromJS(value js.Wrapper) *Stats {
	input := value.JSValue()
	var out Stats
	var (
		value0 float64   // javascript: double {timestamp Timestamp timestamp}
		value1 StatsType // javascript: RTCStatsType {type Type _type}
		value2 string    // javascript: DOMString {id Id id}
	)
	value0 = (input.Get("timestamp")).Float()
	out.Timestamp = value0
	value1 = StatsTypeFromJS(input.Get("type"))
	out.Type = value1
	value2 = (input.Get("id")).String()
	out.Id = value2
	return &out
}

// dictionary: RTCStatsEventInit
type StatsEventInit struct {
	Bubbles    bool
	Cancelable bool
	Composed   bool
	Report     *StatsReport
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *StatsEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Report.JSValue()
	out.Set("report", value3)
	return out
}

// StatsEventInitFromJS is allocating a new
// StatsEventInit object and copy all values from
// input javascript object
func StatsEventInitFromJS(value js.Wrapper) *StatsEventInit {
	input := value.JSValue()
	var out StatsEventInit
	var (
		value0 bool         // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool         // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool         // javascript: boolean {composed Composed composed}
		value3 *StatsReport // javascript: RTCStatsReport {report Report report}
	)
	value0 = (input.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (input.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (input.Get("composed")).Bool()
	out.Composed = value2
	value3 = StatsReportFromJS(input.Get("report"))
	out.Report = value3
	return &out
}

// dictionary: RTCStatsReportEntryIteratorValue
type StatsReportEntryIteratorValue struct {
	Value []js.Value
	Done  bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *StatsReportEntryIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.Value))
	for __idx0, __seq_in0 := range _this.Value {
		__seq_out0 := __seq_in0
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// StatsReportEntryIteratorValueFromJS is allocating a new
// StatsReportEntryIteratorValue object and copy all values from
// input javascript object
func StatsReportEntryIteratorValueFromJS(value js.Wrapper) *StatsReportEntryIteratorValue {
	input := value.JSValue()
	var out StatsReportEntryIteratorValue
	var (
		value0 []js.Value // javascript: sequence<any> {value Value value}
		value1 bool       // javascript: boolean {done Done done}
	)
	__length0 := input.Get("value").Length()
	__array0 := make([]js.Value, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 js.Value
		__seq_in0 := input.Get("value").Index(__idx0)
		__seq_out0 = __seq_in0
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.Value = value0
	value1 = (input.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: RTCStatsReportKeyIteratorValue
type StatsReportKeyIteratorValue struct {
	Value string
	Done  bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *StatsReportKeyIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Value
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// StatsReportKeyIteratorValueFromJS is allocating a new
// StatsReportKeyIteratorValue object and copy all values from
// input javascript object
func StatsReportKeyIteratorValueFromJS(value js.Wrapper) *StatsReportKeyIteratorValue {
	input := value.JSValue()
	var out StatsReportKeyIteratorValue
	var (
		value0 string // javascript: DOMString {value Value value}
		value1 bool   // javascript: boolean {done Done done}
	)
	value0 = (input.Get("value")).String()
	out.Value = value0
	value1 = (input.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: RTCStatsReportValueIteratorValue
type StatsReportValueIteratorValue struct {
	Value *javascript.Object
	Done  bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *StatsReportValueIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Value.JSValue()
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// StatsReportValueIteratorValueFromJS is allocating a new
// StatsReportValueIteratorValue object and copy all values from
// input javascript object
func StatsReportValueIteratorValueFromJS(value js.Wrapper) *StatsReportValueIteratorValue {
	input := value.JSValue()
	var out StatsReportValueIteratorValue
	var (
		value0 *javascript.Object // javascript: object {value Value value}
		value1 bool               // javascript: boolean {done Done done}
	)
	value0 = javascript.ObjectFromJS(input.Get("value"))
	out.Value = value0
	value1 = (input.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: RTCTrackEventInit
type TrackEventInit struct {
	Bubbles     bool
	Cancelable  bool
	Composed    bool
	Receiver    *RtpReceiver
	Track       *local.MediaStreamTrack
	Streams     []*local.MediaStream
	Transceiver *RtpTransceiver
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *TrackEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Receiver.JSValue()
	out.Set("receiver", value3)
	value4 := _this.Track.JSValue()
	out.Set("track", value4)
	value5 := js.Global().Get("Array").New(len(_this.Streams))
	for __idx5, __seq_in5 := range _this.Streams {
		__seq_out5 := __seq_in5.JSValue()
		value5.SetIndex(__idx5, __seq_out5)
	}
	out.Set("streams", value5)
	value6 := _this.Transceiver.JSValue()
	out.Set("transceiver", value6)
	return out
}

// TrackEventInitFromJS is allocating a new
// TrackEventInit object and copy all values from
// input javascript object
func TrackEventInitFromJS(value js.Wrapper) *TrackEventInit {
	input := value.JSValue()
	var out TrackEventInit
	var (
		value0 bool                    // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool                    // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool                    // javascript: boolean {composed Composed composed}
		value3 *RtpReceiver            // javascript: RTCRtpReceiver {receiver Receiver receiver}
		value4 *local.MediaStreamTrack // javascript: MediaStreamTrack {track Track track}
		value5 []*local.MediaStream    // javascript: sequence<MediaStream> {streams Streams streams}
		value6 *RtpTransceiver         // javascript: RTCRtpTransceiver {transceiver Transceiver transceiver}
	)
	value0 = (input.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (input.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (input.Get("composed")).Bool()
	out.Composed = value2
	value3 = RtpReceiverFromJS(input.Get("receiver"))
	out.Receiver = value3
	value4 = local.MediaStreamTrackFromJS(input.Get("track"))
	out.Track = value4
	__length5 := input.Get("streams").Length()
	__array5 := make([]*local.MediaStream, __length5, __length5)
	for __idx5 := 0; __idx5 < __length5; __idx5++ {
		var __seq_out5 *local.MediaStream
		__seq_in5 := input.Get("streams").Index(__idx5)
		__seq_out5 = local.MediaStreamFromJS(__seq_in5)
		__array5[__idx5] = __seq_out5
	}
	value5 = __array5
	out.Streams = value5
	value6 = RtpTransceiverFromJS(input.Get("transceiver"))
	out.Transceiver = value6
	return &out
}

// class: RTCCertificate
type Certificate struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Certificate) JSValue() js.Value {
	return _this.Value_JS
}

// CertificateFromJS is casting a js.Wrapper into Certificate.
func CertificateFromJS(value js.Wrapper) *Certificate {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Certificate{}
	ret.Value_JS = input
	return ret
}

func GetSupportedAlgorithms() (_result []*Union) {
	_klass := js.Global().Get("RTCCertificate")
	_method := _klass.Get("getSupportedAlgorithms")
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted []*Union // javascript: sequence<Union> _what_return_name
	)
	__length0 := _returned.Length()
	__array0 := make([]*Union, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *Union
		__seq_in0 := _returned.Index(__idx0)
		__seq_out0 = UnionFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	_converted = __array0
	_result = _converted
	return
}

// Expires returning attribute 'expires' with
// type int (idl: unsigned long long).
func (_this *Certificate) Expires() int {
	var ret int
	value := _this.Value_JS.Get("expires")
	ret = (value).Int()
	return ret
}

func (_this *Certificate) GetFingerprints() (_result []*DtlsFingerprint) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getFingerprints", _args[0:_end]...)
	var (
		_converted []*DtlsFingerprint // javascript: sequence<RTCDtlsFingerprint> _what_return_name
	)
	__length0 := _returned.Length()
	__array0 := make([]*DtlsFingerprint, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *DtlsFingerprint
		__seq_in0 := _returned.Index(__idx0)
		__seq_out0 = DtlsFingerprintFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	_converted = __array0
	_result = _converted
	return
}

// class: RTCDTMFSender
type DTMFSender struct {
	domcore.EventTarget
}

// DTMFSenderFromJS is casting a js.Wrapper into DTMFSender.
func DTMFSenderFromJS(value js.Wrapper) *DTMFSender {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &DTMFSender{}
	ret.Value_JS = input
	return ret
}

// OnToneChange returning attribute 'ontonechange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *DTMFSender) OnToneChange() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("ontonechange")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// CanInsertDTMF returning attribute 'canInsertDTMF' with
// type bool (idl: boolean).
func (_this *DTMFSender) CanInsertDTMF() bool {
	var ret bool
	value := _this.Value_JS.Get("canInsertDTMF")
	ret = (value).Bool()
	return ret
}

// ToneBuffer returning attribute 'toneBuffer' with
// type string (idl: DOMString).
func (_this *DTMFSender) ToneBuffer() string {
	var ret string
	value := _this.Value_JS.Get("toneBuffer")
	ret = (value).String()
	return ret
}

// event attribute: DTMFToneChangeEvent
func eventFuncDTMFSender_DTMFToneChangeEvent(listener func(event *DTMFToneChangeEvent, target *DTMFSender)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *DTMFToneChangeEvent
		value := args[0]
		incoming := value.Get("target")
		ret = DTMFToneChangeEventFromJS(value)
		src := DTMFSenderFromJS(incoming)
		listener(ret, src)
		return js.Undefined
	}
	return js.FuncOf(fn)
}

// AddToneChange is adding doing AddEventListener for 'ToneChange' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *DTMFSender) AddEventToneChange(listener func(event *DTMFToneChangeEvent, currentTarget *DTMFSender)) js.Func {
	cb := eventFuncDTMFSender_DTMFToneChangeEvent(listener)
	_this.Value_JS.Call("addEventListener", "tonechange", cb)
	return cb
}

// SetOnToneChange is assigning a function to 'ontonechange'. This
// This method is returning allocated javascript function that need to be released.
func (_this *DTMFSender) SetOnToneChange(listener func(event *DTMFToneChangeEvent, currentTarget *DTMFSender)) js.Func {
	cb := eventFuncDTMFSender_DTMFToneChangeEvent(listener)
	_this.Value_JS.Set("ontonechange", cb)
	return cb
}

func (_this *DTMFSender) InsertDTMF(tones string, duration *uint, interToneGap *uint) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := tones
	_args[0] = _p0
	_end++
	if duration != nil {

		var _p1 interface{}
		if duration != nil {
			_p1 = *(duration)
		} else {
			_p1 = nil
		}
		_args[1] = _p1
		_end++
	}
	if interToneGap != nil {

		var _p2 interface{}
		if interToneGap != nil {
			_p2 = *(interToneGap)
		} else {
			_p2 = nil
		}
		_args[2] = _p2
		_end++
	}
	_this.Value_JS.Call("insertDTMF", _args[0:_end]...)
	return
}

// class: RTCDTMFToneChangeEvent
type DTMFToneChangeEvent struct {
	domcore.Event
}

// DTMFToneChangeEventFromJS is casting a js.Wrapper into DTMFToneChangeEvent.
func DTMFToneChangeEventFromJS(value js.Wrapper) *DTMFToneChangeEvent {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &DTMFToneChangeEvent{}
	ret.Value_JS = input
	return ret
}

func NewRTCDTMFToneChangeEvent(_type string, eventInitDict *DTMFToneChangeEventInit) (_result *DTMFToneChangeEvent) {
	_klass := js.Global().Get("RTCDTMFToneChangeEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := eventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *DTMFToneChangeEvent // javascript: RTCDTMFToneChangeEvent _what_return_name
	)
	_converted = DTMFToneChangeEventFromJS(_returned)
	_result = _converted
	return
}

// Tone returning attribute 'tone' with
// type string (idl: DOMString).
func (_this *DTMFToneChangeEvent) Tone() string {
	var ret string
	value := _this.Value_JS.Get("tone")
	ret = (value).String()
	return ret
}

// class: RTCDataChannel
type DataChannel struct {
	domcore.EventTarget
}

// DataChannelFromJS is casting a js.Wrapper into DataChannel.
func DataChannelFromJS(value js.Wrapper) *DataChannel {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &DataChannel{}
	ret.Value_JS = input
	return ret
}

// Label returning attribute 'label' with
// type string (idl: USVString).
func (_this *DataChannel) Label() string {
	var ret string
	value := _this.Value_JS.Get("label")
	ret = (value).String()
	return ret
}

// Ordered returning attribute 'ordered' with
// type bool (idl: boolean).
func (_this *DataChannel) Ordered() bool {
	var ret bool
	value := _this.Value_JS.Get("ordered")
	ret = (value).Bool()
	return ret
}

// MaxPacketLifeTime returning attribute 'maxPacketLifeTime' with
// type int (idl: unsigned short).
func (_this *DataChannel) MaxPacketLifeTime() *int {
	var ret *int
	value := _this.Value_JS.Get("maxPacketLifeTime")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Int()
		ret = &__tmp
	}
	return ret
}

// MaxRetransmits returning attribute 'maxRetransmits' with
// type int (idl: unsigned short).
func (_this *DataChannel) MaxRetransmits() *int {
	var ret *int
	value := _this.Value_JS.Get("maxRetransmits")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Int()
		ret = &__tmp
	}
	return ret
}

// Protocol returning attribute 'protocol' with
// type string (idl: USVString).
func (_this *DataChannel) Protocol() string {
	var ret string
	value := _this.Value_JS.Get("protocol")
	ret = (value).String()
	return ret
}

// Negotiated returning attribute 'negotiated' with
// type bool (idl: boolean).
func (_this *DataChannel) Negotiated() bool {
	var ret bool
	value := _this.Value_JS.Get("negotiated")
	ret = (value).Bool()
	return ret
}

// Id returning attribute 'id' with
// type int (idl: unsigned short).
func (_this *DataChannel) Id() *int {
	var ret *int
	value := _this.Value_JS.Get("id")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Int()
		ret = &__tmp
	}
	return ret
}

// Priority returning attribute 'priority' with
// type PriorityType (idl: RTCPriorityType).
func (_this *DataChannel) Priority() PriorityType {
	var ret PriorityType
	value := _this.Value_JS.Get("priority")
	ret = PriorityTypeFromJS(value)
	return ret
}

// ReadyState returning attribute 'readyState' with
// type DataChannelState (idl: RTCDataChannelState).
func (_this *DataChannel) ReadyState() DataChannelState {
	var ret DataChannelState
	value := _this.Value_JS.Get("readyState")
	ret = DataChannelStateFromJS(value)
	return ret
}

// BufferedAmount returning attribute 'bufferedAmount' with
// type uint (idl: unsigned long).
func (_this *DataChannel) BufferedAmount() uint {
	var ret uint
	value := _this.Value_JS.Get("bufferedAmount")
	ret = (uint)((value).Int())
	return ret
}

// BufferedAmountLowThreshold returning attribute 'bufferedAmountLowThreshold' with
// type uint (idl: unsigned long).
func (_this *DataChannel) BufferedAmountLowThreshold() uint {
	var ret uint
	value := _this.Value_JS.Get("bufferedAmountLowThreshold")
	ret = (uint)((value).Int())
	return ret
}

// SetBufferedAmountLowThreshold setting attribute 'bufferedAmountLowThreshold' with
// type uint (idl: unsigned long).
func (_this *DataChannel) SetBufferedAmountLowThreshold(value uint) {
	input := value
	_this.Value_JS.Set("bufferedAmountLowThreshold", input)
}

// OnOpen returning attribute 'onopen' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *DataChannel) OnOpen() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onopen")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnBufferedAmountLow returning attribute 'onbufferedamountlow' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *DataChannel) OnBufferedAmountLow() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onbufferedamountlow")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnError returning attribute 'onerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *DataChannel) OnError() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onerror")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnClose returning attribute 'onclose' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *DataChannel) OnClose() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onclose")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnMessage returning attribute 'onmessage' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *DataChannel) OnMessage() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onmessage")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// BinaryType returning attribute 'binaryType' with
// type string (idl: DOMString).
func (_this *DataChannel) BinaryType() string {
	var ret string
	value := _this.Value_JS.Get("binaryType")
	ret = (value).String()
	return ret
}

// SetBinaryType setting attribute 'binaryType' with
// type string (idl: DOMString).
func (_this *DataChannel) SetBinaryType(value string) {
	input := value
	_this.Value_JS.Set("binaryType", input)
}

// event attribute: domcore.Event
func eventFuncDataChannel_domcore_Event(listener func(event *domcore.Event, target *DataChannel)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *domcore.Event
		value := args[0]
		incoming := value.Get("target")
		ret = domcore.EventFromJS(value)
		src := DataChannelFromJS(incoming)
		listener(ret, src)
		return js.Undefined
	}
	return js.FuncOf(fn)
}

// AddBufferedAmountLow is adding doing AddEventListener for 'BufferedAmountLow' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *DataChannel) AddEventBufferedAmountLow(listener func(event *domcore.Event, currentTarget *DataChannel)) js.Func {
	cb := eventFuncDataChannel_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "bufferedamountlow", cb)
	return cb
}

// SetOnBufferedAmountLow is assigning a function to 'onbufferedamountlow'. This
// This method is returning allocated javascript function that need to be released.
func (_this *DataChannel) SetOnBufferedAmountLow(listener func(event *domcore.Event, currentTarget *DataChannel)) js.Func {
	cb := eventFuncDataChannel_domcore_Event(listener)
	_this.Value_JS.Set("onbufferedamountlow", cb)
	return cb
}

// AddClose is adding doing AddEventListener for 'Close' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *DataChannel) AddEventClose(listener func(event *domcore.Event, currentTarget *DataChannel)) js.Func {
	cb := eventFuncDataChannel_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "close", cb)
	return cb
}

// SetOnClose is assigning a function to 'onclose'. This
// This method is returning allocated javascript function that need to be released.
func (_this *DataChannel) SetOnClose(listener func(event *domcore.Event, currentTarget *DataChannel)) js.Func {
	cb := eventFuncDataChannel_domcore_Event(listener)
	_this.Value_JS.Set("onclose", cb)
	return cb
}

// event attribute: ErrorEvent
func eventFuncDataChannel_ErrorEvent(listener func(event *ErrorEvent, target *DataChannel)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *ErrorEvent
		value := args[0]
		incoming := value.Get("target")
		ret = ErrorEventFromJS(value)
		src := DataChannelFromJS(incoming)
		listener(ret, src)
		return js.Undefined
	}
	return js.FuncOf(fn)
}

// AddError is adding doing AddEventListener for 'Error' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *DataChannel) AddEventError(listener func(event *ErrorEvent, currentTarget *DataChannel)) js.Func {
	cb := eventFuncDataChannel_ErrorEvent(listener)
	_this.Value_JS.Call("addEventListener", "error", cb)
	return cb
}

// SetOnError is assigning a function to 'onerror'. This
// This method is returning allocated javascript function that need to be released.
func (_this *DataChannel) SetOnError(listener func(event *ErrorEvent, currentTarget *DataChannel)) js.Func {
	cb := eventFuncDataChannel_ErrorEvent(listener)
	_this.Value_JS.Set("onerror", cb)
	return cb
}

// event attribute: channel.MessageEvent
func eventFuncDataChannel_channel_MessageEvent(listener func(event *channel.MessageEvent, target *DataChannel)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *channel.MessageEvent
		value := args[0]
		incoming := value.Get("target")
		ret = channel.MessageEventFromJS(value)
		src := DataChannelFromJS(incoming)
		listener(ret, src)
		return js.Undefined
	}
	return js.FuncOf(fn)
}

// AddMessage is adding doing AddEventListener for 'Message' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *DataChannel) AddEventMessage(listener func(event *channel.MessageEvent, currentTarget *DataChannel)) js.Func {
	cb := eventFuncDataChannel_channel_MessageEvent(listener)
	_this.Value_JS.Call("addEventListener", "message", cb)
	return cb
}

// SetOnMessage is assigning a function to 'onmessage'. This
// This method is returning allocated javascript function that need to be released.
func (_this *DataChannel) SetOnMessage(listener func(event *channel.MessageEvent, currentTarget *DataChannel)) js.Func {
	cb := eventFuncDataChannel_channel_MessageEvent(listener)
	_this.Value_JS.Set("onmessage", cb)
	return cb
}

// AddOpen is adding doing AddEventListener for 'Open' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *DataChannel) AddEventOpen(listener func(event *domcore.Event, currentTarget *DataChannel)) js.Func {
	cb := eventFuncDataChannel_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "open", cb)
	return cb
}

// SetOnOpen is assigning a function to 'onopen'. This
// This method is returning allocated javascript function that need to be released.
func (_this *DataChannel) SetOnOpen(listener func(event *domcore.Event, currentTarget *DataChannel)) js.Func {
	cb := eventFuncDataChannel_domcore_Event(listener)
	_this.Value_JS.Set("onopen", cb)
	return cb
}

func (_this *DataChannel) Close() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("close", _args[0:_end]...)
	return
}

func (_this *DataChannel) Send(data string) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := data
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("send", _args[0:_end]...)
	return
}

func (_this *DataChannel) Send2(data *file.Blob) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := data.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("send", _args[0:_end]...)
	return
}

func (_this *DataChannel) Send3(data *javascript.ArrayBuffer) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := data.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("send", _args[0:_end]...)
	return
}

func (_this *DataChannel) Send4(data *Union) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := data.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("send", _args[0:_end]...)
	return
}

// class: RTCDataChannelEvent
type DataChannelEvent struct {
	domcore.Event
}

// DataChannelEventFromJS is casting a js.Wrapper into DataChannelEvent.
func DataChannelEventFromJS(value js.Wrapper) *DataChannelEvent {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &DataChannelEvent{}
	ret.Value_JS = input
	return ret
}

func NewRTCDataChannelEvent(_type string, eventInitDict *DataChannelEventInit) (_result *DataChannelEvent) {
	_klass := js.Global().Get("RTCDataChannelEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := eventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *DataChannelEvent // javascript: RTCDataChannelEvent _what_return_name
	)
	_converted = DataChannelEventFromJS(_returned)
	_result = _converted
	return
}

// Channel returning attribute 'channel' with
// type DataChannel (idl: RTCDataChannel).
func (_this *DataChannelEvent) Channel() *DataChannel {
	var ret *DataChannel
	value := _this.Value_JS.Get("channel")
	ret = DataChannelFromJS(value)
	return ret
}

// class: RTCDtlsTransport
type DtlsTransport struct {
	domcore.EventTarget
}

// DtlsTransportFromJS is casting a js.Wrapper into DtlsTransport.
func DtlsTransportFromJS(value js.Wrapper) *DtlsTransport {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &DtlsTransport{}
	ret.Value_JS = input
	return ret
}

// IceTransport returning attribute 'iceTransport' with
// type IceTransport (idl: RTCIceTransport).
func (_this *DtlsTransport) IceTransport() *IceTransport {
	var ret *IceTransport
	value := _this.Value_JS.Get("iceTransport")
	ret = IceTransportFromJS(value)
	return ret
}

// State returning attribute 'state' with
// type DtlsTransportState (idl: RTCDtlsTransportState).
func (_this *DtlsTransport) State() DtlsTransportState {
	var ret DtlsTransportState
	value := _this.Value_JS.Get("state")
	ret = DtlsTransportStateFromJS(value)
	return ret
}

// OnStateChange returning attribute 'onstatechange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *DtlsTransport) OnStateChange() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onstatechange")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnError returning attribute 'onerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *DtlsTransport) OnError() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onerror")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// event attribute: ErrorEvent
func eventFuncDtlsTransport_ErrorEvent(listener func(event *ErrorEvent, target *DtlsTransport)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *ErrorEvent
		value := args[0]
		incoming := value.Get("target")
		ret = ErrorEventFromJS(value)
		src := DtlsTransportFromJS(incoming)
		listener(ret, src)
		return js.Undefined
	}
	return js.FuncOf(fn)
}

// AddError is adding doing AddEventListener for 'Error' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *DtlsTransport) AddEventError(listener func(event *ErrorEvent, currentTarget *DtlsTransport)) js.Func {
	cb := eventFuncDtlsTransport_ErrorEvent(listener)
	_this.Value_JS.Call("addEventListener", "error", cb)
	return cb
}

// SetOnError is assigning a function to 'onerror'. This
// This method is returning allocated javascript function that need to be released.
func (_this *DtlsTransport) SetOnError(listener func(event *ErrorEvent, currentTarget *DtlsTransport)) js.Func {
	cb := eventFuncDtlsTransport_ErrorEvent(listener)
	_this.Value_JS.Set("onerror", cb)
	return cb
}

// event attribute: domcore.Event
func eventFuncDtlsTransport_domcore_Event(listener func(event *domcore.Event, target *DtlsTransport)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *domcore.Event
		value := args[0]
		incoming := value.Get("target")
		ret = domcore.EventFromJS(value)
		src := DtlsTransportFromJS(incoming)
		listener(ret, src)
		return js.Undefined
	}
	return js.FuncOf(fn)
}

// AddStateChange is adding doing AddEventListener for 'StateChange' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *DtlsTransport) AddEventStateChange(listener func(event *domcore.Event, currentTarget *DtlsTransport)) js.Func {
	cb := eventFuncDtlsTransport_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "statechange", cb)
	return cb
}

// SetOnStateChange is assigning a function to 'onstatechange'. This
// This method is returning allocated javascript function that need to be released.
func (_this *DtlsTransport) SetOnStateChange(listener func(event *domcore.Event, currentTarget *DtlsTransport)) js.Func {
	cb := eventFuncDtlsTransport_domcore_Event(listener)
	_this.Value_JS.Set("onstatechange", cb)
	return cb
}

func (_this *DtlsTransport) GetRemoteCertificates() (_result []*javascript.ArrayBuffer) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getRemoteCertificates", _args[0:_end]...)
	var (
		_converted []*javascript.ArrayBuffer // javascript: sequence<ArrayBuffer> _what_return_name
	)
	__length0 := _returned.Length()
	__array0 := make([]*javascript.ArrayBuffer, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *javascript.ArrayBuffer
		__seq_in0 := _returned.Index(__idx0)
		__seq_out0 = javascript.ArrayBufferFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	_converted = __array0
	_result = _converted
	return
}

// class: RTCError
type Error struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Error) JSValue() js.Value {
	return _this.Value_JS
}

// ErrorFromJS is casting a js.Wrapper into Error.
func ErrorFromJS(value js.Wrapper) *Error {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Error{}
	ret.Value_JS = input
	return ret
}

// class: RTCErrorEvent
type ErrorEvent struct {
	domcore.Event
}

// ErrorEventFromJS is casting a js.Wrapper into ErrorEvent.
func ErrorEventFromJS(value js.Wrapper) *ErrorEvent {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &ErrorEvent{}
	ret.Value_JS = input
	return ret
}

func NewRTCErrorEvent(_type string, eventInitDict *ErrorEventInit) (_result *ErrorEvent) {
	_klass := js.Global().Get("RTCErrorEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := eventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *ErrorEvent // javascript: RTCErrorEvent _what_return_name
	)
	_converted = ErrorEventFromJS(_returned)
	_result = _converted
	return
}

// Error returning attribute 'error' with
// type Error (idl: RTCError).
func (_this *ErrorEvent) Error() *Error {
	var ret *Error
	value := _this.Value_JS.Get("error")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = ErrorFromJS(value)
	}
	return ret
}

// class: RTCIceCandidate
type IceCandidate struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *IceCandidate) JSValue() js.Value {
	return _this.Value_JS
}

// IceCandidateFromJS is casting a js.Wrapper into IceCandidate.
func IceCandidateFromJS(value js.Wrapper) *IceCandidate {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &IceCandidate{}
	ret.Value_JS = input
	return ret
}

func NewRTCIceCandidate(candidateInitDict *IceCandidateInit) (_result *IceCandidate) {
	_klass := js.Global().Get("RTCIceCandidate")
	var (
		_args [1]interface{}
		_end  int
	)
	if candidateInitDict != nil {
		_p0 := candidateInitDict.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *IceCandidate // javascript: RTCIceCandidate _what_return_name
	)
	_converted = IceCandidateFromJS(_returned)
	_result = _converted
	return
}

// Candidate returning attribute 'candidate' with
// type string (idl: DOMString).
func (_this *IceCandidate) Candidate() string {
	var ret string
	value := _this.Value_JS.Get("candidate")
	ret = (value).String()
	return ret
}

// SdpMid returning attribute 'sdpMid' with
// type string (idl: DOMString).
func (_this *IceCandidate) SdpMid() *string {
	var ret *string
	value := _this.Value_JS.Get("sdpMid")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).String()
		ret = &__tmp
	}
	return ret
}

// SdpMLineIndex returning attribute 'sdpMLineIndex' with
// type int (idl: unsigned short).
func (_this *IceCandidate) SdpMLineIndex() *int {
	var ret *int
	value := _this.Value_JS.Get("sdpMLineIndex")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Int()
		ret = &__tmp
	}
	return ret
}

// Foundation returning attribute 'foundation' with
// type string (idl: DOMString).
func (_this *IceCandidate) Foundation() *string {
	var ret *string
	value := _this.Value_JS.Get("foundation")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).String()
		ret = &__tmp
	}
	return ret
}

// Component returning attribute 'component' with
// type IceComponent (idl: RTCIceComponent).
func (_this *IceCandidate) Component() *IceComponent {
	var ret *IceComponent
	value := _this.Value_JS.Get("component")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := IceComponentFromJS(value)
		ret = &__tmp
	}
	return ret
}

// Priority returning attribute 'priority' with
// type uint (idl: unsigned long).
func (_this *IceCandidate) Priority() *uint {
	var ret *uint
	value := _this.Value_JS.Get("priority")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (uint)((value).Int())
		ret = &__tmp
	}
	return ret
}

// Address returning attribute 'address' with
// type string (idl: DOMString).
func (_this *IceCandidate) Address() *string {
	var ret *string
	value := _this.Value_JS.Get("address")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).String()
		ret = &__tmp
	}
	return ret
}

// Protocol returning attribute 'protocol' with
// type IceProtocol (idl: RTCIceProtocol).
func (_this *IceCandidate) Protocol() *IceProtocol {
	var ret *IceProtocol
	value := _this.Value_JS.Get("protocol")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := IceProtocolFromJS(value)
		ret = &__tmp
	}
	return ret
}

// Port returning attribute 'port' with
// type int (idl: unsigned short).
func (_this *IceCandidate) Port() *int {
	var ret *int
	value := _this.Value_JS.Get("port")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Int()
		ret = &__tmp
	}
	return ret
}

// Type returning attribute 'type' with
// type IceCandidateType (idl: RTCIceCandidateType).
func (_this *IceCandidate) Type() *IceCandidateType {
	var ret *IceCandidateType
	value := _this.Value_JS.Get("type")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := IceCandidateTypeFromJS(value)
		ret = &__tmp
	}
	return ret
}

// TcpType returning attribute 'tcpType' with
// type IceTcpCandidateType (idl: RTCIceTcpCandidateType).
func (_this *IceCandidate) TcpType() *IceTcpCandidateType {
	var ret *IceTcpCandidateType
	value := _this.Value_JS.Get("tcpType")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := IceTcpCandidateTypeFromJS(value)
		ret = &__tmp
	}
	return ret
}

// RelatedAddress returning attribute 'relatedAddress' with
// type string (idl: DOMString).
func (_this *IceCandidate) RelatedAddress() *string {
	var ret *string
	value := _this.Value_JS.Get("relatedAddress")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).String()
		ret = &__tmp
	}
	return ret
}

// RelatedPort returning attribute 'relatedPort' with
// type int (idl: unsigned short).
func (_this *IceCandidate) RelatedPort() *int {
	var ret *int
	value := _this.Value_JS.Get("relatedPort")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Int()
		ret = &__tmp
	}
	return ret
}

// UsernameFragment returning attribute 'usernameFragment' with
// type string (idl: DOMString).
func (_this *IceCandidate) UsernameFragment() *string {
	var ret *string
	value := _this.Value_JS.Get("usernameFragment")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).String()
		ret = &__tmp
	}
	return ret
}

func (_this *IceCandidate) ToJSON() (_result *IceCandidateInit) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("toJSON", _args[0:_end]...)
	var (
		_converted *IceCandidateInit // javascript: RTCIceCandidateInit _what_return_name
	)
	_converted = IceCandidateInitFromJS(_returned)
	_result = _converted
	return
}

// class: RTCIceTransport
type IceTransport struct {
	domcore.EventTarget
}

// IceTransportFromJS is casting a js.Wrapper into IceTransport.
func IceTransportFromJS(value js.Wrapper) *IceTransport {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &IceTransport{}
	ret.Value_JS = input
	return ret
}

// Role returning attribute 'role' with
// type IceRole (idl: RTCIceRole).
func (_this *IceTransport) Role() IceRole {
	var ret IceRole
	value := _this.Value_JS.Get("role")
	ret = IceRoleFromJS(value)
	return ret
}

// Component returning attribute 'component' with
// type IceComponent (idl: RTCIceComponent).
func (_this *IceTransport) Component() IceComponent {
	var ret IceComponent
	value := _this.Value_JS.Get("component")
	ret = IceComponentFromJS(value)
	return ret
}

// State returning attribute 'state' with
// type IceTransportState (idl: RTCIceTransportState).
func (_this *IceTransport) State() IceTransportState {
	var ret IceTransportState
	value := _this.Value_JS.Get("state")
	ret = IceTransportStateFromJS(value)
	return ret
}

// GatheringState returning attribute 'gatheringState' with
// type IceGathererState (idl: RTCIceGathererState).
func (_this *IceTransport) GatheringState() IceGathererState {
	var ret IceGathererState
	value := _this.Value_JS.Get("gatheringState")
	ret = IceGathererStateFromJS(value)
	return ret
}

// OnStateChange returning attribute 'onstatechange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *IceTransport) OnStateChange() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onstatechange")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnGatheringStateChange returning attribute 'ongatheringstatechange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *IceTransport) OnGatheringStateChange() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("ongatheringstatechange")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnSelectedCandidatePairChange returning attribute 'onselectedcandidatepairchange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *IceTransport) OnSelectedCandidatePairChange() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onselectedcandidatepairchange")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// event attribute: domcore.Event
func eventFuncIceTransport_domcore_Event(listener func(event *domcore.Event, target *IceTransport)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *domcore.Event
		value := args[0]
		incoming := value.Get("target")
		ret = domcore.EventFromJS(value)
		src := IceTransportFromJS(incoming)
		listener(ret, src)
		return js.Undefined
	}
	return js.FuncOf(fn)
}

// AddGatheringStateChange is adding doing AddEventListener for 'GatheringStateChange' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *IceTransport) AddEventGatheringStateChange(listener func(event *domcore.Event, currentTarget *IceTransport)) js.Func {
	cb := eventFuncIceTransport_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "gatheringstatechange", cb)
	return cb
}

// SetOnGatheringStateChange is assigning a function to 'ongatheringstatechange'. This
// This method is returning allocated javascript function that need to be released.
func (_this *IceTransport) SetOnGatheringStateChange(listener func(event *domcore.Event, currentTarget *IceTransport)) js.Func {
	cb := eventFuncIceTransport_domcore_Event(listener)
	_this.Value_JS.Set("ongatheringstatechange", cb)
	return cb
}

// AddSelectedCandidatePairChange is adding doing AddEventListener for 'SelectedCandidatePairChange' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *IceTransport) AddEventSelectedCandidatePairChange(listener func(event *domcore.Event, currentTarget *IceTransport)) js.Func {
	cb := eventFuncIceTransport_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "selectedcandidatepairchange", cb)
	return cb
}

// SetOnSelectedCandidatePairChange is assigning a function to 'onselectedcandidatepairchange'. This
// This method is returning allocated javascript function that need to be released.
func (_this *IceTransport) SetOnSelectedCandidatePairChange(listener func(event *domcore.Event, currentTarget *IceTransport)) js.Func {
	cb := eventFuncIceTransport_domcore_Event(listener)
	_this.Value_JS.Set("onselectedcandidatepairchange", cb)
	return cb
}

// AddStateChange is adding doing AddEventListener for 'StateChange' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *IceTransport) AddEventStateChange(listener func(event *domcore.Event, currentTarget *IceTransport)) js.Func {
	cb := eventFuncIceTransport_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "statechange", cb)
	return cb
}

// SetOnStateChange is assigning a function to 'onstatechange'. This
// This method is returning allocated javascript function that need to be released.
func (_this *IceTransport) SetOnStateChange(listener func(event *domcore.Event, currentTarget *IceTransport)) js.Func {
	cb := eventFuncIceTransport_domcore_Event(listener)
	_this.Value_JS.Set("onstatechange", cb)
	return cb
}

func (_this *IceTransport) GetLocalCandidates() (_result []*IceCandidate) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getLocalCandidates", _args[0:_end]...)
	var (
		_converted []*IceCandidate // javascript: sequence<RTCIceCandidate> _what_return_name
	)
	__length0 := _returned.Length()
	__array0 := make([]*IceCandidate, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *IceCandidate
		__seq_in0 := _returned.Index(__idx0)
		__seq_out0 = IceCandidateFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	_converted = __array0
	_result = _converted
	return
}

func (_this *IceTransport) GetRemoteCandidates() (_result []*IceCandidate) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getRemoteCandidates", _args[0:_end]...)
	var (
		_converted []*IceCandidate // javascript: sequence<RTCIceCandidate> _what_return_name
	)
	__length0 := _returned.Length()
	__array0 := make([]*IceCandidate, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *IceCandidate
		__seq_in0 := _returned.Index(__idx0)
		__seq_out0 = IceCandidateFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	_converted = __array0
	_result = _converted
	return
}

func (_this *IceTransport) GetSelectedCandidatePair() (_result *IceCandidatePair) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getSelectedCandidatePair", _args[0:_end]...)
	var (
		_converted *IceCandidatePair // javascript: RTCIceCandidatePair _what_return_name
	)
	if _returned.Type() != js.TypeNull && _returned.Type() != js.TypeUndefined {
		_converted = IceCandidatePairFromJS(_returned)
	}
	_result = _converted
	return
}

func (_this *IceTransport) GetLocalParameters() (_result *IceParameters) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getLocalParameters", _args[0:_end]...)
	var (
		_converted *IceParameters // javascript: RTCIceParameters _what_return_name
	)
	if _returned.Type() != js.TypeNull && _returned.Type() != js.TypeUndefined {
		_converted = IceParametersFromJS(_returned)
	}
	_result = _converted
	return
}

func (_this *IceTransport) GetRemoteParameters() (_result *IceParameters) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getRemoteParameters", _args[0:_end]...)
	var (
		_converted *IceParameters // javascript: RTCIceParameters _what_return_name
	)
	if _returned.Type() != js.TypeNull && _returned.Type() != js.TypeUndefined {
		_converted = IceParametersFromJS(_returned)
	}
	_result = _converted
	return
}

// class: RTCPeerConnection
type PeerConnection struct {
	domcore.EventTarget
}

// PeerConnectionFromJS is casting a js.Wrapper into PeerConnection.
func PeerConnectionFromJS(value js.Wrapper) *PeerConnection {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PeerConnection{}
	ret.Value_JS = input
	return ret
}

func GetDefaultIceServers() (_result []*IceServer) {
	_klass := js.Global().Get("RTCPeerConnection")
	_method := _klass.Get("getDefaultIceServers")
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted []*IceServer // javascript: sequence<RTCIceServer> _what_return_name
	)
	__length0 := _returned.Length()
	__array0 := make([]*IceServer, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *IceServer
		__seq_in0 := _returned.Index(__idx0)
		__seq_out0 = IceServerFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	_converted = __array0
	_result = _converted
	return
}

func GenerateCertificate(keygenAlgorithm *Union) (_result *PromiseCertificate) {
	_klass := js.Global().Get("RTCPeerConnection")
	_method := _klass.Get("generateCertificate")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := keygenAlgorithm.JSValue()
	_args[0] = _p0
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted *PromiseCertificate // javascript: Promise _what_return_name
	)
	_converted = PromiseCertificateFromJS(_returned)
	_result = _converted
	return
}

func NewRTCPeerConnection(configuration *Configuration) (_result *PeerConnection) {
	_klass := js.Global().Get("RTCPeerConnection")
	var (
		_args [1]interface{}
		_end  int
	)
	if configuration != nil {
		_p0 := configuration.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *PeerConnection // javascript: RTCPeerConnection _what_return_name
	)
	_converted = PeerConnectionFromJS(_returned)
	_result = _converted
	return
}

// LocalDescription returning attribute 'localDescription' with
// type SessionDescription (idl: RTCSessionDescription).
func (_this *PeerConnection) LocalDescription() *SessionDescription {
	var ret *SessionDescription
	value := _this.Value_JS.Get("localDescription")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = SessionDescriptionFromJS(value)
	}
	return ret
}

// CurrentLocalDescription returning attribute 'currentLocalDescription' with
// type SessionDescription (idl: RTCSessionDescription).
func (_this *PeerConnection) CurrentLocalDescription() *SessionDescription {
	var ret *SessionDescription
	value := _this.Value_JS.Get("currentLocalDescription")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = SessionDescriptionFromJS(value)
	}
	return ret
}

// PendingLocalDescription returning attribute 'pendingLocalDescription' with
// type SessionDescription (idl: RTCSessionDescription).
func (_this *PeerConnection) PendingLocalDescription() *SessionDescription {
	var ret *SessionDescription
	value := _this.Value_JS.Get("pendingLocalDescription")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = SessionDescriptionFromJS(value)
	}
	return ret
}

// RemoteDescription returning attribute 'remoteDescription' with
// type SessionDescription (idl: RTCSessionDescription).
func (_this *PeerConnection) RemoteDescription() *SessionDescription {
	var ret *SessionDescription
	value := _this.Value_JS.Get("remoteDescription")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = SessionDescriptionFromJS(value)
	}
	return ret
}

// CurrentRemoteDescription returning attribute 'currentRemoteDescription' with
// type SessionDescription (idl: RTCSessionDescription).
func (_this *PeerConnection) CurrentRemoteDescription() *SessionDescription {
	var ret *SessionDescription
	value := _this.Value_JS.Get("currentRemoteDescription")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = SessionDescriptionFromJS(value)
	}
	return ret
}

// PendingRemoteDescription returning attribute 'pendingRemoteDescription' with
// type SessionDescription (idl: RTCSessionDescription).
func (_this *PeerConnection) PendingRemoteDescription() *SessionDescription {
	var ret *SessionDescription
	value := _this.Value_JS.Get("pendingRemoteDescription")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = SessionDescriptionFromJS(value)
	}
	return ret
}

// SignalingState returning attribute 'signalingState' with
// type SignalingState (idl: RTCSignalingState).
func (_this *PeerConnection) SignalingState() SignalingState {
	var ret SignalingState
	value := _this.Value_JS.Get("signalingState")
	ret = SignalingStateFromJS(value)
	return ret
}

// IceGatheringState returning attribute 'iceGatheringState' with
// type IceGatheringState (idl: RTCIceGatheringState).
func (_this *PeerConnection) IceGatheringState() IceGatheringState {
	var ret IceGatheringState
	value := _this.Value_JS.Get("iceGatheringState")
	ret = IceGatheringStateFromJS(value)
	return ret
}

// IceConnectionState returning attribute 'iceConnectionState' with
// type IceConnectionState (idl: RTCIceConnectionState).
func (_this *PeerConnection) IceConnectionState() IceConnectionState {
	var ret IceConnectionState
	value := _this.Value_JS.Get("iceConnectionState")
	ret = IceConnectionStateFromJS(value)
	return ret
}

// ConnectionState returning attribute 'connectionState' with
// type PeerConnectionState (idl: RTCPeerConnectionState).
func (_this *PeerConnection) ConnectionState() PeerConnectionState {
	var ret PeerConnectionState
	value := _this.Value_JS.Get("connectionState")
	ret = PeerConnectionStateFromJS(value)
	return ret
}

// CanTrickleIceCandidates returning attribute 'canTrickleIceCandidates' with
// type bool (idl: boolean).
func (_this *PeerConnection) CanTrickleIceCandidates() *bool {
	var ret *bool
	value := _this.Value_JS.Get("canTrickleIceCandidates")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Bool()
		ret = &__tmp
	}
	return ret
}

// OnNegotiationNeeded returning attribute 'onnegotiationneeded' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *PeerConnection) OnNegotiationNeeded() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onnegotiationneeded")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnIceCandidate returning attribute 'onicecandidate' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *PeerConnection) OnIceCandidate() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onicecandidate")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnIceCandidateError returning attribute 'onicecandidateerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *PeerConnection) OnIceCandidateError() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onicecandidateerror")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnSignalingStateChange returning attribute 'onsignalingstatechange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *PeerConnection) OnSignalingStateChange() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onsignalingstatechange")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnIceConnectionStateChange returning attribute 'oniceconnectionstatechange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *PeerConnection) OnIceConnectionStateChange() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("oniceconnectionstatechange")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnIceGatheringStateChange returning attribute 'onicegatheringstatechange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *PeerConnection) OnIceGatheringStateChange() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onicegatheringstatechange")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnConnectionStateChange returning attribute 'onconnectionstatechange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *PeerConnection) OnConnectionStateChange() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onconnectionstatechange")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnTrack returning attribute 'ontrack' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *PeerConnection) OnTrack() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("ontrack")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// Sctp returning attribute 'sctp' with
// type SctpTransport (idl: RTCSctpTransport).
func (_this *PeerConnection) Sctp() *SctpTransport {
	var ret *SctpTransport
	value := _this.Value_JS.Get("sctp")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = SctpTransportFromJS(value)
	}
	return ret
}

// OnDataChannel returning attribute 'ondatachannel' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *PeerConnection) OnDataChannel() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("ondatachannel")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnStatsEnded returning attribute 'onstatsended' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *PeerConnection) OnStatsEnded() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onstatsended")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// event attribute: domcore.Event
func eventFuncPeerConnection_domcore_Event(listener func(event *domcore.Event, target *PeerConnection)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *domcore.Event
		value := args[0]
		incoming := value.Get("target")
		ret = domcore.EventFromJS(value)
		src := PeerConnectionFromJS(incoming)
		listener(ret, src)
		return js.Undefined
	}
	return js.FuncOf(fn)
}

// AddConnectionStateChange is adding doing AddEventListener for 'ConnectionStateChange' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) AddEventConnectionStateChange(listener func(event *domcore.Event, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "connectionstatechange", cb)
	return cb
}

// SetOnConnectionStateChange is assigning a function to 'onconnectionstatechange'. This
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) SetOnConnectionStateChange(listener func(event *domcore.Event, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_domcore_Event(listener)
	_this.Value_JS.Set("onconnectionstatechange", cb)
	return cb
}

// event attribute: DataChannelEvent
func eventFuncPeerConnection_DataChannelEvent(listener func(event *DataChannelEvent, target *PeerConnection)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *DataChannelEvent
		value := args[0]
		incoming := value.Get("target")
		ret = DataChannelEventFromJS(value)
		src := PeerConnectionFromJS(incoming)
		listener(ret, src)
		return js.Undefined
	}
	return js.FuncOf(fn)
}

// AddDataChannel is adding doing AddEventListener for 'DataChannel' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) AddEventDataChannel(listener func(event *DataChannelEvent, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_DataChannelEvent(listener)
	_this.Value_JS.Call("addEventListener", "datachannel", cb)
	return cb
}

// SetOnDataChannel is assigning a function to 'ondatachannel'. This
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) SetOnDataChannel(listener func(event *DataChannelEvent, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_DataChannelEvent(listener)
	_this.Value_JS.Set("ondatachannel", cb)
	return cb
}

// event attribute: PeerConnectionIceEvent
func eventFuncPeerConnection_PeerConnectionIceEvent(listener func(event *PeerConnectionIceEvent, target *PeerConnection)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *PeerConnectionIceEvent
		value := args[0]
		incoming := value.Get("target")
		ret = PeerConnectionIceEventFromJS(value)
		src := PeerConnectionFromJS(incoming)
		listener(ret, src)
		return js.Undefined
	}
	return js.FuncOf(fn)
}

// AddIceCandidate is adding doing AddEventListener for 'IceCandidate' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) AddEventIceCandidate(listener func(event *PeerConnectionIceEvent, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_PeerConnectionIceEvent(listener)
	_this.Value_JS.Call("addEventListener", "icecandidate", cb)
	return cb
}

// SetOnIceCandidate is assigning a function to 'onicecandidate'. This
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) SetOnIceCandidate(listener func(event *PeerConnectionIceEvent, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_PeerConnectionIceEvent(listener)
	_this.Value_JS.Set("onicecandidate", cb)
	return cb
}

// event attribute: PeerConnectionIceErrorEvent
func eventFuncPeerConnection_PeerConnectionIceErrorEvent(listener func(event *PeerConnectionIceErrorEvent, target *PeerConnection)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *PeerConnectionIceErrorEvent
		value := args[0]
		incoming := value.Get("target")
		ret = PeerConnectionIceErrorEventFromJS(value)
		src := PeerConnectionFromJS(incoming)
		listener(ret, src)
		return js.Undefined
	}
	return js.FuncOf(fn)
}

// AddIceCandidateError is adding doing AddEventListener for 'IceCandidateError' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) AddEventIceCandidateError(listener func(event *PeerConnectionIceErrorEvent, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_PeerConnectionIceErrorEvent(listener)
	_this.Value_JS.Call("addEventListener", "icecandidateerror", cb)
	return cb
}

// SetOnIceCandidateError is assigning a function to 'onicecandidateerror'. This
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) SetOnIceCandidateError(listener func(event *PeerConnectionIceErrorEvent, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_PeerConnectionIceErrorEvent(listener)
	_this.Value_JS.Set("onicecandidateerror", cb)
	return cb
}

// AddIceConnectionStateChange is adding doing AddEventListener for 'IceConnectionStateChange' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) AddEventIceConnectionStateChange(listener func(event *domcore.Event, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "iceconnectionstatechange", cb)
	return cb
}

// SetOnIceConnectionStateChange is assigning a function to 'oniceconnectionstatechange'. This
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) SetOnIceConnectionStateChange(listener func(event *domcore.Event, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_domcore_Event(listener)
	_this.Value_JS.Set("oniceconnectionstatechange", cb)
	return cb
}

// AddIceGatheringStateChange is adding doing AddEventListener for 'IceGatheringStateChange' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) AddEventIceGatheringStateChange(listener func(event *domcore.Event, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "icegatheringstatechange", cb)
	return cb
}

// SetOnIceGatheringStateChange is assigning a function to 'onicegatheringstatechange'. This
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) SetOnIceGatheringStateChange(listener func(event *domcore.Event, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_domcore_Event(listener)
	_this.Value_JS.Set("onicegatheringstatechange", cb)
	return cb
}

// AddNegotiationNeeded is adding doing AddEventListener for 'NegotiationNeeded' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) AddEventNegotiationNeeded(listener func(event *domcore.Event, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "negotiationneeded", cb)
	return cb
}

// SetOnNegotiationNeeded is assigning a function to 'onnegotiationneeded'. This
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) SetOnNegotiationNeeded(listener func(event *domcore.Event, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_domcore_Event(listener)
	_this.Value_JS.Set("onnegotiationneeded", cb)
	return cb
}

// AddSignalingStateChange is adding doing AddEventListener for 'SignalingStateChange' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) AddEventSignalingStateChange(listener func(event *domcore.Event, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "signalingstatechange", cb)
	return cb
}

// SetOnSignalingStateChange is assigning a function to 'onsignalingstatechange'. This
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) SetOnSignalingStateChange(listener func(event *domcore.Event, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_domcore_Event(listener)
	_this.Value_JS.Set("onsignalingstatechange", cb)
	return cb
}

// event attribute: StatsEvent
func eventFuncPeerConnection_StatsEvent(listener func(event *StatsEvent, target *PeerConnection)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *StatsEvent
		value := args[0]
		incoming := value.Get("target")
		ret = StatsEventFromJS(value)
		src := PeerConnectionFromJS(incoming)
		listener(ret, src)
		return js.Undefined
	}
	return js.FuncOf(fn)
}

// AddStatsEnded is adding doing AddEventListener for 'StatsEnded' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) AddEventStatsEnded(listener func(event *StatsEvent, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_StatsEvent(listener)
	_this.Value_JS.Call("addEventListener", "statsended", cb)
	return cb
}

// SetOnStatsEnded is assigning a function to 'onstatsended'. This
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) SetOnStatsEnded(listener func(event *StatsEvent, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_StatsEvent(listener)
	_this.Value_JS.Set("onstatsended", cb)
	return cb
}

// event attribute: TrackEvent
func eventFuncPeerConnection_TrackEvent(listener func(event *TrackEvent, target *PeerConnection)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *TrackEvent
		value := args[0]
		incoming := value.Get("target")
		ret = TrackEventFromJS(value)
		src := PeerConnectionFromJS(incoming)
		listener(ret, src)
		return js.Undefined
	}
	return js.FuncOf(fn)
}

// AddTrack is adding doing AddEventListener for 'Track' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) AddEventTrack(listener func(event *TrackEvent, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_TrackEvent(listener)
	_this.Value_JS.Call("addEventListener", "track", cb)
	return cb
}

// SetOnTrack is assigning a function to 'ontrack'. This
// This method is returning allocated javascript function that need to be released.
func (_this *PeerConnection) SetOnTrack(listener func(event *TrackEvent, currentTarget *PeerConnection)) js.Func {
	cb := eventFuncPeerConnection_TrackEvent(listener)
	_this.Value_JS.Set("ontrack", cb)
	return cb
}

func (_this *PeerConnection) CreateOffer(options *OfferOptions) (_result *PromiseSessionDescriptionInit) {
	var (
		_args [1]interface{}
		_end  int
	)
	if options != nil {
		_p0 := options.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _this.Value_JS.Call("createOffer", _args[0:_end]...)
	var (
		_converted *PromiseSessionDescriptionInit // javascript: Promise _what_return_name
	)
	_converted = PromiseSessionDescriptionInitFromJS(_returned)
	_result = _converted
	return
}

func (_this *PeerConnection) CreateAnswer(options *AnswerOptions) (_result *PromiseSessionDescriptionInit) {
	var (
		_args [1]interface{}
		_end  int
	)
	if options != nil {
		_p0 := options.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _this.Value_JS.Call("createAnswer", _args[0:_end]...)
	var (
		_converted *PromiseSessionDescriptionInit // javascript: Promise _what_return_name
	)
	_converted = PromiseSessionDescriptionInitFromJS(_returned)
	_result = _converted
	return
}

func (_this *PeerConnection) SetLocalDescription(description *SessionDescriptionInit) (_result *javascript.PromiseVoid) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := description.JSValue()
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("setLocalDescription", _args[0:_end]...)
	var (
		_converted *javascript.PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = javascript.PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

func (_this *PeerConnection) SetRemoteDescription(description *SessionDescriptionInit) (_result *javascript.PromiseVoid) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := description.JSValue()
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("setRemoteDescription", _args[0:_end]...)
	var (
		_converted *javascript.PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = javascript.PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

func (_this *PeerConnection) AddIceCandidate(candidate *IceCandidateInit) (_result *javascript.PromiseVoid) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := candidate.JSValue()
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("addIceCandidate", _args[0:_end]...)
	var (
		_converted *javascript.PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = javascript.PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

func (_this *PeerConnection) GetConfiguration() (_result *Configuration) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getConfiguration", _args[0:_end]...)
	var (
		_converted *Configuration // javascript: RTCConfiguration _what_return_name
	)
	_converted = ConfigurationFromJS(_returned)
	_result = _converted
	return
}

func (_this *PeerConnection) SetConfiguration(configuration *Configuration) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := configuration.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("setConfiguration", _args[0:_end]...)
	return
}

func (_this *PeerConnection) Close() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("close", _args[0:_end]...)
	return
}

func (_this *PeerConnection) CreateOffer2(successCallback *SessionDescriptionCallback, failureCallback *PeerConnectionErrorCallback, options *OfferOptions) (_result *javascript.PromiseVoid) {
	var (
		_args [3]interface{}
		_end  int
	)

	var __callback0 js.Value
	if successCallback != nil {
		__callback0 = (*successCallback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++

	var __callback1 js.Value
	if failureCallback != nil {
		__callback1 = (*failureCallback).Value
	} else {
		__callback1 = js.Null()
	}
	_p1 := __callback1
	_args[1] = _p1
	_end++
	if options != nil {
		_p2 := options.JSValue()
		_args[2] = _p2
		_end++
	}
	_returned := _this.Value_JS.Call("createOffer", _args[0:_end]...)
	var (
		_converted *javascript.PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = javascript.PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

func (_this *PeerConnection) SetLocalDescription2(description *SessionDescriptionInit, successCallback *webidl.VoidFunction, failureCallback *PeerConnectionErrorCallback) (_result *javascript.PromiseVoid) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := description.JSValue()
	_args[0] = _p0
	_end++

	var __callback1 js.Value
	if successCallback != nil {
		__callback1 = (*successCallback).Value
	} else {
		__callback1 = js.Null()
	}
	_p1 := __callback1
	_args[1] = _p1
	_end++

	var __callback2 js.Value
	if failureCallback != nil {
		__callback2 = (*failureCallback).Value
	} else {
		__callback2 = js.Null()
	}
	_p2 := __callback2
	_args[2] = _p2
	_end++
	_returned := _this.Value_JS.Call("setLocalDescription", _args[0:_end]...)
	var (
		_converted *javascript.PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = javascript.PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

func (_this *PeerConnection) CreateAnswer2(successCallback *SessionDescriptionCallback, failureCallback *PeerConnectionErrorCallback) (_result *javascript.PromiseVoid) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if successCallback != nil {
		__callback0 = (*successCallback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++

	var __callback1 js.Value
	if failureCallback != nil {
		__callback1 = (*failureCallback).Value
	} else {
		__callback1 = js.Null()
	}
	_p1 := __callback1
	_args[1] = _p1
	_end++
	_returned := _this.Value_JS.Call("createAnswer", _args[0:_end]...)
	var (
		_converted *javascript.PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = javascript.PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

func (_this *PeerConnection) SetRemoteDescription2(description *SessionDescriptionInit, successCallback *webidl.VoidFunction, failureCallback *PeerConnectionErrorCallback) (_result *javascript.PromiseVoid) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := description.JSValue()
	_args[0] = _p0
	_end++

	var __callback1 js.Value
	if successCallback != nil {
		__callback1 = (*successCallback).Value
	} else {
		__callback1 = js.Null()
	}
	_p1 := __callback1
	_args[1] = _p1
	_end++

	var __callback2 js.Value
	if failureCallback != nil {
		__callback2 = (*failureCallback).Value
	} else {
		__callback2 = js.Null()
	}
	_p2 := __callback2
	_args[2] = _p2
	_end++
	_returned := _this.Value_JS.Call("setRemoteDescription", _args[0:_end]...)
	var (
		_converted *javascript.PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = javascript.PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

func (_this *PeerConnection) AddIceCandidate2(candidate *IceCandidateInit, successCallback *webidl.VoidFunction, failureCallback *PeerConnectionErrorCallback) (_result *javascript.PromiseVoid) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := candidate.JSValue()
	_args[0] = _p0
	_end++

	var __callback1 js.Value
	if successCallback != nil {
		__callback1 = (*successCallback).Value
	} else {
		__callback1 = js.Null()
	}
	_p1 := __callback1
	_args[1] = _p1
	_end++

	var __callback2 js.Value
	if failureCallback != nil {
		__callback2 = (*failureCallback).Value
	} else {
		__callback2 = js.Null()
	}
	_p2 := __callback2
	_args[2] = _p2
	_end++
	_returned := _this.Value_JS.Call("addIceCandidate", _args[0:_end]...)
	var (
		_converted *javascript.PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = javascript.PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

func (_this *PeerConnection) GetSenders() (_result []*RtpSender) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getSenders", _args[0:_end]...)
	var (
		_converted []*RtpSender // javascript: sequence<RTCRtpSender> _what_return_name
	)
	__length0 := _returned.Length()
	__array0 := make([]*RtpSender, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *RtpSender
		__seq_in0 := _returned.Index(__idx0)
		__seq_out0 = RtpSenderFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	_converted = __array0
	_result = _converted
	return
}

func (_this *PeerConnection) GetReceivers() (_result []*RtpReceiver) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getReceivers", _args[0:_end]...)
	var (
		_converted []*RtpReceiver // javascript: sequence<RTCRtpReceiver> _what_return_name
	)
	__length0 := _returned.Length()
	__array0 := make([]*RtpReceiver, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *RtpReceiver
		__seq_in0 := _returned.Index(__idx0)
		__seq_out0 = RtpReceiverFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	_converted = __array0
	_result = _converted
	return
}

func (_this *PeerConnection) GetTransceivers() (_result []*RtpTransceiver) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getTransceivers", _args[0:_end]...)
	var (
		_converted []*RtpTransceiver // javascript: sequence<RTCRtpTransceiver> _what_return_name
	)
	__length0 := _returned.Length()
	__array0 := make([]*RtpTransceiver, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *RtpTransceiver
		__seq_in0 := _returned.Index(__idx0)
		__seq_out0 = RtpTransceiverFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	_converted = __array0
	_result = _converted
	return
}

func (_this *PeerConnection) AddTrack(track *local.MediaStreamTrack, streams ...*local.MediaStream) (_result *RtpSender) {
	var (
		_args []interface{} = make([]interface{}, 1+len(streams))
		_end  int
	)
	_p0 := track.JSValue()
	_args[0] = _p0
	_end++
	for _, __in := range streams {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("addTrack", _args[0:_end]...)
	var (
		_converted *RtpSender // javascript: RTCRtpSender _what_return_name
	)
	_converted = RtpSenderFromJS(_returned)
	_result = _converted
	return
}

func (_this *PeerConnection) RemoveTrack(sender *RtpSender) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := sender.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("removeTrack", _args[0:_end]...)
	return
}

func (_this *PeerConnection) AddTransceiver(trackOrKind *Union, init *RtpTransceiverInit) (_result *RtpTransceiver) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := trackOrKind.JSValue()
	_args[0] = _p0
	_end++
	if init != nil {
		_p1 := init.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("addTransceiver", _args[0:_end]...)
	var (
		_converted *RtpTransceiver // javascript: RTCRtpTransceiver _what_return_name
	)
	_converted = RtpTransceiverFromJS(_returned)
	_result = _converted
	return
}

func (_this *PeerConnection) CreateDataChannel(label string, dataChannelDict *DataChannelInit) (_result *DataChannel) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := label
	_args[0] = _p0
	_end++
	if dataChannelDict != nil {
		_p1 := dataChannelDict.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("createDataChannel", _args[0:_end]...)
	var (
		_converted *DataChannel // javascript: RTCDataChannel _what_return_name
	)
	_converted = DataChannelFromJS(_returned)
	_result = _converted
	return
}

func (_this *PeerConnection) GetStats(selector *local.MediaStreamTrack) (_result *PromiseStatsReport) {
	var (
		_args [1]interface{}
		_end  int
	)
	if selector != nil {
		_p0 := selector.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _this.Value_JS.Call("getStats", _args[0:_end]...)
	var (
		_converted *PromiseStatsReport // javascript: Promise _what_return_name
	)
	_converted = PromiseStatsReportFromJS(_returned)
	_result = _converted
	return
}

// class: RTCPeerConnectionIceErrorEvent
type PeerConnectionIceErrorEvent struct {
	domcore.Event
}

// PeerConnectionIceErrorEventFromJS is casting a js.Wrapper into PeerConnectionIceErrorEvent.
func PeerConnectionIceErrorEventFromJS(value js.Wrapper) *PeerConnectionIceErrorEvent {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PeerConnectionIceErrorEvent{}
	ret.Value_JS = input
	return ret
}

func NewRTCPeerConnectionIceErrorEvent(_type string, eventInitDict *PeerConnectionIceErrorEventInit) (_result *PeerConnectionIceErrorEvent) {
	_klass := js.Global().Get("RTCPeerConnectionIceErrorEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := eventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *PeerConnectionIceErrorEvent // javascript: RTCPeerConnectionIceErrorEvent _what_return_name
	)
	_converted = PeerConnectionIceErrorEventFromJS(_returned)
	_result = _converted
	return
}

// HostCandidate returning attribute 'hostCandidate' with
// type string (idl: DOMString).
func (_this *PeerConnectionIceErrorEvent) HostCandidate() string {
	var ret string
	value := _this.Value_JS.Get("hostCandidate")
	ret = (value).String()
	return ret
}

// Url returning attribute 'url' with
// type string (idl: DOMString).
func (_this *PeerConnectionIceErrorEvent) Url() string {
	var ret string
	value := _this.Value_JS.Get("url")
	ret = (value).String()
	return ret
}

// ErrorCode returning attribute 'errorCode' with
// type int (idl: unsigned short).
func (_this *PeerConnectionIceErrorEvent) ErrorCode() int {
	var ret int
	value := _this.Value_JS.Get("errorCode")
	ret = (value).Int()
	return ret
}

// ErrorText returning attribute 'errorText' with
// type string (idl: USVString).
func (_this *PeerConnectionIceErrorEvent) ErrorText() string {
	var ret string
	value := _this.Value_JS.Get("errorText")
	ret = (value).String()
	return ret
}

// class: RTCPeerConnectionIceEvent
type PeerConnectionIceEvent struct {
	domcore.Event
}

// PeerConnectionIceEventFromJS is casting a js.Wrapper into PeerConnectionIceEvent.
func PeerConnectionIceEventFromJS(value js.Wrapper) *PeerConnectionIceEvent {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PeerConnectionIceEvent{}
	ret.Value_JS = input
	return ret
}

func NewRTCPeerConnectionIceEvent(_type string, eventInitDict *PeerConnectionIceEventInit) (_result *PeerConnectionIceEvent) {
	_klass := js.Global().Get("RTCPeerConnectionIceEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	if eventInitDict != nil {
		_p1 := eventInitDict.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *PeerConnectionIceEvent // javascript: RTCPeerConnectionIceEvent _what_return_name
	)
	_converted = PeerConnectionIceEventFromJS(_returned)
	_result = _converted
	return
}

// Candidate returning attribute 'candidate' with
// type IceCandidate (idl: RTCIceCandidate).
func (_this *PeerConnectionIceEvent) Candidate() *IceCandidate {
	var ret *IceCandidate
	value := _this.Value_JS.Get("candidate")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = IceCandidateFromJS(value)
	}
	return ret
}

// Url returning attribute 'url' with
// type string (idl: DOMString).
func (_this *PeerConnectionIceEvent) Url() *string {
	var ret *string
	value := _this.Value_JS.Get("url")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).String()
		ret = &__tmp
	}
	return ret
}

// class: Promise
type PromiseCertificate struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PromiseCertificate) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseCertificateFromJS is casting a js.Wrapper into PromiseCertificate.
func PromiseCertificateFromJS(value js.Wrapper) *PromiseCertificate {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseCertificate{}
	ret.Value_JS = input
	return ret
}

func (_this *PromiseCertificate) Then(onFulfilled *PromiseCertificateOnFulfilled, onRejected *PromiseCertificateOnRejected) (_result *PromiseCertificate) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseCertificate // javascript: Promise _what_return_name
	)
	_converted = PromiseCertificateFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseCertificate) Catch(onRejected *PromiseCertificateOnRejected) (_result *PromiseCertificate) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseCertificate // javascript: Promise _what_return_name
	)
	_converted = PromiseCertificateFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseCertificate) Finally(onFinally *javascript.PromiseFinally) (_result *PromiseCertificate) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseCertificate // javascript: Promise _what_return_name
	)
	_converted = PromiseCertificateFromJS(_returned)
	_result = _converted
	return
}

// class: Promise
type PromiseSessionDescriptionInit struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PromiseSessionDescriptionInit) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseSessionDescriptionInitFromJS is casting a js.Wrapper into PromiseSessionDescriptionInit.
func PromiseSessionDescriptionInitFromJS(value js.Wrapper) *PromiseSessionDescriptionInit {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseSessionDescriptionInit{}
	ret.Value_JS = input
	return ret
}

func (_this *PromiseSessionDescriptionInit) Then(onFulfilled *PromiseSessionDescriptionInitOnFulfilled, onRejected *PromiseSessionDescriptionInitOnRejected) (_result *PromiseSessionDescriptionInit) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseSessionDescriptionInit // javascript: Promise _what_return_name
	)
	_converted = PromiseSessionDescriptionInitFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseSessionDescriptionInit) Catch(onRejected *PromiseSessionDescriptionInitOnRejected) (_result *PromiseSessionDescriptionInit) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseSessionDescriptionInit // javascript: Promise _what_return_name
	)
	_converted = PromiseSessionDescriptionInitFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseSessionDescriptionInit) Finally(onFinally *javascript.PromiseFinally) (_result *PromiseSessionDescriptionInit) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseSessionDescriptionInit // javascript: Promise _what_return_name
	)
	_converted = PromiseSessionDescriptionInitFromJS(_returned)
	_result = _converted
	return
}

// class: Promise
type PromiseStatsReport struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PromiseStatsReport) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseStatsReportFromJS is casting a js.Wrapper into PromiseStatsReport.
func PromiseStatsReportFromJS(value js.Wrapper) *PromiseStatsReport {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseStatsReport{}
	ret.Value_JS = input
	return ret
}

func (_this *PromiseStatsReport) Then(onFulfilled *PromiseStatsReportOnFulfilled, onRejected *PromiseStatsReportOnRejected) (_result *PromiseStatsReport) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseStatsReport // javascript: Promise _what_return_name
	)
	_converted = PromiseStatsReportFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseStatsReport) Catch(onRejected *PromiseStatsReportOnRejected) (_result *PromiseStatsReport) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseStatsReport // javascript: Promise _what_return_name
	)
	_converted = PromiseStatsReportFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseStatsReport) Finally(onFinally *javascript.PromiseFinally) (_result *PromiseStatsReport) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseStatsReport // javascript: Promise _what_return_name
	)
	_converted = PromiseStatsReportFromJS(_returned)
	_result = _converted
	return
}

// class: RTCRtpReceiver
type RtpReceiver struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *RtpReceiver) JSValue() js.Value {
	return _this.Value_JS
}

// RtpReceiverFromJS is casting a js.Wrapper into RtpReceiver.
func RtpReceiverFromJS(value js.Wrapper) *RtpReceiver {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &RtpReceiver{}
	ret.Value_JS = input
	return ret
}

func GetCapabilities(kind string) (_result *RtpCapabilities) {
	_klass := js.Global().Get("RTCRtpReceiver")
	_method := _klass.Get("getCapabilities")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := kind
	_args[0] = _p0
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted *RtpCapabilities // javascript: RTCRtpCapabilities _what_return_name
	)
	if _returned.Type() != js.TypeNull && _returned.Type() != js.TypeUndefined {
		_converted = RtpCapabilitiesFromJS(_returned)
	}
	_result = _converted
	return
}

// Track returning attribute 'track' with
// type local.MediaStreamTrack (idl: MediaStreamTrack).
func (_this *RtpReceiver) Track() *local.MediaStreamTrack {
	var ret *local.MediaStreamTrack
	value := _this.Value_JS.Get("track")
	ret = local.MediaStreamTrackFromJS(value)
	return ret
}

// Transport returning attribute 'transport' with
// type DtlsTransport (idl: RTCDtlsTransport).
func (_this *RtpReceiver) Transport() *DtlsTransport {
	var ret *DtlsTransport
	value := _this.Value_JS.Get("transport")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = DtlsTransportFromJS(value)
	}
	return ret
}

// RtcpTransport returning attribute 'rtcpTransport' with
// type DtlsTransport (idl: RTCDtlsTransport).
func (_this *RtpReceiver) RtcpTransport() *DtlsTransport {
	var ret *DtlsTransport
	value := _this.Value_JS.Get("rtcpTransport")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = DtlsTransportFromJS(value)
	}
	return ret
}

func (_this *RtpReceiver) GetParameters() (_result *RtpReceiveParameters) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getParameters", _args[0:_end]...)
	var (
		_converted *RtpReceiveParameters // javascript: RTCRtpReceiveParameters _what_return_name
	)
	_converted = RtpReceiveParametersFromJS(_returned)
	_result = _converted
	return
}

func (_this *RtpReceiver) GetContributingSources() (_result []*RtpContributingSource) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getContributingSources", _args[0:_end]...)
	var (
		_converted []*RtpContributingSource // javascript: sequence<RTCRtpContributingSource> _what_return_name
	)
	__length0 := _returned.Length()
	__array0 := make([]*RtpContributingSource, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *RtpContributingSource
		__seq_in0 := _returned.Index(__idx0)
		__seq_out0 = RtpContributingSourceFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	_converted = __array0
	_result = _converted
	return
}

func (_this *RtpReceiver) GetSynchronizationSources() (_result []*RtpSynchronizationSource) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getSynchronizationSources", _args[0:_end]...)
	var (
		_converted []*RtpSynchronizationSource // javascript: sequence<RTCRtpSynchronizationSource> _what_return_name
	)
	__length0 := _returned.Length()
	__array0 := make([]*RtpSynchronizationSource, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 *RtpSynchronizationSource
		__seq_in0 := _returned.Index(__idx0)
		__seq_out0 = RtpSynchronizationSourceFromJS(__seq_in0)
		__array0[__idx0] = __seq_out0
	}
	_converted = __array0
	_result = _converted
	return
}

func (_this *RtpReceiver) GetStats() (_result *PromiseStatsReport) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getStats", _args[0:_end]...)
	var (
		_converted *PromiseStatsReport // javascript: Promise _what_return_name
	)
	_converted = PromiseStatsReportFromJS(_returned)
	_result = _converted
	return
}

// class: RTCRtpSender
type RtpSender struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *RtpSender) JSValue() js.Value {
	return _this.Value_JS
}

// RtpSenderFromJS is casting a js.Wrapper into RtpSender.
func RtpSenderFromJS(value js.Wrapper) *RtpSender {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &RtpSender{}
	ret.Value_JS = input
	return ret
}

func GetCapabilities2(kind string) (_result *RtpCapabilities) {
	_klass := js.Global().Get("RTCRtpSender")
	_method := _klass.Get("getCapabilities")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := kind
	_args[0] = _p0
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted *RtpCapabilities // javascript: RTCRtpCapabilities _what_return_name
	)
	if _returned.Type() != js.TypeNull && _returned.Type() != js.TypeUndefined {
		_converted = RtpCapabilitiesFromJS(_returned)
	}
	_result = _converted
	return
}

// Track returning attribute 'track' with
// type local.MediaStreamTrack (idl: MediaStreamTrack).
func (_this *RtpSender) Track() *local.MediaStreamTrack {
	var ret *local.MediaStreamTrack
	value := _this.Value_JS.Get("track")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = local.MediaStreamTrackFromJS(value)
	}
	return ret
}

// Transport returning attribute 'transport' with
// type DtlsTransport (idl: RTCDtlsTransport).
func (_this *RtpSender) Transport() *DtlsTransport {
	var ret *DtlsTransport
	value := _this.Value_JS.Get("transport")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = DtlsTransportFromJS(value)
	}
	return ret
}

// RtcpTransport returning attribute 'rtcpTransport' with
// type DtlsTransport (idl: RTCDtlsTransport).
func (_this *RtpSender) RtcpTransport() *DtlsTransport {
	var ret *DtlsTransport
	value := _this.Value_JS.Get("rtcpTransport")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = DtlsTransportFromJS(value)
	}
	return ret
}

// Dtmf returning attribute 'dtmf' with
// type DTMFSender (idl: RTCDTMFSender).
func (_this *RtpSender) Dtmf() *DTMFSender {
	var ret *DTMFSender
	value := _this.Value_JS.Get("dtmf")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = DTMFSenderFromJS(value)
	}
	return ret
}

func (_this *RtpSender) SetParameters(parameters *RtpSendParameters) (_result *javascript.PromiseVoid) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := parameters.JSValue()
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("setParameters", _args[0:_end]...)
	var (
		_converted *javascript.PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = javascript.PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

func (_this *RtpSender) GetParameters() (_result *RtpSendParameters) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getParameters", _args[0:_end]...)
	var (
		_converted *RtpSendParameters // javascript: RTCRtpSendParameters _what_return_name
	)
	_converted = RtpSendParametersFromJS(_returned)
	_result = _converted
	return
}

func (_this *RtpSender) ReplaceTrack(withTrack *local.MediaStreamTrack) (_result *javascript.PromiseVoid) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := withTrack.JSValue()
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("replaceTrack", _args[0:_end]...)
	var (
		_converted *javascript.PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = javascript.PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

func (_this *RtpSender) SetStreams(streams ...*local.MediaStream) {
	var (
		_args []interface{} = make([]interface{}, 0+len(streams))
		_end  int
	)
	for _, __in := range streams {
		__out := __in.JSValue()
		_args[_end] = __out
		_end++
	}
	_this.Value_JS.Call("setStreams", _args[0:_end]...)
	return
}

func (_this *RtpSender) GetStats() (_result *PromiseStatsReport) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getStats", _args[0:_end]...)
	var (
		_converted *PromiseStatsReport // javascript: Promise _what_return_name
	)
	_converted = PromiseStatsReportFromJS(_returned)
	_result = _converted
	return
}

// class: RTCRtpTransceiver
type RtpTransceiver struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *RtpTransceiver) JSValue() js.Value {
	return _this.Value_JS
}

// RtpTransceiverFromJS is casting a js.Wrapper into RtpTransceiver.
func RtpTransceiverFromJS(value js.Wrapper) *RtpTransceiver {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &RtpTransceiver{}
	ret.Value_JS = input
	return ret
}

// Mid returning attribute 'mid' with
// type string (idl: DOMString).
func (_this *RtpTransceiver) Mid() *string {
	var ret *string
	value := _this.Value_JS.Get("mid")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).String()
		ret = &__tmp
	}
	return ret
}

// Sender returning attribute 'sender' with
// type RtpSender (idl: RTCRtpSender).
func (_this *RtpTransceiver) Sender() *RtpSender {
	var ret *RtpSender
	value := _this.Value_JS.Get("sender")
	ret = RtpSenderFromJS(value)
	return ret
}

// Receiver returning attribute 'receiver' with
// type RtpReceiver (idl: RTCRtpReceiver).
func (_this *RtpTransceiver) Receiver() *RtpReceiver {
	var ret *RtpReceiver
	value := _this.Value_JS.Get("receiver")
	ret = RtpReceiverFromJS(value)
	return ret
}

// Stopped returning attribute 'stopped' with
// type bool (idl: boolean).
func (_this *RtpTransceiver) Stopped() bool {
	var ret bool
	value := _this.Value_JS.Get("stopped")
	ret = (value).Bool()
	return ret
}

// Direction returning attribute 'direction' with
// type RtpTransceiverDirection (idl: RTCRtpTransceiverDirection).
func (_this *RtpTransceiver) Direction() RtpTransceiverDirection {
	var ret RtpTransceiverDirection
	value := _this.Value_JS.Get("direction")
	ret = RtpTransceiverDirectionFromJS(value)
	return ret
}

// SetDirection setting attribute 'direction' with
// type RtpTransceiverDirection (idl: RTCRtpTransceiverDirection).
func (_this *RtpTransceiver) SetDirection(value RtpTransceiverDirection) {
	input := value.JSValue()
	_this.Value_JS.Set("direction", input)
}

// CurrentDirection returning attribute 'currentDirection' with
// type RtpTransceiverDirection (idl: RTCRtpTransceiverDirection).
func (_this *RtpTransceiver) CurrentDirection() *RtpTransceiverDirection {
	var ret *RtpTransceiverDirection
	value := _this.Value_JS.Get("currentDirection")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := RtpTransceiverDirectionFromJS(value)
		ret = &__tmp
	}
	return ret
}

func (_this *RtpTransceiver) Stop() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("stop", _args[0:_end]...)
	return
}

func (_this *RtpTransceiver) SetCodecPreferences(codecs []*RtpCodecCapability) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := js.Global().Get("Array").New(len(codecs))
	for __idx0, __seq_in0 := range codecs {
		__seq_out0 := __seq_in0.JSValue()
		_p0.SetIndex(__idx0, __seq_out0)
	}
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("setCodecPreferences", _args[0:_end]...)
	return
}

// class: RTCSctpTransport
type SctpTransport struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *SctpTransport) JSValue() js.Value {
	return _this.Value_JS
}

// SctpTransportFromJS is casting a js.Wrapper into SctpTransport.
func SctpTransportFromJS(value js.Wrapper) *SctpTransport {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &SctpTransport{}
	ret.Value_JS = input
	return ret
}

// Transport returning attribute 'transport' with
// type DtlsTransport (idl: RTCDtlsTransport).
func (_this *SctpTransport) Transport() *DtlsTransport {
	var ret *DtlsTransport
	value := _this.Value_JS.Get("transport")
	ret = DtlsTransportFromJS(value)
	return ret
}

// State returning attribute 'state' with
// type SctpTransportState (idl: RTCSctpTransportState).
func (_this *SctpTransport) State() SctpTransportState {
	var ret SctpTransportState
	value := _this.Value_JS.Get("state")
	ret = SctpTransportStateFromJS(value)
	return ret
}

// MaxMessageSize returning attribute 'maxMessageSize' with
// type float64 (idl: unrestricted double).
func (_this *SctpTransport) MaxMessageSize() float64 {
	var ret float64
	value := _this.Value_JS.Get("maxMessageSize")
	ret = (value).Float()
	return ret
}

// MaxChannels returning attribute 'maxChannels' with
// type int (idl: unsigned short).
func (_this *SctpTransport) MaxChannels() *int {
	var ret *int
	value := _this.Value_JS.Get("maxChannels")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Int()
		ret = &__tmp
	}
	return ret
}

// OnStateChange returning attribute 'onstatechange' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *SctpTransport) OnStateChange() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onstatechange")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// event attribute: domcore.Event
func eventFuncSctpTransport_domcore_Event(listener func(event *domcore.Event, target *SctpTransport)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *domcore.Event
		value := args[0]
		incoming := value.Get("target")
		ret = domcore.EventFromJS(value)
		src := SctpTransportFromJS(incoming)
		listener(ret, src)
		return js.Undefined
	}
	return js.FuncOf(fn)
}

// AddStateChange is adding doing AddEventListener for 'StateChange' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *SctpTransport) AddEventStateChange(listener func(event *domcore.Event, currentTarget *SctpTransport)) js.Func {
	cb := eventFuncSctpTransport_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "statechange", cb)
	return cb
}

// SetOnStateChange is assigning a function to 'onstatechange'. This
// This method is returning allocated javascript function that need to be released.
func (_this *SctpTransport) SetOnStateChange(listener func(event *domcore.Event, currentTarget *SctpTransport)) js.Func {
	cb := eventFuncSctpTransport_domcore_Event(listener)
	_this.Value_JS.Set("onstatechange", cb)
	return cb
}

// class: RTCSessionDescription
type SessionDescription struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *SessionDescription) JSValue() js.Value {
	return _this.Value_JS
}

// SessionDescriptionFromJS is casting a js.Wrapper into SessionDescription.
func SessionDescriptionFromJS(value js.Wrapper) *SessionDescription {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &SessionDescription{}
	ret.Value_JS = input
	return ret
}

func NewRTCSessionDescription(descriptionInitDict *SessionDescriptionInit) (_result *SessionDescription) {
	_klass := js.Global().Get("RTCSessionDescription")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := descriptionInitDict.JSValue()
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SessionDescription // javascript: RTCSessionDescription _what_return_name
	)
	_converted = SessionDescriptionFromJS(_returned)
	_result = _converted
	return
}

// Type returning attribute 'type' with
// type SdpType (idl: RTCSdpType).
func (_this *SessionDescription) Type() SdpType {
	var ret SdpType
	value := _this.Value_JS.Get("type")
	ret = SdpTypeFromJS(value)
	return ret
}

// Sdp returning attribute 'sdp' with
// type string (idl: DOMString).
func (_this *SessionDescription) Sdp() string {
	var ret string
	value := _this.Value_JS.Get("sdp")
	ret = (value).String()
	return ret
}

func (_this *SessionDescription) ToJSON() (_result *javascript.Object) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("toJSON", _args[0:_end]...)
	var (
		_converted *javascript.Object // javascript: object _what_return_name
	)
	_converted = javascript.ObjectFromJS(_returned)
	_result = _converted
	return
}

// class: RTCStatsEvent
type StatsEvent struct {
	domcore.Event
}

// StatsEventFromJS is casting a js.Wrapper into StatsEvent.
func StatsEventFromJS(value js.Wrapper) *StatsEvent {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &StatsEvent{}
	ret.Value_JS = input
	return ret
}

func NewRTCStatsEvent(_type string, eventInitDict *StatsEventInit) (_result *StatsEvent) {
	_klass := js.Global().Get("RTCStatsEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := eventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *StatsEvent // javascript: RTCStatsEvent _what_return_name
	)
	_converted = StatsEventFromJS(_returned)
	_result = _converted
	return
}

// Report returning attribute 'report' with
// type StatsReport (idl: RTCStatsReport).
func (_this *StatsEvent) Report() *StatsReport {
	var ret *StatsReport
	value := _this.Value_JS.Get("report")
	ret = StatsReportFromJS(value)
	return ret
}

// class: RTCStatsReport
type StatsReport struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *StatsReport) JSValue() js.Value {
	return _this.Value_JS
}

// StatsReportFromJS is casting a js.Wrapper into StatsReport.
func StatsReportFromJS(value js.Wrapper) *StatsReport {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &StatsReport{}
	ret.Value_JS = input
	return ret
}

// Size returning attribute 'size' with
// type int (idl: long).
func (_this *StatsReport) Size() int {
	var ret int
	value := _this.Value_JS.Get("size")
	ret = (value).Int()
	return ret
}

func (_this *StatsReport) Entries() (_result *StatsReportEntryIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("entries", _args[0:_end]...)
	var (
		_converted *StatsReportEntryIterator // javascript: RTCStatsReportEntryIterator _what_return_name
	)
	_converted = StatsReportEntryIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *StatsReport) ForEach(callback *StatsReportForEach, optionalThisForCallbackArgument interface{}) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if callback != nil {
		__callback0 = (*callback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if optionalThisForCallbackArgument != nil {
		_p1 := optionalThisForCallbackArgument
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("forEach", _args[0:_end]...)
	return
}

func (_this *StatsReport) Keys() (_result *StatsReportKeyIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("keys", _args[0:_end]...)
	var (
		_converted *StatsReportKeyIterator // javascript: RTCStatsReportKeyIterator _what_return_name
	)
	_converted = StatsReportKeyIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *StatsReport) Values() (_result *StatsReportValueIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("values", _args[0:_end]...)
	var (
		_converted *StatsReportValueIterator // javascript: RTCStatsReportValueIterator _what_return_name
	)
	_converted = StatsReportValueIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *StatsReport) Get(key string) (_result *javascript.Object) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := key
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("get", _args[0:_end]...)
	var (
		_converted *javascript.Object // javascript: object _what_return_name
	)
	if _returned.Type() != js.TypeNull && _returned.Type() != js.TypeUndefined {
		_converted = javascript.ObjectFromJS(_returned)
	}
	_result = _converted
	return
}

func (_this *StatsReport) Has(key string) (_result bool) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := key
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("has", _args[0:_end]...)
	var (
		_converted bool // javascript: boolean _what_return_name
	)
	_converted = (_returned).Bool()
	_result = _converted
	return
}

// class: RTCStatsReportEntryIterator
type StatsReportEntryIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *StatsReportEntryIterator) JSValue() js.Value {
	return _this.Value_JS
}

// StatsReportEntryIteratorFromJS is casting a js.Wrapper into StatsReportEntryIterator.
func StatsReportEntryIteratorFromJS(value js.Wrapper) *StatsReportEntryIterator {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &StatsReportEntryIterator{}
	ret.Value_JS = input
	return ret
}

func (_this *StatsReportEntryIterator) Next() (_result *StatsReportEntryIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *StatsReportEntryIteratorValue // javascript: RTCStatsReportEntryIteratorValue _what_return_name
	)
	_converted = StatsReportEntryIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: RTCStatsReportKeyIterator
type StatsReportKeyIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *StatsReportKeyIterator) JSValue() js.Value {
	return _this.Value_JS
}

// StatsReportKeyIteratorFromJS is casting a js.Wrapper into StatsReportKeyIterator.
func StatsReportKeyIteratorFromJS(value js.Wrapper) *StatsReportKeyIterator {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &StatsReportKeyIterator{}
	ret.Value_JS = input
	return ret
}

func (_this *StatsReportKeyIterator) Next() (_result *StatsReportKeyIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *StatsReportKeyIteratorValue // javascript: RTCStatsReportKeyIteratorValue _what_return_name
	)
	_converted = StatsReportKeyIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: RTCStatsReportValueIterator
type StatsReportValueIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *StatsReportValueIterator) JSValue() js.Value {
	return _this.Value_JS
}

// StatsReportValueIteratorFromJS is casting a js.Wrapper into StatsReportValueIterator.
func StatsReportValueIteratorFromJS(value js.Wrapper) *StatsReportValueIterator {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &StatsReportValueIterator{}
	ret.Value_JS = input
	return ret
}

func (_this *StatsReportValueIterator) Next() (_result *StatsReportValueIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *StatsReportValueIteratorValue // javascript: RTCStatsReportValueIteratorValue _what_return_name
	)
	_converted = StatsReportValueIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: RTCTrackEvent
type TrackEvent struct {
	domcore.Event
}

// TrackEventFromJS is casting a js.Wrapper into TrackEvent.
func TrackEventFromJS(value js.Wrapper) *TrackEvent {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &TrackEvent{}
	ret.Value_JS = input
	return ret
}

func NewRTCTrackEvent(_type string, eventInitDict *TrackEventInit) (_result *TrackEvent) {
	_klass := js.Global().Get("RTCTrackEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := eventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *TrackEvent // javascript: RTCTrackEvent _what_return_name
	)
	_converted = TrackEventFromJS(_returned)
	_result = _converted
	return
}

// Receiver returning attribute 'receiver' with
// type RtpReceiver (idl: RTCRtpReceiver).
func (_this *TrackEvent) Receiver() *RtpReceiver {
	var ret *RtpReceiver
	value := _this.Value_JS.Get("receiver")
	ret = RtpReceiverFromJS(value)
	return ret
}

// Track returning attribute 'track' with
// type local.MediaStreamTrack (idl: MediaStreamTrack).
func (_this *TrackEvent) Track() *local.MediaStreamTrack {
	var ret *local.MediaStreamTrack
	value := _this.Value_JS.Get("track")
	ret = local.MediaStreamTrackFromJS(value)
	return ret
}

// Streams returning attribute 'streams' with
// type javascript.FrozenArray (idl: FrozenArray).
func (_this *TrackEvent) Streams() *javascript.FrozenArray {
	var ret *javascript.FrozenArray
	value := _this.Value_JS.Get("streams")
	ret = javascript.FrozenArrayFromJS(value)
	return ret
}

// Transceiver returning attribute 'transceiver' with
// type RtpTransceiver (idl: RTCRtpTransceiver).
func (_this *TrackEvent) Transceiver() *RtpTransceiver {
	var ret *RtpTransceiver
	value := _this.Value_JS.Get("transceiver")
	ret = RtpTransceiverFromJS(value)
	return ret
}
