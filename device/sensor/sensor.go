// Code generated by webidl-bind. DO NOT EDIT.

// +build !js

package sensor

import js "github.com/gowebapi/webapi/core/js"

import (
	"github.com/gowebapi/webapi/core"
	"github.com/gowebapi/webapi/dom/domcore"
	"github.com/gowebapi/webapi/javascript"
)

// using following types:
// domcore.AbortSignal
// domcore.DOMException
// domcore.Event
// domcore.EventHandler
// domcore.EventTarget
// javascript.FrozenArray
// javascript.PromiseFinally

// source idl files:
// accelerometer.idl
// ambient-light.idl
// generic-sensor.idl
// generic-sensor.patch.idl
// geolocation-API.idl
// geolocation-sensor.idl
// gyroscope.idl
// magnetometer.idl
// orientation-event.idl
// orientation-sensor.idl
// promises.idl
// proximity.idl

// transform files:
// accelerometer.go.md
// ambient-light.go.md
// generic-sensor.go.md
// generic-sensor.go.md
// geolocation-API.go.md
// geolocation-sensor.go.md
// gyroscope.go.md
// magnetometer.go.md
// orientation-event.go.md
// orientation-sensor.go.md
// promises.go.md
// proximity.go.md

// workaround for compiler error
func unused(value interface{}) {
	// TODO remove this method
}

type Union struct {
	Value js.Value
}

func (u *Union) JSValue() js.Value {
	return u.Value
}

func UnionFromJS(value js.Value) *Union {
	return &Union{Value: value}
}

// enum: GenericSensorLocalCoordinateSystem
type LocalCoordinateSystem int

const (
	CoordinateSystemDevice LocalCoordinateSystem = iota
	CoordinateSystemScreen
)

var genericSensorLocalCoordinateSystemToWasmTable = []string{
	"device", "screen",
}

var genericSensorLocalCoordinateSystemFromWasmTable = map[string]LocalCoordinateSystem{
	"device": CoordinateSystemDevice, "screen": CoordinateSystemScreen,
}

// JSValue is converting this enum into a javascript object
func (this *LocalCoordinateSystem) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this LocalCoordinateSystem) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(genericSensorLocalCoordinateSystemToWasmTable) {
		return genericSensorLocalCoordinateSystemToWasmTable[idx]
	}
	panic("unknown input value")
}

// LocalCoordinateSystemFromJS is converting a javascript value into
// a LocalCoordinateSystem enum value.
func LocalCoordinateSystemFromJS(value js.Value) LocalCoordinateSystem {
	key := value.String()
	conv, ok := genericSensorLocalCoordinateSystemFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// enum: MockSensorType
type MockSensorType int

const (
	AmbientLightMockSensorType MockSensorType = iota
	AccelerometerMockSensorType
	LinearAccelerationMockSensorType
	GravityMockSensorType
	GyroscopeMockSensorType
	MagnetometerMockSensorType
	UncalibratedMagnetometerMockSensorType
	AbsoluteOrientationMockSensorType
	RelativeOrientationMockSensorType
	GeolocationMockSensorType
	ProximityMockSensorType
)

var mockSensorTypeToWasmTable = []string{
	"ambient-light", "accelerometer", "linear-acceleration", "gravity", "gyroscope", "magnetometer", "uncalibrated-magnetometer", "absolute-orientation", "relative-orientation", "geolocation", "proximity",
}

var mockSensorTypeFromWasmTable = map[string]MockSensorType{
	"ambient-light": AmbientLightMockSensorType, "accelerometer": AccelerometerMockSensorType, "linear-acceleration": LinearAccelerationMockSensorType, "gravity": GravityMockSensorType, "gyroscope": GyroscopeMockSensorType, "magnetometer": MagnetometerMockSensorType, "uncalibrated-magnetometer": UncalibratedMagnetometerMockSensorType, "absolute-orientation": AbsoluteOrientationMockSensorType, "relative-orientation": RelativeOrientationMockSensorType, "geolocation": GeolocationMockSensorType, "proximity": ProximityMockSensorType,
}

// JSValue is converting this enum into a javascript object
func (this *MockSensorType) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this MockSensorType) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(mockSensorTypeToWasmTable) {
		return mockSensorTypeToWasmTable[idx]
	}
	panic("unknown input value")
}

// MockSensorTypeFromJS is converting a javascript value into
// a MockSensorType enum value.
func MockSensorTypeFromJS(value js.Value) MockSensorType {
	key := value.String()
	conv, ok := mockSensorTypeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// callback: PositionCallback
type PositionCallbackFunc func(position *Position)

// PositionCallback is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PositionCallback js.Func

func PositionCallbackToJS(callback PositionCallbackFunc) *PositionCallback {
	if callback == nil {
		return nil
	}
	ret := PositionCallback(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *Position // javascript: Position position
		)
		_p0 = PositionFromJS(args[0])
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PositionCallbackFromJS(_value js.Value) PositionCallbackFunc {
	return func(position *Position) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := position.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PositionErrorCallback
type PositionErrorCallbackFunc func(positionError *PositionError)

// PositionErrorCallback is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PositionErrorCallback js.Func

func PositionErrorCallbackToJS(callback PositionErrorCallbackFunc) *PositionErrorCallback {
	if callback == nil {
		return nil
	}
	ret := PositionErrorCallback(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *PositionError // javascript: PositionError positionError
		)
		_p0 = PositionErrorFromJS(args[0])
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PositionErrorCallbackFromJS(_value js.Value) PositionErrorCallbackFunc {
	return func(positionError *PositionError) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := positionError.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromiseGeolocationSensorReadingOnFulfilledFunc func(value *GeolocationSensorReading)

// PromiseGeolocationSensorReadingOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseGeolocationSensorReadingOnFulfilled js.Func

func PromiseGeolocationSensorReadingOnFulfilledToJS(callback PromiseGeolocationSensorReadingOnFulfilledFunc) *PromiseGeolocationSensorReadingOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseGeolocationSensorReadingOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *GeolocationSensorReading // javascript: GeolocationSensorReading value
		)
		_p0 = GeolocationSensorReadingFromJS(args[0])
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseGeolocationSensorReadingOnFulfilledFromJS(_value js.Value) PromiseGeolocationSensorReadingOnFulfilledFunc {
	return func(value *GeolocationSensorReading) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseGeolocationSensorReadingOnRejectedFunc func(reason js.Value)

// PromiseGeolocationSensorReadingOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseGeolocationSensorReadingOnRejected js.Func

func PromiseGeolocationSensorReadingOnRejectedToJS(callback PromiseGeolocationSensorReadingOnRejectedFunc) *PromiseGeolocationSensorReadingOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseGeolocationSensorReadingOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseGeolocationSensorReadingOnRejectedFromJS(_value js.Value) PromiseGeolocationSensorReadingOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// dictionary: AbsoluteOrientationReadingValues
type AbsoluteOrientationReadingValues struct {
	Quaternion *javascript.FrozenArray
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *AbsoluteOrientationReadingValues) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Quaternion.JSValue()
	out.Set("quaternion", value0)
	return out
}

// AbsoluteOrientationReadingValuesFromJS is allocating a new
// AbsoluteOrientationReadingValues object and copy all values in the value javascript object.
func AbsoluteOrientationReadingValuesFromJS(value js.Value) *AbsoluteOrientationReadingValues {
	var out AbsoluteOrientationReadingValues
	var (
		value0 *javascript.FrozenArray // javascript: FrozenArray {quaternion Quaternion quaternion}
	)
	if value.Get("quaternion").Type() != js.TypeNull && value.Get("quaternion").Type() != js.TypeUndefined {
		value0 = javascript.FrozenArrayFromJS(value.Get("quaternion"))
	}
	out.Quaternion = value0
	return &out
}

// dictionary: AccelerometerReadingValues
type AccelerometerReadingValues struct {
	X *float64
	Y *float64
	Z *float64
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *AccelerometerReadingValues) JSValue() js.Value {
	out := js.Global().Get("Object").New()

	var value0 interface{}
	if _this.X != nil {
		value0 = *(_this.X)
	} else {
		value0 = nil
	}
	out.Set("x", value0)

	var value1 interface{}
	if _this.Y != nil {
		value1 = *(_this.Y)
	} else {
		value1 = nil
	}
	out.Set("y", value1)

	var value2 interface{}
	if _this.Z != nil {
		value2 = *(_this.Z)
	} else {
		value2 = nil
	}
	out.Set("z", value2)
	return out
}

// AccelerometerReadingValuesFromJS is allocating a new
// AccelerometerReadingValues object and copy all values in the value javascript object.
func AccelerometerReadingValuesFromJS(value js.Value) *AccelerometerReadingValues {
	var out AccelerometerReadingValues
	var (
		value0 *float64 // javascript: double {x X x}
		value1 *float64 // javascript: double {y Y y}
		value2 *float64 // javascript: double {z Z z}
	)
	if value.Get("x").Type() != js.TypeNull && value.Get("x").Type() != js.TypeUndefined {
		__tmp := (value.Get("x")).Float()
		value0 = &__tmp
	}
	out.X = value0
	if value.Get("y").Type() != js.TypeNull && value.Get("y").Type() != js.TypeUndefined {
		__tmp := (value.Get("y")).Float()
		value1 = &__tmp
	}
	out.Y = value1
	if value.Get("z").Type() != js.TypeNull && value.Get("z").Type() != js.TypeUndefined {
		__tmp := (value.Get("z")).Float()
		value2 = &__tmp
	}
	out.Z = value2
	return &out
}

// dictionary: AccelerometerSensorOptions
type AccelerometerSensorOptions struct {
	Frequency      float64
	ReferenceFrame LocalCoordinateSystem
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *AccelerometerSensorOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Frequency
	out.Set("frequency", value0)
	value1 := _this.ReferenceFrame.JSValue()
	out.Set("referenceFrame", value1)
	return out
}

// AccelerometerSensorOptionsFromJS is allocating a new
// AccelerometerSensorOptions object and copy all values in the value javascript object.
func AccelerometerSensorOptionsFromJS(value js.Value) *AccelerometerSensorOptions {
	var out AccelerometerSensorOptions
	var (
		value0 float64               // javascript: double {frequency Frequency frequency}
		value1 LocalCoordinateSystem // javascript: GenericSensorLocalCoordinateSystem {referenceFrame ReferenceFrame referenceFrame}
	)
	value0 = (value.Get("frequency")).Float()
	out.Frequency = value0
	value1 = LocalCoordinateSystemFromJS(value.Get("referenceFrame"))
	out.ReferenceFrame = value1
	return &out
}

// dictionary: AmbientLightReadingValues
type AmbientLightReadingValues struct {
	Illuminance *float64
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *AmbientLightReadingValues) JSValue() js.Value {
	out := js.Global().Get("Object").New()

	var value0 interface{}
	if _this.Illuminance != nil {
		value0 = *(_this.Illuminance)
	} else {
		value0 = nil
	}
	out.Set("illuminance", value0)
	return out
}

// AmbientLightReadingValuesFromJS is allocating a new
// AmbientLightReadingValues object and copy all values in the value javascript object.
func AmbientLightReadingValuesFromJS(value js.Value) *AmbientLightReadingValues {
	var out AmbientLightReadingValues
	var (
		value0 *float64 // javascript: double {illuminance Illuminance illuminance}
	)
	if value.Get("illuminance").Type() != js.TypeNull && value.Get("illuminance").Type() != js.TypeUndefined {
		__tmp := (value.Get("illuminance")).Float()
		value0 = &__tmp
	}
	out.Illuminance = value0
	return &out
}

// dictionary: DeviceAccelerationInit
type DeviceAccelerationInit struct {
	X *float64
	Y *float64
	Z *float64
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *DeviceAccelerationInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()

	var value0 interface{}
	if _this.X != nil {
		value0 = *(_this.X)
	} else {
		value0 = nil
	}
	out.Set("x", value0)

	var value1 interface{}
	if _this.Y != nil {
		value1 = *(_this.Y)
	} else {
		value1 = nil
	}
	out.Set("y", value1)

	var value2 interface{}
	if _this.Z != nil {
		value2 = *(_this.Z)
	} else {
		value2 = nil
	}
	out.Set("z", value2)
	return out
}

// DeviceAccelerationInitFromJS is allocating a new
// DeviceAccelerationInit object and copy all values in the value javascript object.
func DeviceAccelerationInitFromJS(value js.Value) *DeviceAccelerationInit {
	var out DeviceAccelerationInit
	var (
		value0 *float64 // javascript: double {x X x}
		value1 *float64 // javascript: double {y Y y}
		value2 *float64 // javascript: double {z Z z}
	)
	if value.Get("x").Type() != js.TypeNull && value.Get("x").Type() != js.TypeUndefined {
		__tmp := (value.Get("x")).Float()
		value0 = &__tmp
	}
	out.X = value0
	if value.Get("y").Type() != js.TypeNull && value.Get("y").Type() != js.TypeUndefined {
		__tmp := (value.Get("y")).Float()
		value1 = &__tmp
	}
	out.Y = value1
	if value.Get("z").Type() != js.TypeNull && value.Get("z").Type() != js.TypeUndefined {
		__tmp := (value.Get("z")).Float()
		value2 = &__tmp
	}
	out.Z = value2
	return &out
}

// dictionary: DeviceMotionEventInit
type DeviceMotionEventInit struct {
	Bubbles                      bool
	Cancelable                   bool
	Composed                     bool
	Acceleration                 *DeviceAccelerationInit
	AccelerationIncludingGravity *DeviceAccelerationInit
	RotationRate                 *DeviceRotationRateInit
	Interval                     float64
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *DeviceMotionEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Acceleration.JSValue()
	out.Set("acceleration", value3)
	value4 := _this.AccelerationIncludingGravity.JSValue()
	out.Set("accelerationIncludingGravity", value4)
	value5 := _this.RotationRate.JSValue()
	out.Set("rotationRate", value5)
	value6 := _this.Interval
	out.Set("interval", value6)
	return out
}

// DeviceMotionEventInitFromJS is allocating a new
// DeviceMotionEventInit object and copy all values in the value javascript object.
func DeviceMotionEventInitFromJS(value js.Value) *DeviceMotionEventInit {
	var out DeviceMotionEventInit
	var (
		value0 bool                    // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool                    // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool                    // javascript: boolean {composed Composed composed}
		value3 *DeviceAccelerationInit // javascript: DeviceAccelerationInit {acceleration Acceleration acceleration}
		value4 *DeviceAccelerationInit // javascript: DeviceAccelerationInit {accelerationIncludingGravity AccelerationIncludingGravity accelerationIncludingGravity}
		value5 *DeviceRotationRateInit // javascript: DeviceRotationRateInit {rotationRate RotationRate rotationRate}
		value6 float64                 // javascript: double {interval Interval interval}
	)
	value0 = (value.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (value.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (value.Get("composed")).Bool()
	out.Composed = value2
	if value.Get("acceleration").Type() != js.TypeNull && value.Get("acceleration").Type() != js.TypeUndefined {
		value3 = DeviceAccelerationInitFromJS(value.Get("acceleration"))
	}
	out.Acceleration = value3
	if value.Get("accelerationIncludingGravity").Type() != js.TypeNull && value.Get("accelerationIncludingGravity").Type() != js.TypeUndefined {
		value4 = DeviceAccelerationInitFromJS(value.Get("accelerationIncludingGravity"))
	}
	out.AccelerationIncludingGravity = value4
	if value.Get("rotationRate").Type() != js.TypeNull && value.Get("rotationRate").Type() != js.TypeUndefined {
		value5 = DeviceRotationRateInitFromJS(value.Get("rotationRate"))
	}
	out.RotationRate = value5
	value6 = (value.Get("interval")).Float()
	out.Interval = value6
	return &out
}

// dictionary: DeviceOrientationEventInit
type DeviceOrientationEventInit struct {
	Bubbles    bool
	Cancelable bool
	Composed   bool
	Alpha      *float64
	Beta       *float64
	Gamma      *float64
	Absolute   bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *DeviceOrientationEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)

	var value3 interface{}
	if _this.Alpha != nil {
		value3 = *(_this.Alpha)
	} else {
		value3 = nil
	}
	out.Set("alpha", value3)

	var value4 interface{}
	if _this.Beta != nil {
		value4 = *(_this.Beta)
	} else {
		value4 = nil
	}
	out.Set("beta", value4)

	var value5 interface{}
	if _this.Gamma != nil {
		value5 = *(_this.Gamma)
	} else {
		value5 = nil
	}
	out.Set("gamma", value5)
	value6 := _this.Absolute
	out.Set("absolute", value6)
	return out
}

// DeviceOrientationEventInitFromJS is allocating a new
// DeviceOrientationEventInit object and copy all values in the value javascript object.
func DeviceOrientationEventInitFromJS(value js.Value) *DeviceOrientationEventInit {
	var out DeviceOrientationEventInit
	var (
		value0 bool     // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool     // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool     // javascript: boolean {composed Composed composed}
		value3 *float64 // javascript: double {alpha Alpha alpha}
		value4 *float64 // javascript: double {beta Beta beta}
		value5 *float64 // javascript: double {gamma Gamma gamma}
		value6 bool     // javascript: boolean {absolute Absolute absolute}
	)
	value0 = (value.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (value.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (value.Get("composed")).Bool()
	out.Composed = value2
	if value.Get("alpha").Type() != js.TypeNull && value.Get("alpha").Type() != js.TypeUndefined {
		__tmp := (value.Get("alpha")).Float()
		value3 = &__tmp
	}
	out.Alpha = value3
	if value.Get("beta").Type() != js.TypeNull && value.Get("beta").Type() != js.TypeUndefined {
		__tmp := (value.Get("beta")).Float()
		value4 = &__tmp
	}
	out.Beta = value4
	if value.Get("gamma").Type() != js.TypeNull && value.Get("gamma").Type() != js.TypeUndefined {
		__tmp := (value.Get("gamma")).Float()
		value5 = &__tmp
	}
	out.Gamma = value5
	value6 = (value.Get("absolute")).Bool()
	out.Absolute = value6
	return &out
}

// dictionary: DeviceRotationRateInit
type DeviceRotationRateInit struct {
	Alpha *float64
	Beta  *float64
	Gamma *float64
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *DeviceRotationRateInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()

	var value0 interface{}
	if _this.Alpha != nil {
		value0 = *(_this.Alpha)
	} else {
		value0 = nil
	}
	out.Set("alpha", value0)

	var value1 interface{}
	if _this.Beta != nil {
		value1 = *(_this.Beta)
	} else {
		value1 = nil
	}
	out.Set("beta", value1)

	var value2 interface{}
	if _this.Gamma != nil {
		value2 = *(_this.Gamma)
	} else {
		value2 = nil
	}
	out.Set("gamma", value2)
	return out
}

// DeviceRotationRateInitFromJS is allocating a new
// DeviceRotationRateInit object and copy all values in the value javascript object.
func DeviceRotationRateInitFromJS(value js.Value) *DeviceRotationRateInit {
	var out DeviceRotationRateInit
	var (
		value0 *float64 // javascript: double {alpha Alpha alpha}
		value1 *float64 // javascript: double {beta Beta beta}
		value2 *float64 // javascript: double {gamma Gamma gamma}
	)
	if value.Get("alpha").Type() != js.TypeNull && value.Get("alpha").Type() != js.TypeUndefined {
		__tmp := (value.Get("alpha")).Float()
		value0 = &__tmp
	}
	out.Alpha = value0
	if value.Get("beta").Type() != js.TypeNull && value.Get("beta").Type() != js.TypeUndefined {
		__tmp := (value.Get("beta")).Float()
		value1 = &__tmp
	}
	out.Beta = value1
	if value.Get("gamma").Type() != js.TypeNull && value.Get("gamma").Type() != js.TypeUndefined {
		__tmp := (value.Get("gamma")).Float()
		value2 = &__tmp
	}
	out.Gamma = value2
	return &out
}

// dictionary: GeolocationReadingValues
type GeolocationReadingValues struct {
	Latitude         *float64
	Longitude        *float64
	Altitude         *float64
	Accuracy         *float64
	AltitudeAccuracy *float64
	Heading          *float64
	Speed            *float64
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *GeolocationReadingValues) JSValue() js.Value {
	out := js.Global().Get("Object").New()

	var value0 interface{}
	if _this.Latitude != nil {
		value0 = *(_this.Latitude)
	} else {
		value0 = nil
	}
	out.Set("latitude", value0)

	var value1 interface{}
	if _this.Longitude != nil {
		value1 = *(_this.Longitude)
	} else {
		value1 = nil
	}
	out.Set("longitude", value1)

	var value2 interface{}
	if _this.Altitude != nil {
		value2 = *(_this.Altitude)
	} else {
		value2 = nil
	}
	out.Set("altitude", value2)

	var value3 interface{}
	if _this.Accuracy != nil {
		value3 = *(_this.Accuracy)
	} else {
		value3 = nil
	}
	out.Set("accuracy", value3)

	var value4 interface{}
	if _this.AltitudeAccuracy != nil {
		value4 = *(_this.AltitudeAccuracy)
	} else {
		value4 = nil
	}
	out.Set("altitudeAccuracy", value4)

	var value5 interface{}
	if _this.Heading != nil {
		value5 = *(_this.Heading)
	} else {
		value5 = nil
	}
	out.Set("heading", value5)

	var value6 interface{}
	if _this.Speed != nil {
		value6 = *(_this.Speed)
	} else {
		value6 = nil
	}
	out.Set("speed", value6)
	return out
}

// GeolocationReadingValuesFromJS is allocating a new
// GeolocationReadingValues object and copy all values in the value javascript object.
func GeolocationReadingValuesFromJS(value js.Value) *GeolocationReadingValues {
	var out GeolocationReadingValues
	var (
		value0 *float64 // javascript: double {latitude Latitude latitude}
		value1 *float64 // javascript: double {longitude Longitude longitude}
		value2 *float64 // javascript: double {altitude Altitude altitude}
		value3 *float64 // javascript: double {accuracy Accuracy accuracy}
		value4 *float64 // javascript: double {altitudeAccuracy AltitudeAccuracy altitudeAccuracy}
		value5 *float64 // javascript: double {heading Heading heading}
		value6 *float64 // javascript: double {speed Speed speed}
	)
	if value.Get("latitude").Type() != js.TypeNull && value.Get("latitude").Type() != js.TypeUndefined {
		__tmp := (value.Get("latitude")).Float()
		value0 = &__tmp
	}
	out.Latitude = value0
	if value.Get("longitude").Type() != js.TypeNull && value.Get("longitude").Type() != js.TypeUndefined {
		__tmp := (value.Get("longitude")).Float()
		value1 = &__tmp
	}
	out.Longitude = value1
	if value.Get("altitude").Type() != js.TypeNull && value.Get("altitude").Type() != js.TypeUndefined {
		__tmp := (value.Get("altitude")).Float()
		value2 = &__tmp
	}
	out.Altitude = value2
	if value.Get("accuracy").Type() != js.TypeNull && value.Get("accuracy").Type() != js.TypeUndefined {
		__tmp := (value.Get("accuracy")).Float()
		value3 = &__tmp
	}
	out.Accuracy = value3
	if value.Get("altitudeAccuracy").Type() != js.TypeNull && value.Get("altitudeAccuracy").Type() != js.TypeUndefined {
		__tmp := (value.Get("altitudeAccuracy")).Float()
		value4 = &__tmp
	}
	out.AltitudeAccuracy = value4
	if value.Get("heading").Type() != js.TypeNull && value.Get("heading").Type() != js.TypeUndefined {
		__tmp := (value.Get("heading")).Float()
		value5 = &__tmp
	}
	out.Heading = value5
	if value.Get("speed").Type() != js.TypeNull && value.Get("speed").Type() != js.TypeUndefined {
		__tmp := (value.Get("speed")).Float()
		value6 = &__tmp
	}
	out.Speed = value6
	return &out
}

// dictionary: GeolocationSensorOptions
type GeolocationSensorOptions struct {
	Frequency float64
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *GeolocationSensorOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Frequency
	out.Set("frequency", value0)
	return out
}

// GeolocationSensorOptionsFromJS is allocating a new
// GeolocationSensorOptions object and copy all values in the value javascript object.
func GeolocationSensorOptionsFromJS(value js.Value) *GeolocationSensorOptions {
	var out GeolocationSensorOptions
	var (
		value0 float64 // javascript: double {frequency Frequency frequency}
	)
	value0 = (value.Get("frequency")).Float()
	out.Frequency = value0
	return &out
}

// dictionary: GeolocationSensorReading
type GeolocationSensorReading struct {
	Timestamp        *float64
	Latitude         *float64
	Longitude        *float64
	Altitude         *float64
	Accuracy         *float64
	AltitudeAccuracy *float64
	Heading          *float64
	Speed            *float64
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *GeolocationSensorReading) JSValue() js.Value {
	out := js.Global().Get("Object").New()

	var value0 interface{}
	if _this.Timestamp != nil {
		value0 = *(_this.Timestamp)
	} else {
		value0 = nil
	}
	out.Set("timestamp", value0)

	var value1 interface{}
	if _this.Latitude != nil {
		value1 = *(_this.Latitude)
	} else {
		value1 = nil
	}
	out.Set("latitude", value1)

	var value2 interface{}
	if _this.Longitude != nil {
		value2 = *(_this.Longitude)
	} else {
		value2 = nil
	}
	out.Set("longitude", value2)

	var value3 interface{}
	if _this.Altitude != nil {
		value3 = *(_this.Altitude)
	} else {
		value3 = nil
	}
	out.Set("altitude", value3)

	var value4 interface{}
	if _this.Accuracy != nil {
		value4 = *(_this.Accuracy)
	} else {
		value4 = nil
	}
	out.Set("accuracy", value4)

	var value5 interface{}
	if _this.AltitudeAccuracy != nil {
		value5 = *(_this.AltitudeAccuracy)
	} else {
		value5 = nil
	}
	out.Set("altitudeAccuracy", value5)

	var value6 interface{}
	if _this.Heading != nil {
		value6 = *(_this.Heading)
	} else {
		value6 = nil
	}
	out.Set("heading", value6)

	var value7 interface{}
	if _this.Speed != nil {
		value7 = *(_this.Speed)
	} else {
		value7 = nil
	}
	out.Set("speed", value7)
	return out
}

// GeolocationSensorReadingFromJS is allocating a new
// GeolocationSensorReading object and copy all values in the value javascript object.
func GeolocationSensorReadingFromJS(value js.Value) *GeolocationSensorReading {
	var out GeolocationSensorReading
	var (
		value0 *float64 // javascript: double {timestamp Timestamp timestamp}
		value1 *float64 // javascript: double {latitude Latitude latitude}
		value2 *float64 // javascript: double {longitude Longitude longitude}
		value3 *float64 // javascript: double {altitude Altitude altitude}
		value4 *float64 // javascript: double {accuracy Accuracy accuracy}
		value5 *float64 // javascript: double {altitudeAccuracy AltitudeAccuracy altitudeAccuracy}
		value6 *float64 // javascript: double {heading Heading heading}
		value7 *float64 // javascript: double {speed Speed speed}
	)
	if value.Get("timestamp").Type() != js.TypeNull && value.Get("timestamp").Type() != js.TypeUndefined {
		__tmp := (value.Get("timestamp")).Float()
		value0 = &__tmp
	}
	out.Timestamp = value0
	if value.Get("latitude").Type() != js.TypeNull && value.Get("latitude").Type() != js.TypeUndefined {
		__tmp := (value.Get("latitude")).Float()
		value1 = &__tmp
	}
	out.Latitude = value1
	if value.Get("longitude").Type() != js.TypeNull && value.Get("longitude").Type() != js.TypeUndefined {
		__tmp := (value.Get("longitude")).Float()
		value2 = &__tmp
	}
	out.Longitude = value2
	if value.Get("altitude").Type() != js.TypeNull && value.Get("altitude").Type() != js.TypeUndefined {
		__tmp := (value.Get("altitude")).Float()
		value3 = &__tmp
	}
	out.Altitude = value3
	if value.Get("accuracy").Type() != js.TypeNull && value.Get("accuracy").Type() != js.TypeUndefined {
		__tmp := (value.Get("accuracy")).Float()
		value4 = &__tmp
	}
	out.Accuracy = value4
	if value.Get("altitudeAccuracy").Type() != js.TypeNull && value.Get("altitudeAccuracy").Type() != js.TypeUndefined {
		__tmp := (value.Get("altitudeAccuracy")).Float()
		value5 = &__tmp
	}
	out.AltitudeAccuracy = value5
	if value.Get("heading").Type() != js.TypeNull && value.Get("heading").Type() != js.TypeUndefined {
		__tmp := (value.Get("heading")).Float()
		value6 = &__tmp
	}
	out.Heading = value6
	if value.Get("speed").Type() != js.TypeNull && value.Get("speed").Type() != js.TypeUndefined {
		__tmp := (value.Get("speed")).Float()
		value7 = &__tmp
	}
	out.Speed = value7
	return &out
}

// dictionary: GravityReadingValues
type GravityReadingValues struct {
	X *float64
	Y *float64
	Z *float64
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *GravityReadingValues) JSValue() js.Value {
	out := js.Global().Get("Object").New()

	var value0 interface{}
	if _this.X != nil {
		value0 = *(_this.X)
	} else {
		value0 = nil
	}
	out.Set("x", value0)

	var value1 interface{}
	if _this.Y != nil {
		value1 = *(_this.Y)
	} else {
		value1 = nil
	}
	out.Set("y", value1)

	var value2 interface{}
	if _this.Z != nil {
		value2 = *(_this.Z)
	} else {
		value2 = nil
	}
	out.Set("z", value2)
	return out
}

// GravityReadingValuesFromJS is allocating a new
// GravityReadingValues object and copy all values in the value javascript object.
func GravityReadingValuesFromJS(value js.Value) *GravityReadingValues {
	var out GravityReadingValues
	var (
		value0 *float64 // javascript: double {x X x}
		value1 *float64 // javascript: double {y Y y}
		value2 *float64 // javascript: double {z Z z}
	)
	if value.Get("x").Type() != js.TypeNull && value.Get("x").Type() != js.TypeUndefined {
		__tmp := (value.Get("x")).Float()
		value0 = &__tmp
	}
	out.X = value0
	if value.Get("y").Type() != js.TypeNull && value.Get("y").Type() != js.TypeUndefined {
		__tmp := (value.Get("y")).Float()
		value1 = &__tmp
	}
	out.Y = value1
	if value.Get("z").Type() != js.TypeNull && value.Get("z").Type() != js.TypeUndefined {
		__tmp := (value.Get("z")).Float()
		value2 = &__tmp
	}
	out.Z = value2
	return &out
}

// dictionary: GyroscopeReadingValues
type GyroscopeReadingValues struct {
	X *float64
	Y *float64
	Z *float64
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *GyroscopeReadingValues) JSValue() js.Value {
	out := js.Global().Get("Object").New()

	var value0 interface{}
	if _this.X != nil {
		value0 = *(_this.X)
	} else {
		value0 = nil
	}
	out.Set("x", value0)

	var value1 interface{}
	if _this.Y != nil {
		value1 = *(_this.Y)
	} else {
		value1 = nil
	}
	out.Set("y", value1)

	var value2 interface{}
	if _this.Z != nil {
		value2 = *(_this.Z)
	} else {
		value2 = nil
	}
	out.Set("z", value2)
	return out
}

// GyroscopeReadingValuesFromJS is allocating a new
// GyroscopeReadingValues object and copy all values in the value javascript object.
func GyroscopeReadingValuesFromJS(value js.Value) *GyroscopeReadingValues {
	var out GyroscopeReadingValues
	var (
		value0 *float64 // javascript: double {x X x}
		value1 *float64 // javascript: double {y Y y}
		value2 *float64 // javascript: double {z Z z}
	)
	if value.Get("x").Type() != js.TypeNull && value.Get("x").Type() != js.TypeUndefined {
		__tmp := (value.Get("x")).Float()
		value0 = &__tmp
	}
	out.X = value0
	if value.Get("y").Type() != js.TypeNull && value.Get("y").Type() != js.TypeUndefined {
		__tmp := (value.Get("y")).Float()
		value1 = &__tmp
	}
	out.Y = value1
	if value.Get("z").Type() != js.TypeNull && value.Get("z").Type() != js.TypeUndefined {
		__tmp := (value.Get("z")).Float()
		value2 = &__tmp
	}
	out.Z = value2
	return &out
}

// dictionary: GyroscopeSensorOptions
type GyroscopeSensorOptions struct {
	Frequency      float64
	ReferenceFrame LocalCoordinateSystem
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *GyroscopeSensorOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Frequency
	out.Set("frequency", value0)
	value1 := _this.ReferenceFrame.JSValue()
	out.Set("referenceFrame", value1)
	return out
}

// GyroscopeSensorOptionsFromJS is allocating a new
// GyroscopeSensorOptions object and copy all values in the value javascript object.
func GyroscopeSensorOptionsFromJS(value js.Value) *GyroscopeSensorOptions {
	var out GyroscopeSensorOptions
	var (
		value0 float64               // javascript: double {frequency Frequency frequency}
		value1 LocalCoordinateSystem // javascript: GenericSensorLocalCoordinateSystem {referenceFrame ReferenceFrame referenceFrame}
	)
	value0 = (value.Get("frequency")).Float()
	out.Frequency = value0
	value1 = LocalCoordinateSystemFromJS(value.Get("referenceFrame"))
	out.ReferenceFrame = value1
	return &out
}

// dictionary: LinearAccelerationReadingValues
type LinearAccelerationReadingValues struct {
	X *float64
	Y *float64
	Z *float64
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *LinearAccelerationReadingValues) JSValue() js.Value {
	out := js.Global().Get("Object").New()

	var value0 interface{}
	if _this.X != nil {
		value0 = *(_this.X)
	} else {
		value0 = nil
	}
	out.Set("x", value0)

	var value1 interface{}
	if _this.Y != nil {
		value1 = *(_this.Y)
	} else {
		value1 = nil
	}
	out.Set("y", value1)

	var value2 interface{}
	if _this.Z != nil {
		value2 = *(_this.Z)
	} else {
		value2 = nil
	}
	out.Set("z", value2)
	return out
}

// LinearAccelerationReadingValuesFromJS is allocating a new
// LinearAccelerationReadingValues object and copy all values in the value javascript object.
func LinearAccelerationReadingValuesFromJS(value js.Value) *LinearAccelerationReadingValues {
	var out LinearAccelerationReadingValues
	var (
		value0 *float64 // javascript: double {x X x}
		value1 *float64 // javascript: double {y Y y}
		value2 *float64 // javascript: double {z Z z}
	)
	if value.Get("x").Type() != js.TypeNull && value.Get("x").Type() != js.TypeUndefined {
		__tmp := (value.Get("x")).Float()
		value0 = &__tmp
	}
	out.X = value0
	if value.Get("y").Type() != js.TypeNull && value.Get("y").Type() != js.TypeUndefined {
		__tmp := (value.Get("y")).Float()
		value1 = &__tmp
	}
	out.Y = value1
	if value.Get("z").Type() != js.TypeNull && value.Get("z").Type() != js.TypeUndefined {
		__tmp := (value.Get("z")).Float()
		value2 = &__tmp
	}
	out.Z = value2
	return &out
}

// dictionary: MagnetometerReadingValues
type MagnetometerReadingValues struct {
	X *float64
	Y *float64
	Z *float64
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *MagnetometerReadingValues) JSValue() js.Value {
	out := js.Global().Get("Object").New()

	var value0 interface{}
	if _this.X != nil {
		value0 = *(_this.X)
	} else {
		value0 = nil
	}
	out.Set("x", value0)

	var value1 interface{}
	if _this.Y != nil {
		value1 = *(_this.Y)
	} else {
		value1 = nil
	}
	out.Set("y", value1)

	var value2 interface{}
	if _this.Z != nil {
		value2 = *(_this.Z)
	} else {
		value2 = nil
	}
	out.Set("z", value2)
	return out
}

// MagnetometerReadingValuesFromJS is allocating a new
// MagnetometerReadingValues object and copy all values in the value javascript object.
func MagnetometerReadingValuesFromJS(value js.Value) *MagnetometerReadingValues {
	var out MagnetometerReadingValues
	var (
		value0 *float64 // javascript: double {x X x}
		value1 *float64 // javascript: double {y Y y}
		value2 *float64 // javascript: double {z Z z}
	)
	if value.Get("x").Type() != js.TypeNull && value.Get("x").Type() != js.TypeUndefined {
		__tmp := (value.Get("x")).Float()
		value0 = &__tmp
	}
	out.X = value0
	if value.Get("y").Type() != js.TypeNull && value.Get("y").Type() != js.TypeUndefined {
		__tmp := (value.Get("y")).Float()
		value1 = &__tmp
	}
	out.Y = value1
	if value.Get("z").Type() != js.TypeNull && value.Get("z").Type() != js.TypeUndefined {
		__tmp := (value.Get("z")).Float()
		value2 = &__tmp
	}
	out.Z = value2
	return &out
}

// dictionary: MagnetometerSensorOptions
type MagnetometerSensorOptions struct {
	Frequency      float64
	ReferenceFrame LocalCoordinateSystem
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *MagnetometerSensorOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Frequency
	out.Set("frequency", value0)
	value1 := _this.ReferenceFrame.JSValue()
	out.Set("referenceFrame", value1)
	return out
}

// MagnetometerSensorOptionsFromJS is allocating a new
// MagnetometerSensorOptions object and copy all values in the value javascript object.
func MagnetometerSensorOptionsFromJS(value js.Value) *MagnetometerSensorOptions {
	var out MagnetometerSensorOptions
	var (
		value0 float64               // javascript: double {frequency Frequency frequency}
		value1 LocalCoordinateSystem // javascript: GenericSensorLocalCoordinateSystem {referenceFrame ReferenceFrame referenceFrame}
	)
	value0 = (value.Get("frequency")).Float()
	out.Frequency = value0
	value1 = LocalCoordinateSystemFromJS(value.Get("referenceFrame"))
	out.ReferenceFrame = value1
	return &out
}

// dictionary: MockSensor
type MockSensor struct {
	MaxSamplingFrequency       float64
	MinSamplingFrequency       float64
	RequestedSamplingFrequency float64
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *MockSensor) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.MaxSamplingFrequency
	out.Set("maxSamplingFrequency", value0)
	value1 := _this.MinSamplingFrequency
	out.Set("minSamplingFrequency", value1)
	value2 := _this.RequestedSamplingFrequency
	out.Set("requestedSamplingFrequency", value2)
	return out
}

// MockSensorFromJS is allocating a new
// MockSensor object and copy all values in the value javascript object.
func MockSensorFromJS(value js.Value) *MockSensor {
	var out MockSensor
	var (
		value0 float64 // javascript: double {maxSamplingFrequency MaxSamplingFrequency maxSamplingFrequency}
		value1 float64 // javascript: double {minSamplingFrequency MinSamplingFrequency minSamplingFrequency}
		value2 float64 // javascript: double {requestedSamplingFrequency RequestedSamplingFrequency requestedSamplingFrequency}
	)
	value0 = (value.Get("maxSamplingFrequency")).Float()
	out.MaxSamplingFrequency = value0
	value1 = (value.Get("minSamplingFrequency")).Float()
	out.MinSamplingFrequency = value1
	value2 = (value.Get("requestedSamplingFrequency")).Float()
	out.RequestedSamplingFrequency = value2
	return &out
}

// dictionary: MockSensorConfiguration
type MockSensorConfiguration struct {
	MockSensorType       MockSensorType
	Connected            bool
	MaxSamplingFrequency *float64
	MinSamplingFrequency *float64
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *MockSensorConfiguration) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.MockSensorType.JSValue()
	out.Set("mockSensorType", value0)
	value1 := _this.Connected
	out.Set("connected", value1)

	var value2 interface{}
	if _this.MaxSamplingFrequency != nil {
		value2 = *(_this.MaxSamplingFrequency)
	} else {
		value2 = nil
	}
	out.Set("maxSamplingFrequency", value2)

	var value3 interface{}
	if _this.MinSamplingFrequency != nil {
		value3 = *(_this.MinSamplingFrequency)
	} else {
		value3 = nil
	}
	out.Set("minSamplingFrequency", value3)
	return out
}

// MockSensorConfigurationFromJS is allocating a new
// MockSensorConfiguration object and copy all values in the value javascript object.
func MockSensorConfigurationFromJS(value js.Value) *MockSensorConfiguration {
	var out MockSensorConfiguration
	var (
		value0 MockSensorType // javascript: MockSensorType {mockSensorType MockSensorType mockSensorType}
		value1 bool           // javascript: boolean {connected Connected connected}
		value2 *float64       // javascript: double {maxSamplingFrequency MaxSamplingFrequency maxSamplingFrequency}
		value3 *float64       // javascript: double {minSamplingFrequency MinSamplingFrequency minSamplingFrequency}
	)
	value0 = MockSensorTypeFromJS(value.Get("mockSensorType"))
	out.MockSensorType = value0
	value1 = (value.Get("connected")).Bool()
	out.Connected = value1
	if value.Get("maxSamplingFrequency").Type() != js.TypeNull && value.Get("maxSamplingFrequency").Type() != js.TypeUndefined {
		__tmp := (value.Get("maxSamplingFrequency")).Float()
		value2 = &__tmp
	}
	out.MaxSamplingFrequency = value2
	if value.Get("minSamplingFrequency").Type() != js.TypeNull && value.Get("minSamplingFrequency").Type() != js.TypeUndefined {
		__tmp := (value.Get("minSamplingFrequency")).Float()
		value3 = &__tmp
	}
	out.MinSamplingFrequency = value3
	return &out
}

// dictionary: MockSensorReadingValues
type MockSensorReadingValues struct {
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *MockSensorReadingValues) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	return out
}

// MockSensorReadingValuesFromJS is allocating a new
// MockSensorReadingValues object and copy all values in the value javascript object.
func MockSensorReadingValuesFromJS(value js.Value) *MockSensorReadingValues {
	var out MockSensorReadingValues
	var ()
	return &out
}

// dictionary: OrientationSensorOptions
type OrientationSensorOptions struct {
	Frequency      float64
	ReferenceFrame LocalCoordinateSystem
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *OrientationSensorOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Frequency
	out.Set("frequency", value0)
	value1 := _this.ReferenceFrame.JSValue()
	out.Set("referenceFrame", value1)
	return out
}

// OrientationSensorOptionsFromJS is allocating a new
// OrientationSensorOptions object and copy all values in the value javascript object.
func OrientationSensorOptionsFromJS(value js.Value) *OrientationSensorOptions {
	var out OrientationSensorOptions
	var (
		value0 float64               // javascript: double {frequency Frequency frequency}
		value1 LocalCoordinateSystem // javascript: GenericSensorLocalCoordinateSystem {referenceFrame ReferenceFrame referenceFrame}
	)
	value0 = (value.Get("frequency")).Float()
	out.Frequency = value0
	value1 = LocalCoordinateSystemFromJS(value.Get("referenceFrame"))
	out.ReferenceFrame = value1
	return &out
}

// dictionary: PositionOptions
type PositionOptions struct {
	EnableHighAccuracy bool
	Timeout            uint
	MaximumAge         uint
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *PositionOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.EnableHighAccuracy
	out.Set("enableHighAccuracy", value0)
	value1 := _this.Timeout
	out.Set("timeout", value1)
	value2 := _this.MaximumAge
	out.Set("maximumAge", value2)
	return out
}

// PositionOptionsFromJS is allocating a new
// PositionOptions object and copy all values in the value javascript object.
func PositionOptionsFromJS(value js.Value) *PositionOptions {
	var out PositionOptions
	var (
		value0 bool // javascript: boolean {enableHighAccuracy EnableHighAccuracy enableHighAccuracy}
		value1 uint // javascript: unsigned long {timeout Timeout timeout}
		value2 uint // javascript: unsigned long {maximumAge MaximumAge maximumAge}
	)
	value0 = (value.Get("enableHighAccuracy")).Bool()
	out.EnableHighAccuracy = value0
	value1 = (uint)((value.Get("timeout")).Int())
	out.Timeout = value1
	value2 = (uint)((value.Get("maximumAge")).Int())
	out.MaximumAge = value2
	return &out
}

// dictionary: ProximityReadingValues
type ProximityReadingValues struct {
	Distance *float64
	Max      *float64
	Near     *bool
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *ProximityReadingValues) JSValue() js.Value {
	out := js.Global().Get("Object").New()

	var value0 interface{}
	if _this.Distance != nil {
		value0 = *(_this.Distance)
	} else {
		value0 = nil
	}
	out.Set("distance", value0)

	var value1 interface{}
	if _this.Max != nil {
		value1 = *(_this.Max)
	} else {
		value1 = nil
	}
	out.Set("max", value1)

	var value2 interface{}
	if _this.Near != nil {
		value2 = *(_this.Near)
	} else {
		value2 = nil
	}
	out.Set("near", value2)
	return out
}

// ProximityReadingValuesFromJS is allocating a new
// ProximityReadingValues object and copy all values in the value javascript object.
func ProximityReadingValuesFromJS(value js.Value) *ProximityReadingValues {
	var out ProximityReadingValues
	var (
		value0 *float64 // javascript: double {distance Distance distance}
		value1 *float64 // javascript: double {max Max max}
		value2 *bool    // javascript: boolean {near Near near}
	)
	if value.Get("distance").Type() != js.TypeNull && value.Get("distance").Type() != js.TypeUndefined {
		__tmp := (value.Get("distance")).Float()
		value0 = &__tmp
	}
	out.Distance = value0
	if value.Get("max").Type() != js.TypeNull && value.Get("max").Type() != js.TypeUndefined {
		__tmp := (value.Get("max")).Float()
		value1 = &__tmp
	}
	out.Max = value1
	if value.Get("near").Type() != js.TypeNull && value.Get("near").Type() != js.TypeUndefined {
		__tmp := (value.Get("near")).Bool()
		value2 = &__tmp
	}
	out.Near = value2
	return &out
}

// dictionary: ReadOptions
type ReadOptions struct {
	Frequency float64
	Signal    *domcore.AbortSignal
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *ReadOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Frequency
	out.Set("frequency", value0)
	value1 := _this.Signal.JSValue()
	out.Set("signal", value1)
	return out
}

// ReadOptionsFromJS is allocating a new
// ReadOptions object and copy all values in the value javascript object.
func ReadOptionsFromJS(value js.Value) *ReadOptions {
	var out ReadOptions
	var (
		value0 float64              // javascript: double {frequency Frequency frequency}
		value1 *domcore.AbortSignal // javascript: AbortSignal {signal Signal signal}
	)
	value0 = (value.Get("frequency")).Float()
	out.Frequency = value0
	if value.Get("signal").Type() != js.TypeNull && value.Get("signal").Type() != js.TypeUndefined {
		value1 = domcore.AbortSignalFromJS(value.Get("signal"))
	}
	out.Signal = value1
	return &out
}

// dictionary: RelativeOrientationReadingValues
type RelativeOrientationReadingValues struct {
	Quaternion *javascript.FrozenArray
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *RelativeOrientationReadingValues) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Quaternion.JSValue()
	out.Set("quaternion", value0)
	return out
}

// RelativeOrientationReadingValuesFromJS is allocating a new
// RelativeOrientationReadingValues object and copy all values in the value javascript object.
func RelativeOrientationReadingValuesFromJS(value js.Value) *RelativeOrientationReadingValues {
	var out RelativeOrientationReadingValues
	var (
		value0 *javascript.FrozenArray // javascript: FrozenArray {quaternion Quaternion quaternion}
	)
	if value.Get("quaternion").Type() != js.TypeNull && value.Get("quaternion").Type() != js.TypeUndefined {
		value0 = javascript.FrozenArrayFromJS(value.Get("quaternion"))
	}
	out.Quaternion = value0
	return &out
}

// dictionary: SensorErrorEventInit
type SensorErrorEventInit struct {
	Bubbles    bool
	Cancelable bool
	Composed   bool
	Error      *domcore.DOMException
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *SensorErrorEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Bubbles
	out.Set("bubbles", value0)
	value1 := _this.Cancelable
	out.Set("cancelable", value1)
	value2 := _this.Composed
	out.Set("composed", value2)
	value3 := _this.Error.JSValue()
	out.Set("error", value3)
	return out
}

// SensorErrorEventInitFromJS is allocating a new
// SensorErrorEventInit object and copy all values in the value javascript object.
func SensorErrorEventInitFromJS(value js.Value) *SensorErrorEventInit {
	var out SensorErrorEventInit
	var (
		value0 bool                  // javascript: boolean {bubbles Bubbles bubbles}
		value1 bool                  // javascript: boolean {cancelable Cancelable cancelable}
		value2 bool                  // javascript: boolean {composed Composed composed}
		value3 *domcore.DOMException // javascript: DOMException {error Error _error}
	)
	value0 = (value.Get("bubbles")).Bool()
	out.Bubbles = value0
	value1 = (value.Get("cancelable")).Bool()
	out.Cancelable = value1
	value2 = (value.Get("composed")).Bool()
	out.Composed = value2
	value3 = domcore.DOMExceptionFromJS(value.Get("error"))
	out.Error = value3
	return &out
}

// dictionary: SensorOptions
type SensorOptions struct {
	Frequency float64
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *SensorOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Frequency
	out.Set("frequency", value0)
	return out
}

// SensorOptionsFromJS is allocating a new
// SensorOptions object and copy all values in the value javascript object.
func SensorOptionsFromJS(value js.Value) *SensorOptions {
	var out SensorOptions
	var (
		value0 float64 // javascript: double {frequency Frequency frequency}
	)
	value0 = (value.Get("frequency")).Float()
	out.Frequency = value0
	return &out
}

// dictionary: UncalibratedMagnetometerReadingValues
type UncalibratedMagnetometerReadingValues struct {
	X     *float64
	Y     *float64
	Z     *float64
	XBias *float64
	YBias *float64
	ZBias *float64
}

// JSValue is allocating a new javascript object and copy
// all values
func (_this *UncalibratedMagnetometerReadingValues) JSValue() js.Value {
	out := js.Global().Get("Object").New()

	var value0 interface{}
	if _this.X != nil {
		value0 = *(_this.X)
	} else {
		value0 = nil
	}
	out.Set("x", value0)

	var value1 interface{}
	if _this.Y != nil {
		value1 = *(_this.Y)
	} else {
		value1 = nil
	}
	out.Set("y", value1)

	var value2 interface{}
	if _this.Z != nil {
		value2 = *(_this.Z)
	} else {
		value2 = nil
	}
	out.Set("z", value2)

	var value3 interface{}
	if _this.XBias != nil {
		value3 = *(_this.XBias)
	} else {
		value3 = nil
	}
	out.Set("xBias", value3)

	var value4 interface{}
	if _this.YBias != nil {
		value4 = *(_this.YBias)
	} else {
		value4 = nil
	}
	out.Set("yBias", value4)

	var value5 interface{}
	if _this.ZBias != nil {
		value5 = *(_this.ZBias)
	} else {
		value5 = nil
	}
	out.Set("zBias", value5)
	return out
}

// UncalibratedMagnetometerReadingValuesFromJS is allocating a new
// UncalibratedMagnetometerReadingValues object and copy all values in the value javascript object.
func UncalibratedMagnetometerReadingValuesFromJS(value js.Value) *UncalibratedMagnetometerReadingValues {
	var out UncalibratedMagnetometerReadingValues
	var (
		value0 *float64 // javascript: double {x X x}
		value1 *float64 // javascript: double {y Y y}
		value2 *float64 // javascript: double {z Z z}
		value3 *float64 // javascript: double {xBias XBias xBias}
		value4 *float64 // javascript: double {yBias YBias yBias}
		value5 *float64 // javascript: double {zBias ZBias zBias}
	)
	if value.Get("x").Type() != js.TypeNull && value.Get("x").Type() != js.TypeUndefined {
		__tmp := (value.Get("x")).Float()
		value0 = &__tmp
	}
	out.X = value0
	if value.Get("y").Type() != js.TypeNull && value.Get("y").Type() != js.TypeUndefined {
		__tmp := (value.Get("y")).Float()
		value1 = &__tmp
	}
	out.Y = value1
	if value.Get("z").Type() != js.TypeNull && value.Get("z").Type() != js.TypeUndefined {
		__tmp := (value.Get("z")).Float()
		value2 = &__tmp
	}
	out.Z = value2
	if value.Get("xBias").Type() != js.TypeNull && value.Get("xBias").Type() != js.TypeUndefined {
		__tmp := (value.Get("xBias")).Float()
		value3 = &__tmp
	}
	out.XBias = value3
	if value.Get("yBias").Type() != js.TypeNull && value.Get("yBias").Type() != js.TypeUndefined {
		__tmp := (value.Get("yBias")).Float()
		value4 = &__tmp
	}
	out.YBias = value4
	if value.Get("zBias").Type() != js.TypeNull && value.Get("zBias").Type() != js.TypeUndefined {
		__tmp := (value.Get("zBias")).Float()
		value5 = &__tmp
	}
	out.ZBias = value5
	return &out
}

// class: AbsoluteOrientationSensor
type AbsoluteOrientationSensor struct {
	OrientationSensor
}

// AbsoluteOrientationSensorFromJS is casting a js.Value into AbsoluteOrientationSensor.
func AbsoluteOrientationSensorFromJS(value js.Value) *AbsoluteOrientationSensor {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &AbsoluteOrientationSensor{}
	ret.Value_JS = value
	return ret
}

// AbsoluteOrientationSensorFromJS is casting from something that holds a js.Value into AbsoluteOrientationSensor.
func AbsoluteOrientationSensorFromWrapper(input core.Wrapper) *AbsoluteOrientationSensor {
	return AbsoluteOrientationSensorFromJS(input.JSValue())
}

func NewAbsoluteOrientationSensor(sensorOptions *OrientationSensorOptions) (_result *AbsoluteOrientationSensor) {
	_klass := js.Global().Get("AbsoluteOrientationSensor")
	var (
		_args [1]interface{}
		_end  int
	)
	if sensorOptions != nil {
		_p0 := sensorOptions.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *AbsoluteOrientationSensor // javascript: AbsoluteOrientationSensor _what_return_name
	)
	_converted = AbsoluteOrientationSensorFromJS(_returned)
	_result = _converted
	return
}

// class: Accelerometer
type Accelerometer struct {
	Sensor
}

// AccelerometerFromJS is casting a js.Value into Accelerometer.
func AccelerometerFromJS(value js.Value) *Accelerometer {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Accelerometer{}
	ret.Value_JS = value
	return ret
}

// AccelerometerFromJS is casting from something that holds a js.Value into Accelerometer.
func AccelerometerFromWrapper(input core.Wrapper) *Accelerometer {
	return AccelerometerFromJS(input.JSValue())
}

func NewAccelerometer(options *AccelerometerSensorOptions) (_result *Accelerometer) {
	_klass := js.Global().Get("Accelerometer")
	var (
		_args [1]interface{}
		_end  int
	)
	if options != nil {
		_p0 := options.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *Accelerometer // javascript: Accelerometer _what_return_name
	)
	_converted = AccelerometerFromJS(_returned)
	_result = _converted
	return
}

// X returning attribute 'x' with
// type float64 (idl: double).
func (_this *Accelerometer) X() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("x")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Y returning attribute 'y' with
// type float64 (idl: double).
func (_this *Accelerometer) Y() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("y")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Z returning attribute 'z' with
// type float64 (idl: double).
func (_this *Accelerometer) Z() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("z")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// class: AmbientLightSensor
type AmbientLightSensor struct {
	Sensor
}

// AmbientLightSensorFromJS is casting a js.Value into AmbientLightSensor.
func AmbientLightSensorFromJS(value js.Value) *AmbientLightSensor {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &AmbientLightSensor{}
	ret.Value_JS = value
	return ret
}

// AmbientLightSensorFromJS is casting from something that holds a js.Value into AmbientLightSensor.
func AmbientLightSensorFromWrapper(input core.Wrapper) *AmbientLightSensor {
	return AmbientLightSensorFromJS(input.JSValue())
}

func NewAmbientLightSensor(sensorOptions *SensorOptions) (_result *AmbientLightSensor) {
	_klass := js.Global().Get("AmbientLightSensor")
	var (
		_args [1]interface{}
		_end  int
	)
	if sensorOptions != nil {
		_p0 := sensorOptions.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *AmbientLightSensor // javascript: AmbientLightSensor _what_return_name
	)
	_converted = AmbientLightSensorFromJS(_returned)
	_result = _converted
	return
}

// Illuminance returning attribute 'illuminance' with
// type float64 (idl: double).
func (_this *AmbientLightSensor) Illuminance() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("illuminance")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// class: Coordinates
type Coordinates struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *Coordinates) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// CoordinatesFromJS is casting a js.Value into Coordinates.
func CoordinatesFromJS(value js.Value) *Coordinates {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Coordinates{}
	ret.Value_JS = value
	return ret
}

// CoordinatesFromJS is casting from something that holds a js.Value into Coordinates.
func CoordinatesFromWrapper(input core.Wrapper) *Coordinates {
	return CoordinatesFromJS(input.JSValue())
}

// Latitude returning attribute 'latitude' with
// type float64 (idl: double).
func (_this *Coordinates) Latitude() float64 {
	var ret float64
	value := _this.Value_JS.Get("latitude")
	ret = (value).Float()
	return ret
}

// Longitude returning attribute 'longitude' with
// type float64 (idl: double).
func (_this *Coordinates) Longitude() float64 {
	var ret float64
	value := _this.Value_JS.Get("longitude")
	ret = (value).Float()
	return ret
}

// Altitude returning attribute 'altitude' with
// type float64 (idl: double).
func (_this *Coordinates) Altitude() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("altitude")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Accuracy returning attribute 'accuracy' with
// type float64 (idl: double).
func (_this *Coordinates) Accuracy() float64 {
	var ret float64
	value := _this.Value_JS.Get("accuracy")
	ret = (value).Float()
	return ret
}

// AltitudeAccuracy returning attribute 'altitudeAccuracy' with
// type float64 (idl: double).
func (_this *Coordinates) AltitudeAccuracy() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("altitudeAccuracy")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Heading returning attribute 'heading' with
// type float64 (idl: double).
func (_this *Coordinates) Heading() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("heading")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Speed returning attribute 'speed' with
// type float64 (idl: double).
func (_this *Coordinates) Speed() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("speed")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// class: DeviceAcceleration
type DeviceAcceleration struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *DeviceAcceleration) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// DeviceAccelerationFromJS is casting a js.Value into DeviceAcceleration.
func DeviceAccelerationFromJS(value js.Value) *DeviceAcceleration {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &DeviceAcceleration{}
	ret.Value_JS = value
	return ret
}

// DeviceAccelerationFromJS is casting from something that holds a js.Value into DeviceAcceleration.
func DeviceAccelerationFromWrapper(input core.Wrapper) *DeviceAcceleration {
	return DeviceAccelerationFromJS(input.JSValue())
}

// X returning attribute 'x' with
// type float64 (idl: double).
func (_this *DeviceAcceleration) X() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("x")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Y returning attribute 'y' with
// type float64 (idl: double).
func (_this *DeviceAcceleration) Y() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("y")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Z returning attribute 'z' with
// type float64 (idl: double).
func (_this *DeviceAcceleration) Z() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("z")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// class: DeviceMotionEvent
type DeviceMotionEvent struct {
	domcore.Event
}

// DeviceMotionEventFromJS is casting a js.Value into DeviceMotionEvent.
func DeviceMotionEventFromJS(value js.Value) *DeviceMotionEvent {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &DeviceMotionEvent{}
	ret.Value_JS = value
	return ret
}

// DeviceMotionEventFromJS is casting from something that holds a js.Value into DeviceMotionEvent.
func DeviceMotionEventFromWrapper(input core.Wrapper) *DeviceMotionEvent {
	return DeviceMotionEventFromJS(input.JSValue())
}

func NewDeviceMotionEvent(_type string, eventInitDict *DeviceMotionEventInit) (_result *DeviceMotionEvent) {
	_klass := js.Global().Get("DeviceMotionEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	if eventInitDict != nil {
		_p1 := eventInitDict.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *DeviceMotionEvent // javascript: DeviceMotionEvent _what_return_name
	)
	_converted = DeviceMotionEventFromJS(_returned)
	_result = _converted
	return
}

// Acceleration returning attribute 'acceleration' with
// type DeviceAcceleration (idl: DeviceAcceleration).
func (_this *DeviceMotionEvent) Acceleration() *DeviceAcceleration {
	var ret *DeviceAcceleration
	value := _this.Value_JS.Get("acceleration")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = DeviceAccelerationFromJS(value)
	}
	return ret
}

// AccelerationIncludingGravity returning attribute 'accelerationIncludingGravity' with
// type DeviceAcceleration (idl: DeviceAcceleration).
func (_this *DeviceMotionEvent) AccelerationIncludingGravity() *DeviceAcceleration {
	var ret *DeviceAcceleration
	value := _this.Value_JS.Get("accelerationIncludingGravity")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = DeviceAccelerationFromJS(value)
	}
	return ret
}

// RotationRate returning attribute 'rotationRate' with
// type DeviceRotationRate (idl: DeviceRotationRate).
func (_this *DeviceMotionEvent) RotationRate() *DeviceRotationRate {
	var ret *DeviceRotationRate
	value := _this.Value_JS.Get("rotationRate")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = DeviceRotationRateFromJS(value)
	}
	return ret
}

// Interval returning attribute 'interval' with
// type float64 (idl: double).
func (_this *DeviceMotionEvent) Interval() float64 {
	var ret float64
	value := _this.Value_JS.Get("interval")
	ret = (value).Float()
	return ret
}

// class: DeviceOrientationEvent
type DeviceOrientationEvent struct {
	domcore.Event
}

// DeviceOrientationEventFromJS is casting a js.Value into DeviceOrientationEvent.
func DeviceOrientationEventFromJS(value js.Value) *DeviceOrientationEvent {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &DeviceOrientationEvent{}
	ret.Value_JS = value
	return ret
}

// DeviceOrientationEventFromJS is casting from something that holds a js.Value into DeviceOrientationEvent.
func DeviceOrientationEventFromWrapper(input core.Wrapper) *DeviceOrientationEvent {
	return DeviceOrientationEventFromJS(input.JSValue())
}

func NewDeviceOrientationEvent(_type string, eventInitDict *DeviceOrientationEventInit) (_result *DeviceOrientationEvent) {
	_klass := js.Global().Get("DeviceOrientationEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	if eventInitDict != nil {
		_p1 := eventInitDict.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *DeviceOrientationEvent // javascript: DeviceOrientationEvent _what_return_name
	)
	_converted = DeviceOrientationEventFromJS(_returned)
	_result = _converted
	return
}

// Alpha returning attribute 'alpha' with
// type float64 (idl: double).
func (_this *DeviceOrientationEvent) Alpha() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("alpha")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Beta returning attribute 'beta' with
// type float64 (idl: double).
func (_this *DeviceOrientationEvent) Beta() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("beta")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Gamma returning attribute 'gamma' with
// type float64 (idl: double).
func (_this *DeviceOrientationEvent) Gamma() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("gamma")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Absolute returning attribute 'absolute' with
// type bool (idl: boolean).
func (_this *DeviceOrientationEvent) Absolute() bool {
	var ret bool
	value := _this.Value_JS.Get("absolute")
	ret = (value).Bool()
	return ret
}

// class: DeviceRotationRate
type DeviceRotationRate struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *DeviceRotationRate) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// DeviceRotationRateFromJS is casting a js.Value into DeviceRotationRate.
func DeviceRotationRateFromJS(value js.Value) *DeviceRotationRate {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &DeviceRotationRate{}
	ret.Value_JS = value
	return ret
}

// DeviceRotationRateFromJS is casting from something that holds a js.Value into DeviceRotationRate.
func DeviceRotationRateFromWrapper(input core.Wrapper) *DeviceRotationRate {
	return DeviceRotationRateFromJS(input.JSValue())
}

// Alpha returning attribute 'alpha' with
// type float64 (idl: double).
func (_this *DeviceRotationRate) Alpha() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("alpha")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Beta returning attribute 'beta' with
// type float64 (idl: double).
func (_this *DeviceRotationRate) Beta() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("beta")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Gamma returning attribute 'gamma' with
// type float64 (idl: double).
func (_this *DeviceRotationRate) Gamma() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("gamma")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// class: Geolocation
type Geolocation struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *Geolocation) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// GeolocationFromJS is casting a js.Value into Geolocation.
func GeolocationFromJS(value js.Value) *Geolocation {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Geolocation{}
	ret.Value_JS = value
	return ret
}

// GeolocationFromJS is casting from something that holds a js.Value into Geolocation.
func GeolocationFromWrapper(input core.Wrapper) *Geolocation {
	return GeolocationFromJS(input.JSValue())
}

func (_this *Geolocation) GetCurrentPosition(successCallback *PositionCallback, errorCallback *PositionErrorCallback, options *PositionOptions) {
	var (
		_args [3]interface{}
		_end  int
	)

	var __callback0 js.Value
	if successCallback != nil {
		__callback0 = (*successCallback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if errorCallback != nil {

		var __callback1 js.Value
		if errorCallback != nil {
			__callback1 = (*errorCallback).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	if options != nil {
		_p2 := options.JSValue()
		_args[2] = _p2
		_end++
	}
	_this.Value_JS.Call("getCurrentPosition", _args[0:_end]...)
	return
}

func (_this *Geolocation) WatchPosition(successCallback *PositionCallback, errorCallback *PositionErrorCallback, options *PositionOptions) (_result int) {
	var (
		_args [3]interface{}
		_end  int
	)

	var __callback0 js.Value
	if successCallback != nil {
		__callback0 = (*successCallback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if errorCallback != nil {

		var __callback1 js.Value
		if errorCallback != nil {
			__callback1 = (*errorCallback).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	if options != nil {
		_p2 := options.JSValue()
		_args[2] = _p2
		_end++
	}
	_returned := _this.Value_JS.Call("watchPosition", _args[0:_end]...)
	var (
		_converted int // javascript: long _what_return_name
	)
	_converted = (_returned).Int()
	_result = _converted
	return
}

func (_this *Geolocation) ClearWatch(watchId int) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := watchId
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("clearWatch", _args[0:_end]...)
	return
}

// class: GeolocationSensor
type GeolocationSensor struct {
	Sensor
}

// GeolocationSensorFromJS is casting a js.Value into GeolocationSensor.
func GeolocationSensorFromJS(value js.Value) *GeolocationSensor {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &GeolocationSensor{}
	ret.Value_JS = value
	return ret
}

// GeolocationSensorFromJS is casting from something that holds a js.Value into GeolocationSensor.
func GeolocationSensorFromWrapper(input core.Wrapper) *GeolocationSensor {
	return GeolocationSensorFromJS(input.JSValue())
}

func Read(readOptions *ReadOptions) (_result *PromiseGeolocationSensorReading) {
	_klass := js.Global().Get("GeolocationSensor")
	_method := _klass.Get("read")
	var (
		_args [1]interface{}
		_end  int
	)
	if readOptions != nil {
		_p0 := readOptions.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted *PromiseGeolocationSensorReading // javascript: Promise _what_return_name
	)
	_converted = PromiseGeolocationSensorReadingFromJS(_returned)
	_result = _converted
	return
}

func NewGeolocationSensor(options *GeolocationSensorOptions) (_result *GeolocationSensor) {
	_klass := js.Global().Get("GeolocationSensor")
	var (
		_args [1]interface{}
		_end  int
	)
	if options != nil {
		_p0 := options.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *GeolocationSensor // javascript: GeolocationSensor _what_return_name
	)
	_converted = GeolocationSensorFromJS(_returned)
	_result = _converted
	return
}

// Latitude returning attribute 'latitude' with
// type float64 (idl: unrestricted double).
func (_this *GeolocationSensor) Latitude() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("latitude")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Longitude returning attribute 'longitude' with
// type float64 (idl: unrestricted double).
func (_this *GeolocationSensor) Longitude() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("longitude")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Altitude returning attribute 'altitude' with
// type float64 (idl: unrestricted double).
func (_this *GeolocationSensor) Altitude() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("altitude")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Accuracy returning attribute 'accuracy' with
// type float64 (idl: unrestricted double).
func (_this *GeolocationSensor) Accuracy() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("accuracy")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// AltitudeAccuracy returning attribute 'altitudeAccuracy' with
// type float64 (idl: unrestricted double).
func (_this *GeolocationSensor) AltitudeAccuracy() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("altitudeAccuracy")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Heading returning attribute 'heading' with
// type float64 (idl: unrestricted double).
func (_this *GeolocationSensor) Heading() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("heading")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Speed returning attribute 'speed' with
// type float64 (idl: unrestricted double).
func (_this *GeolocationSensor) Speed() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("speed")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// class: GravitySensor
type GravitySensor struct {
	Accelerometer
}

// GravitySensorFromJS is casting a js.Value into GravitySensor.
func GravitySensorFromJS(value js.Value) *GravitySensor {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &GravitySensor{}
	ret.Value_JS = value
	return ret
}

// GravitySensorFromJS is casting from something that holds a js.Value into GravitySensor.
func GravitySensorFromWrapper(input core.Wrapper) *GravitySensor {
	return GravitySensorFromJS(input.JSValue())
}

func NewGravitySensor(options *AccelerometerSensorOptions) (_result *GravitySensor) {
	_klass := js.Global().Get("GravitySensor")
	var (
		_args [1]interface{}
		_end  int
	)
	if options != nil {
		_p0 := options.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *GravitySensor // javascript: GravitySensor _what_return_name
	)
	_converted = GravitySensorFromJS(_returned)
	_result = _converted
	return
}

// class: Gyroscope
type Gyroscope struct {
	Sensor
}

// GyroscopeFromJS is casting a js.Value into Gyroscope.
func GyroscopeFromJS(value js.Value) *Gyroscope {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Gyroscope{}
	ret.Value_JS = value
	return ret
}

// GyroscopeFromJS is casting from something that holds a js.Value into Gyroscope.
func GyroscopeFromWrapper(input core.Wrapper) *Gyroscope {
	return GyroscopeFromJS(input.JSValue())
}

func NewGyroscope(sensorOptions *GyroscopeSensorOptions) (_result *Gyroscope) {
	_klass := js.Global().Get("Gyroscope")
	var (
		_args [1]interface{}
		_end  int
	)
	if sensorOptions != nil {
		_p0 := sensorOptions.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *Gyroscope // javascript: Gyroscope _what_return_name
	)
	_converted = GyroscopeFromJS(_returned)
	_result = _converted
	return
}

// X returning attribute 'x' with
// type float64 (idl: double).
func (_this *Gyroscope) X() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("x")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Y returning attribute 'y' with
// type float64 (idl: double).
func (_this *Gyroscope) Y() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("y")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Z returning attribute 'z' with
// type float64 (idl: double).
func (_this *Gyroscope) Z() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("z")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// class: LinearAccelerationSensor
type LinearAccelerationSensor struct {
	Accelerometer
}

// LinearAccelerationSensorFromJS is casting a js.Value into LinearAccelerationSensor.
func LinearAccelerationSensorFromJS(value js.Value) *LinearAccelerationSensor {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &LinearAccelerationSensor{}
	ret.Value_JS = value
	return ret
}

// LinearAccelerationSensorFromJS is casting from something that holds a js.Value into LinearAccelerationSensor.
func LinearAccelerationSensorFromWrapper(input core.Wrapper) *LinearAccelerationSensor {
	return LinearAccelerationSensorFromJS(input.JSValue())
}

func NewLinearAccelerationSensor(options *AccelerometerSensorOptions) (_result *LinearAccelerationSensor) {
	_klass := js.Global().Get("LinearAccelerationSensor")
	var (
		_args [1]interface{}
		_end  int
	)
	if options != nil {
		_p0 := options.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *LinearAccelerationSensor // javascript: LinearAccelerationSensor _what_return_name
	)
	_converted = LinearAccelerationSensorFromJS(_returned)
	_result = _converted
	return
}

// class: Magnetometer
type Magnetometer struct {
	Sensor
}

// MagnetometerFromJS is casting a js.Value into Magnetometer.
func MagnetometerFromJS(value js.Value) *Magnetometer {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Magnetometer{}
	ret.Value_JS = value
	return ret
}

// MagnetometerFromJS is casting from something that holds a js.Value into Magnetometer.
func MagnetometerFromWrapper(input core.Wrapper) *Magnetometer {
	return MagnetometerFromJS(input.JSValue())
}

func NewMagnetometer(sensorOptions *MagnetometerSensorOptions) (_result *Magnetometer) {
	_klass := js.Global().Get("Magnetometer")
	var (
		_args [1]interface{}
		_end  int
	)
	if sensorOptions != nil {
		_p0 := sensorOptions.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *Magnetometer // javascript: Magnetometer _what_return_name
	)
	_converted = MagnetometerFromJS(_returned)
	_result = _converted
	return
}

// X returning attribute 'x' with
// type float64 (idl: double).
func (_this *Magnetometer) X() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("x")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Y returning attribute 'y' with
// type float64 (idl: double).
func (_this *Magnetometer) Y() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("y")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Z returning attribute 'z' with
// type float64 (idl: double).
func (_this *Magnetometer) Z() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("z")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// class: OrientationSensor
type OrientationSensor struct {
	Sensor
}

// OrientationSensorFromJS is casting a js.Value into OrientationSensor.
func OrientationSensorFromJS(value js.Value) *OrientationSensor {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &OrientationSensor{}
	ret.Value_JS = value
	return ret
}

// OrientationSensorFromJS is casting from something that holds a js.Value into OrientationSensor.
func OrientationSensorFromWrapper(input core.Wrapper) *OrientationSensor {
	return OrientationSensorFromJS(input.JSValue())
}

// Quaternion returning attribute 'quaternion' with
// type javascript.FrozenArray (idl: FrozenArray).
func (_this *OrientationSensor) Quaternion() *javascript.FrozenArray {
	var ret *javascript.FrozenArray
	value := _this.Value_JS.Get("quaternion")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = javascript.FrozenArrayFromJS(value)
	}
	return ret
}

func (_this *OrientationSensor) PopulateMatrix(targetMatrix *Union) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := targetMatrix.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("populateMatrix", _args[0:_end]...)
	return
}

// class: Position
type Position struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *Position) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// PositionFromJS is casting a js.Value into Position.
func PositionFromJS(value js.Value) *Position {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Position{}
	ret.Value_JS = value
	return ret
}

// PositionFromJS is casting from something that holds a js.Value into Position.
func PositionFromWrapper(input core.Wrapper) *Position {
	return PositionFromJS(input.JSValue())
}

// Coords returning attribute 'coords' with
// type Coordinates (idl: Coordinates).
func (_this *Position) Coords() *Coordinates {
	var ret *Coordinates
	value := _this.Value_JS.Get("coords")
	ret = CoordinatesFromJS(value)
	return ret
}

// Timestamp returning attribute 'timestamp' with
// type int (idl: unsigned long long).
func (_this *Position) Timestamp() int {
	var ret int
	value := _this.Value_JS.Get("timestamp")
	ret = (value).Int()
	return ret
}

// class: PositionError
type PositionError struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *PositionError) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// PositionErrorFromJS is casting a js.Value into PositionError.
func PositionErrorFromJS(value js.Value) *PositionError {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PositionError{}
	ret.Value_JS = value
	return ret
}

// PositionErrorFromJS is casting from something that holds a js.Value into PositionError.
func PositionErrorFromWrapper(input core.Wrapper) *PositionError {
	return PositionErrorFromJS(input.JSValue())
}

const (
	PERMISSIONDENIED_PositionError    int = 1
	POSITIONUNAVAILABLE_PositionError int = 2
	TIMEOUT_PositionError             int = 3
)

// Code returning attribute 'code' with
// type int (idl: unsigned short).
func (_this *PositionError) Code() int {
	var ret int
	value := _this.Value_JS.Get("code")
	ret = (value).Int()
	return ret
}

// Message returning attribute 'message' with
// type string (idl: DOMString).
func (_this *PositionError) Message() string {
	var ret string
	value := _this.Value_JS.Get("message")
	ret = (value).String()
	return ret
}

// class: Promise
type PromiseGeolocationSensorReading struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

// JSValue returns the js.Value or js.Null() if _this is nil
func (_this *PromiseGeolocationSensorReading) JSValue() js.Value {
	if _this == nil {
		return js.Null()
	}
	return _this.Value_JS
}

// PromiseGeolocationSensorReadingFromJS is casting a js.Value into PromiseGeolocationSensorReading.
func PromiseGeolocationSensorReadingFromJS(value js.Value) *PromiseGeolocationSensorReading {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseGeolocationSensorReading{}
	ret.Value_JS = value
	return ret
}

// PromiseGeolocationSensorReadingFromJS is casting from something that holds a js.Value into PromiseGeolocationSensorReading.
func PromiseGeolocationSensorReadingFromWrapper(input core.Wrapper) *PromiseGeolocationSensorReading {
	return PromiseGeolocationSensorReadingFromJS(input.JSValue())
}

func (_this *PromiseGeolocationSensorReading) Then(onFulfilled *PromiseGeolocationSensorReadingOnFulfilled, onRejected *PromiseGeolocationSensorReadingOnRejected) (_result *PromiseGeolocationSensorReading) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseGeolocationSensorReading // javascript: Promise _what_return_name
	)
	_converted = PromiseGeolocationSensorReadingFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseGeolocationSensorReading) Catch(onRejected *PromiseGeolocationSensorReadingOnRejected) (_result *PromiseGeolocationSensorReading) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseGeolocationSensorReading // javascript: Promise _what_return_name
	)
	_converted = PromiseGeolocationSensorReadingFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseGeolocationSensorReading) Finally(onFinally *javascript.PromiseFinally) (_result *PromiseGeolocationSensorReading) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseGeolocationSensorReading // javascript: Promise _what_return_name
	)
	_converted = PromiseGeolocationSensorReadingFromJS(_returned)
	_result = _converted
	return
}

// class: ProximitySensor
type ProximitySensor struct {
	Sensor
}

// ProximitySensorFromJS is casting a js.Value into ProximitySensor.
func ProximitySensorFromJS(value js.Value) *ProximitySensor {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &ProximitySensor{}
	ret.Value_JS = value
	return ret
}

// ProximitySensorFromJS is casting from something that holds a js.Value into ProximitySensor.
func ProximitySensorFromWrapper(input core.Wrapper) *ProximitySensor {
	return ProximitySensorFromJS(input.JSValue())
}

func NewProximitySensor(sensorOptions *SensorOptions) (_result *ProximitySensor) {
	_klass := js.Global().Get("ProximitySensor")
	var (
		_args [1]interface{}
		_end  int
	)
	if sensorOptions != nil {
		_p0 := sensorOptions.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *ProximitySensor // javascript: ProximitySensor _what_return_name
	)
	_converted = ProximitySensorFromJS(_returned)
	_result = _converted
	return
}

// Distance returning attribute 'distance' with
// type float64 (idl: double).
func (_this *ProximitySensor) Distance() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("distance")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Max returning attribute 'max' with
// type float64 (idl: double).
func (_this *ProximitySensor) Max() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("max")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Near returning attribute 'near' with
// type bool (idl: boolean).
func (_this *ProximitySensor) Near() *bool {
	var ret *bool
	value := _this.Value_JS.Get("near")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Bool()
		ret = &__tmp
	}
	return ret
}

// class: RelativeOrientationSensor
type RelativeOrientationSensor struct {
	OrientationSensor
}

// RelativeOrientationSensorFromJS is casting a js.Value into RelativeOrientationSensor.
func RelativeOrientationSensorFromJS(value js.Value) *RelativeOrientationSensor {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &RelativeOrientationSensor{}
	ret.Value_JS = value
	return ret
}

// RelativeOrientationSensorFromJS is casting from something that holds a js.Value into RelativeOrientationSensor.
func RelativeOrientationSensorFromWrapper(input core.Wrapper) *RelativeOrientationSensor {
	return RelativeOrientationSensorFromJS(input.JSValue())
}

func NewRelativeOrientationSensor(sensorOptions *OrientationSensorOptions) (_result *RelativeOrientationSensor) {
	_klass := js.Global().Get("RelativeOrientationSensor")
	var (
		_args [1]interface{}
		_end  int
	)
	if sensorOptions != nil {
		_p0 := sensorOptions.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *RelativeOrientationSensor // javascript: RelativeOrientationSensor _what_return_name
	)
	_converted = RelativeOrientationSensorFromJS(_returned)
	_result = _converted
	return
}

// class: Sensor
type Sensor struct {
	domcore.EventTarget
}

// SensorFromJS is casting a js.Value into Sensor.
func SensorFromJS(value js.Value) *Sensor {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Sensor{}
	ret.Value_JS = value
	return ret
}

// SensorFromJS is casting from something that holds a js.Value into Sensor.
func SensorFromWrapper(input core.Wrapper) *Sensor {
	return SensorFromJS(input.JSValue())
}

// Activated returning attribute 'activated' with
// type bool (idl: boolean).
func (_this *Sensor) Activated() bool {
	var ret bool
	value := _this.Value_JS.Get("activated")
	ret = (value).Bool()
	return ret
}

// HasReading returning attribute 'hasReading' with
// type bool (idl: boolean).
func (_this *Sensor) HasReading() bool {
	var ret bool
	value := _this.Value_JS.Get("hasReading")
	ret = (value).Bool()
	return ret
}

// Timestamp returning attribute 'timestamp' with
// type float64 (idl: double).
func (_this *Sensor) Timestamp() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("timestamp")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// OnReading returning attribute 'onreading' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *Sensor) OnReading() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onreading")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnActivate returning attribute 'onactivate' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *Sensor) OnActivate() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onactivate")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// OnError returning attribute 'onerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *Sensor) OnError() domcore.EventHandlerFunc {
	var ret domcore.EventHandlerFunc
	value := _this.Value_JS.Get("onerror")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// event attribute: domcore.Event
func eventFuncSensor_domcore_Event(listener func(event *domcore.Event, target *Sensor)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *domcore.Event
		value := args[0]
		incoming := value.Get("target")
		ret = domcore.EventFromJS(value)
		src := SensorFromJS(incoming)
		listener(ret, src)
		return js.Undefined()
	}
	return js.FuncOf(fn)
}

// AddActivate is adding doing AddEventListener for 'Activate' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *Sensor) AddEventActivate(listener func(event *domcore.Event, currentTarget *Sensor)) js.Func {
	cb := eventFuncSensor_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "activate", cb)
	return cb
}

// SetOnActivate is assigning a function to 'onactivate'. This
// This method is returning allocated javascript function that need to be released.
func (_this *Sensor) SetOnActivate(listener func(event *domcore.Event, currentTarget *Sensor)) js.Func {
	cb := eventFuncSensor_domcore_Event(listener)
	_this.Value_JS.Set("onactivate", cb)
	return cb
}

// event attribute: SensorErrorEvent
func eventFuncSensor_SensorErrorEvent(listener func(event *SensorErrorEvent, target *Sensor)) js.Func {
	fn := func(this js.Value, args []js.Value) interface{} {
		var ret *SensorErrorEvent
		value := args[0]
		incoming := value.Get("target")
		ret = SensorErrorEventFromJS(value)
		src := SensorFromJS(incoming)
		listener(ret, src)
		return js.Undefined()
	}
	return js.FuncOf(fn)
}

// AddError is adding doing AddEventListener for 'Error' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *Sensor) AddEventError(listener func(event *SensorErrorEvent, currentTarget *Sensor)) js.Func {
	cb := eventFuncSensor_SensorErrorEvent(listener)
	_this.Value_JS.Call("addEventListener", "error", cb)
	return cb
}

// SetOnError is assigning a function to 'onerror'. This
// This method is returning allocated javascript function that need to be released.
func (_this *Sensor) SetOnError(listener func(event *SensorErrorEvent, currentTarget *Sensor)) js.Func {
	cb := eventFuncSensor_SensorErrorEvent(listener)
	_this.Value_JS.Set("onerror", cb)
	return cb
}

// AddReading is adding doing AddEventListener for 'Reading' on target.
// This method is returning allocated javascript function that need to be released.
func (_this *Sensor) AddEventReading(listener func(event *domcore.Event, currentTarget *Sensor)) js.Func {
	cb := eventFuncSensor_domcore_Event(listener)
	_this.Value_JS.Call("addEventListener", "reading", cb)
	return cb
}

// SetOnReading is assigning a function to 'onreading'. This
// This method is returning allocated javascript function that need to be released.
func (_this *Sensor) SetOnReading(listener func(event *domcore.Event, currentTarget *Sensor)) js.Func {
	cb := eventFuncSensor_domcore_Event(listener)
	_this.Value_JS.Set("onreading", cb)
	return cb
}

func (_this *Sensor) Start() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("start", _args[0:_end]...)
	return
}

func (_this *Sensor) Stop() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("stop", _args[0:_end]...)
	return
}

// class: SensorErrorEvent
type SensorErrorEvent struct {
	domcore.Event
}

// SensorErrorEventFromJS is casting a js.Value into SensorErrorEvent.
func SensorErrorEventFromJS(value js.Value) *SensorErrorEvent {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &SensorErrorEvent{}
	ret.Value_JS = value
	return ret
}

// SensorErrorEventFromJS is casting from something that holds a js.Value into SensorErrorEvent.
func SensorErrorEventFromWrapper(input core.Wrapper) *SensorErrorEvent {
	return SensorErrorEventFromJS(input.JSValue())
}

func NewSensorErrorEvent(_type string, errorEventInitDict *SensorErrorEventInit) (_result *SensorErrorEvent) {
	_klass := js.Global().Get("SensorErrorEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	_p1 := errorEventInitDict.JSValue()
	_args[1] = _p1
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *SensorErrorEvent // javascript: SensorErrorEvent _what_return_name
	)
	_converted = SensorErrorEventFromJS(_returned)
	_result = _converted
	return
}

// Error returning attribute 'error' with
// type domcore.DOMException (idl: DOMException).
func (_this *SensorErrorEvent) Error() *domcore.DOMException {
	var ret *domcore.DOMException
	value := _this.Value_JS.Get("error")
	ret = domcore.DOMExceptionFromJS(value)
	return ret
}

// class: UncalibratedMagnetometer
type UncalibratedMagnetometer struct {
	Sensor
}

// UncalibratedMagnetometerFromJS is casting a js.Value into UncalibratedMagnetometer.
func UncalibratedMagnetometerFromJS(value js.Value) *UncalibratedMagnetometer {
	if typ := value.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &UncalibratedMagnetometer{}
	ret.Value_JS = value
	return ret
}

// UncalibratedMagnetometerFromJS is casting from something that holds a js.Value into UncalibratedMagnetometer.
func UncalibratedMagnetometerFromWrapper(input core.Wrapper) *UncalibratedMagnetometer {
	return UncalibratedMagnetometerFromJS(input.JSValue())
}

func NewUncalibratedMagnetometer(sensorOptions *MagnetometerSensorOptions) (_result *UncalibratedMagnetometer) {
	_klass := js.Global().Get("UncalibratedMagnetometer")
	var (
		_args [1]interface{}
		_end  int
	)
	if sensorOptions != nil {
		_p0 := sensorOptions.JSValue()
		_args[0] = _p0
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *UncalibratedMagnetometer // javascript: UncalibratedMagnetometer _what_return_name
	)
	_converted = UncalibratedMagnetometerFromJS(_returned)
	_result = _converted
	return
}

// X returning attribute 'x' with
// type float64 (idl: double).
func (_this *UncalibratedMagnetometer) X() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("x")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Y returning attribute 'y' with
// type float64 (idl: double).
func (_this *UncalibratedMagnetometer) Y() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("y")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// Z returning attribute 'z' with
// type float64 (idl: double).
func (_this *UncalibratedMagnetometer) Z() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("z")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// XBias returning attribute 'xBias' with
// type float64 (idl: double).
func (_this *UncalibratedMagnetometer) XBias() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("xBias")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// YBias returning attribute 'yBias' with
// type float64 (idl: double).
func (_this *UncalibratedMagnetometer) YBias() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("yBias")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}

// ZBias returning attribute 'zBias' with
// type float64 (idl: double).
func (_this *UncalibratedMagnetometer) ZBias() *float64 {
	var ret *float64
	value := _this.Value_JS.Get("zBias")
	if value.Type() != js.TypeNull && value.Type() != js.TypeUndefined {
		__tmp := (value).Float()
		ret = &__tmp
	}
	return ret
}
